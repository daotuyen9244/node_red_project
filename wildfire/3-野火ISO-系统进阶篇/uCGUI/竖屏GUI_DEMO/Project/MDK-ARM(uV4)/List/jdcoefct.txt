; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdcoefct.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdcoefct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jdcoefct.c]
                          THUMB

                          AREA ||i.consume_data||, CODE, READONLY, ALIGN=1

                  consume_data PROC
;;;244    METHODDEF(int)
;;;245    consume_data (j_decompress_ptr cinfo)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;246    {
000004  b089              SUB      sp,sp,#0x24
000006  4604              MOV      r4,r0
;;;247      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
000008  f8d451ac          LDR      r5,[r4,#0x1ac]
;;;248      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;249      int blkn, ci, xindex, yindex, yoffset;
;;;250      JDIMENSION start_col;
;;;251      JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
;;;252      JBLOCKROW buffer_ptr;
;;;253      jpeg_component_info *compptr;
;;;254    
;;;255      /* Align the virtual buffers for the components used in this scan. */
;;;256      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
00000c  2600              MOVS     r6,#0
00000e  e01a              B        |L1.70|
                  |L1.16|
;;;257        compptr = cinfo->cur_comp_info[ci];
000010  f50470a6          ADD      r0,r4,#0x14c
000014  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;258        buffer[ci] = (*cinfo->mem->access_virt_barray)
000018  2001              MOVS     r0,#1
00001a  9000              STR      r0,[sp,#0]
00001c  f8d40094          LDR      r0,[r4,#0x94]
000020  f8d7e00c          LDR      lr,[r7,#0xc]
000024  fb00f20e          MUL      r2,r0,lr
000028  4673              MOV      r3,lr
00002a  f1050e48          ADD      lr,r5,#0x48
00002e  6878              LDR      r0,[r7,#4]
000030  f85e1020          LDR      r1,[lr,r0,LSL #2]
000034  6860              LDR      r0,[r4,#4]
000036  f8d0c020          LDR      r12,[r0,#0x20]
00003a  4620              MOV      r0,r4
00003c  47e0              BLX      r12
00003e  a903              ADD      r1,sp,#0xc
000040  f8410026          STR      r0,[r1,r6,LSL #2]
000044  1c76              ADDS     r6,r6,#1              ;256
                  |L1.70|
000046  f8d40148          LDR      r0,[r4,#0x148]        ;256
00004a  42b0              CMP      r0,r6                 ;256
00004c  dce0              BGT      |L1.16|
;;;259          ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
;;;260           cinfo->input_iMCU_row * compptr->v_samp_factor,
;;;261           (JDIMENSION) compptr->v_samp_factor, TRUE);
;;;262        /* Note: entropy decoder expects buffer to be zeroed,
;;;263         * but this is handled automatically by the memory manager
;;;264         * because we requested a pre-zeroed array.
;;;265         */
;;;266      }
;;;267    
;;;268      /* Loop to process one whole iMCU row */
;;;269      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
00004e  f8d58018          LDR      r8,[r5,#0x18]
000052  e053              B        |L1.252|
                  |L1.84|
;;;270           yoffset++) {
;;;271        for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
000054  f8d59014          LDR      r9,[r5,#0x14]
000058  e048              B        |L1.236|
                  |L1.90|
;;;272    	 MCU_col_num++) {
;;;273          /* Construct list of pointers to DCT blocks belonging to this MCU */
;;;274          blkn = 0;			/* index of current DCT block within MCU */
00005a  2000              MOVS     r0,#0
00005c  9008              STR      r0,[sp,#0x20]
;;;275          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
00005e  2600              MOVS     r6,#0
000060  e02e              B        |L1.192|
                  |L1.98|
;;;276    	compptr = cinfo->cur_comp_info[ci];
000062  f50470a6          ADD      r0,r4,#0x14c
000066  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;277    	start_col = MCU_col_num * compptr->MCU_width;
00006a  6b78              LDR      r0,[r7,#0x34]
00006c  fb00f009          MUL      r0,r0,r9
000070  9007              STR      r0,[sp,#0x1c]
;;;278    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
000072  f04f0a00          MOV      r10,#0
000076  e01f              B        |L1.184|
                  |L1.120|
;;;279    	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
000078  a803              ADD      r0,sp,#0xc
00007a  f8500026          LDR      r0,[r0,r6,LSL #2]
00007e  eb0a0108          ADD      r1,r10,r8
000082  f8501021          LDR      r1,[r0,r1,LSL #2]
000086  9807              LDR      r0,[sp,#0x1c]
000088  eb0110c0          ADD      r0,r1,r0,LSL #7
00008c  9002              STR      r0,[sp,#8]
;;;280    	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
00008e  f04f0b00          MOV      r11,#0
000092  e00c              B        |L1.174|
                  |L1.148|
;;;281    	    coef->MCU_buffer[blkn++] = buffer_ptr++;
000094  9808              LDR      r0,[sp,#0x20]
000096  1c42              ADDS     r2,r0,#1
000098  9902              LDR      r1,[sp,#8]
00009a  9208              STR      r2,[sp,#0x20]
00009c  f1050220          ADD      r2,r5,#0x20
0000a0  f8421020          STR      r1,[r2,r0,LSL #2]
0000a4  9802              LDR      r0,[sp,#8]
0000a6  3080              ADDS     r0,r0,#0x80
0000a8  9002              STR      r0,[sp,#8]
0000aa  f10b0b01          ADD      r11,r11,#1            ;280
                  |L1.174|
0000ae  6b78              LDR      r0,[r7,#0x34]         ;280
0000b0  4558              CMP      r0,r11                ;280
0000b2  dcef              BGT      |L1.148|
0000b4  f10a0a01          ADD      r10,r10,#1            ;278
                  |L1.184|
0000b8  6bb8              LDR      r0,[r7,#0x38]         ;278
0000ba  4550              CMP      r0,r10                ;278
0000bc  dcdc              BGT      |L1.120|
0000be  1c76              ADDS     r6,r6,#1              ;275
                  |L1.192|
0000c0  f8d40148          LDR      r0,[r4,#0x148]        ;275
0000c4  42b0              CMP      r0,r6                 ;275
0000c6  dccc              BGT      |L1.98|
;;;282    	  }
;;;283    	}
;;;284          }
;;;285          /* Try to fetch the MCU. */
;;;286          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
0000c8  f8d401bc          LDR      r0,[r4,#0x1bc]
0000cc  f1050120          ADD      r1,r5,#0x20
0000d0  6842              LDR      r2,[r0,#4]
0000d2  4620              MOV      r0,r4
0000d4  4790              BLX      r2
0000d6  b938              CBNZ     r0,|L1.232|
;;;287    	/* Suspension forced; update state counters and exit */
;;;288    	coef->MCU_vert_offset = yoffset;
0000d8  f8c58018          STR      r8,[r5,#0x18]
;;;289    	coef->MCU_ctr = MCU_col_num;
0000dc  f8c59014          STR      r9,[r5,#0x14]
;;;290    	return JPEG_SUSPENDED;
0000e0  2000              MOVS     r0,#0
                  |L1.226|
;;;291          }
;;;292        }
;;;293        /* Completed an MCU row, but perhaps not an iMCU row */
;;;294        coef->MCU_ctr = 0;
;;;295      }
;;;296      /* Completed the iMCU row, advance counters for next one */
;;;297      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;298        start_iMCU_row(cinfo);
;;;299        return JPEG_ROW_COMPLETED;
;;;300      }
;;;301      /* Completed the scan */
;;;302      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;303      return JPEG_SCAN_COMPLETED;
;;;304    }
0000e2  b009              ADD      sp,sp,#0x24
0000e4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.232|
0000e8  f1090901          ADD      r9,r9,#1              ;272
                  |L1.236|
0000ec  f8d4015c          LDR      r0,[r4,#0x15c]        ;271
0000f0  4548              CMP      r0,r9                 ;271
0000f2  d8b2              BHI      |L1.90|
0000f4  2000              MOVS     r0,#0                 ;294
0000f6  6168              STR      r0,[r5,#0x14]         ;294
0000f8  f1080801          ADD      r8,r8,#1              ;270
                  |L1.252|
0000fc  69e8              LDR      r0,[r5,#0x1c]         ;269
0000fe  4540              CMP      r0,r8                 ;269
000100  dca8              BGT      |L1.84|
000102  f8d40094          LDR      r0,[r4,#0x94]         ;297
000106  1c40              ADDS     r0,r0,#1              ;297
000108  f8c40094          STR      r0,[r4,#0x94]         ;297
00010c  f8d41140          LDR      r1,[r4,#0x140]        ;297
000110  4288              CMP      r0,r1                 ;297
000112  d204              BCS      |L1.286|
000114  4620              MOV      r0,r4                 ;298
000116  f7fffffe          BL       start_iMCU_row
00011a  2003              MOVS     r0,#3                 ;299
00011c  e7e1              B        |L1.226|
                  |L1.286|
00011e  f8d401b4          LDR      r0,[r4,#0x1b4]        ;302
000122  68c1              LDR      r1,[r0,#0xc]          ;302
000124  4620              MOV      r0,r4                 ;302
000126  4788              BLX      r1                    ;302
000128  2004              MOVS     r0,#4                 ;303
00012a  e7da              B        |L1.226|
;;;305    
                          ENDP


                          AREA ||i.decompress_data||, CODE, READONLY, ALIGN=1

                  decompress_data PROC
;;;315    METHODDEF(int)
;;;316    decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;317    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;318      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
00000a  f8d401ac          LDR      r0,[r4,#0x1ac]
00000e  9006              STR      r0,[sp,#0x18]
;;;319      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000010  f8d40140          LDR      r0,[r4,#0x140]
000014  1e40              SUBS     r0,r0,#1
000016  9005              STR      r0,[sp,#0x14]
;;;320      JDIMENSION block_num;
;;;321      int ci, block_row, block_rows;
;;;322      JBLOCKARRAY buffer;
;;;323      JBLOCKROW buffer_ptr;
;;;324      JSAMPARRAY output_ptr;
;;;325      JDIMENSION output_col;
;;;326      jpeg_component_info *compptr;
;;;327      inverse_DCT_method_ptr inverse_DCT;
;;;328    
;;;329      /* Force some input to be done if we are getting ahead of the input. */
;;;330      while (cinfo->input_scan_number < cinfo->output_scan_number ||
000018  e009              B        |L2.46|
                  |L2.26|
;;;331    	 (cinfo->input_scan_number == cinfo->output_scan_number &&
;;;332    	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
;;;333        if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
00001a  f8d401b4          LDR      r0,[r4,#0x1b4]
00001e  6801              LDR      r1,[r0,#0]
000020  4620              MOV      r0,r4
000022  4788              BLX      r1
000024  b918              CBNZ     r0,|L2.46|
;;;334          return JPEG_SUSPENDED;
000026  2000              MOVS     r0,#0
                  |L2.40|
;;;335      }
;;;336    
;;;337      /* OK, output from the virtual arrays. */
;;;338      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;339           ci++, compptr++) {
;;;340        /* Don't bother to IDCT an uninteresting component. */
;;;341        if (! compptr->component_needed)
;;;342          continue;
;;;343        /* Align the virtual buffer for this component. */
;;;344        buffer = (*cinfo->mem->access_virt_barray)
;;;345          ((j_common_ptr) cinfo, coef->whole_image[ci],
;;;346           cinfo->output_iMCU_row * compptr->v_samp_factor,
;;;347           (JDIMENSION) compptr->v_samp_factor, FALSE);
;;;348        /* Count non-dummy DCT block rows in this iMCU row. */
;;;349        if (cinfo->output_iMCU_row < last_iMCU_row)
;;;350          block_rows = compptr->v_samp_factor;
;;;351        else {
;;;352          /* NB: can't use last_row_height here; it is input-side-dependent! */
;;;353          block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
;;;354          if (block_rows == 0) block_rows = compptr->v_samp_factor;
;;;355        }
;;;356        inverse_DCT = cinfo->idct->inverse_DCT[ci];
;;;357        output_ptr = output_buf[ci];
;;;358        /* Loop over all DCT blocks to be processed. */
;;;359        for (block_row = 0; block_row < block_rows; block_row++) {
;;;360          buffer_ptr = buffer[block_row];
;;;361          output_col = 0;
;;;362          for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
;;;363    	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
;;;364    			output_ptr, output_col);
;;;365    	buffer_ptr++;
;;;366    	output_col += compptr->DCT_scaled_size;
;;;367          }
;;;368          output_ptr += compptr->DCT_scaled_size;
;;;369        }
;;;370      }
;;;371    
;;;372      if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
;;;373        return JPEG_ROW_COMPLETED;
;;;374      return JPEG_SCAN_COMPLETED;
;;;375    }
000028  b007              ADD      sp,sp,#0x1c
00002a  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.46|
00002e  f8d41098          LDR      r1,[r4,#0x98]         ;330
000032  f8d40090          LDR      r0,[r4,#0x90]         ;330
000036  4288              CMP      r0,r1                 ;330
000038  dbef              BLT      |L2.26|
00003a  f8d41098          LDR      r1,[r4,#0x98]         ;331
00003e  f8d40090          LDR      r0,[r4,#0x90]         ;331
000042  4288              CMP      r0,r1                 ;331
000044  d105              BNE      |L2.82|
000046  f8d4109c          LDR      r1,[r4,#0x9c]         ;332
00004a  f8d40094          LDR      r0,[r4,#0x94]         ;332
00004e  4288              CMP      r0,r1                 ;332
000050  d9e3              BLS      |L2.26|
                  |L2.82|
000052  2600              MOVS     r6,#0                 ;338
000054  f8d450d8          LDR      r5,[r4,#0xd8]         ;338
000058  e058              B        |L2.268|
                  |L2.90|
00005a  6b28              LDR      r0,[r5,#0x30]         ;341
00005c  b900              CBNZ     r0,|L2.96|
00005e  e053              B        |L2.264|
                  |L2.96|
000060  2000              MOVS     r0,#0                 ;344
000062  9000              STR      r0,[sp,#0]            ;344
000064  f8d4009c          LDR      r0,[r4,#0x9c]         ;344
000068  f8d5e00c          LDR      lr,[r5,#0xc]          ;344
00006c  fb00f20e          MUL      r2,r0,lr              ;344
000070  4673              MOV      r3,lr                 ;344
000072  9806              LDR      r0,[sp,#0x18]         ;344
000074  3048              ADDS     r0,r0,#0x48           ;344
000076  f8501026          LDR      r1,[r0,r6,LSL #2]     ;344
00007a  6860              LDR      r0,[r4,#4]            ;344
00007c  f8d0c020          LDR      r12,[r0,#0x20]        ;344
000080  4620              MOV      r0,r4                 ;344
000082  47e0              BLX      r12                   ;344
000084  4680              MOV      r8,r0                 ;344
000086  f8d4109c          LDR      r1,[r4,#0x9c]         ;349
00008a  9805              LDR      r0,[sp,#0x14]         ;349
00008c  4281              CMP      r1,r0                 ;349
00008e  d202              BCS      |L2.150|
000090  68e8              LDR      r0,[r5,#0xc]          ;350
000092  9004              STR      r0,[sp,#0x10]         ;350
000094  e00a              B        |L2.172|
                  |L2.150|
000096  68e9              LDR      r1,[r5,#0xc]          ;353
000098  6a28              LDR      r0,[r5,#0x20]         ;353
00009a  fbb0f2f1          UDIV     r2,r0,r1              ;353
00009e  fb010012          MLS      r0,r1,r2,r0           ;353
0000a2  9004              STR      r0,[sp,#0x10]         ;353
0000a4  9804              LDR      r0,[sp,#0x10]         ;354
0000a6  b908              CBNZ     r0,|L2.172|
0000a8  68e8              LDR      r0,[r5,#0xc]          ;354
0000aa  9004              STR      r0,[sp,#0x10]         ;354
                  |L2.172|
0000ac  f8d401c0          LDR      r0,[r4,#0x1c0]        ;356
0000b0  1d00              ADDS     r0,r0,#4              ;356
0000b2  f850b026          LDR      r11,[r0,r6,LSL #2]    ;356
0000b6  f8590026          LDR      r0,[r9,r6,LSL #2]     ;357
0000ba  9002              STR      r0,[sp,#8]            ;357
0000bc  2700              MOVS     r7,#0                 ;359
0000be  e01f              B        |L2.256|
                  |L2.192|
0000c0  f8580027          LDR      r0,[r8,r7,LSL #2]     ;360
0000c4  9003              STR      r0,[sp,#0xc]          ;360
0000c6  2000              MOVS     r0,#0                 ;361
0000c8  9001              STR      r0,[sp,#4]            ;361
0000ca  4682              MOV      r10,r0                ;362
0000cc  e00f              B        |L2.238|
                  |L2.206|
0000ce  9801              LDR      r0,[sp,#4]            ;363
0000d0  9000              STR      r0,[sp,#0]            ;363
0000d2  4629              MOV      r1,r5                 ;363
0000d4  4620              MOV      r0,r4                 ;363
0000d6  e9dd3202          LDRD     r3,r2,[sp,#8]         ;363
0000da  47d8              BLX      r11                   ;363
0000dc  9803              LDR      r0,[sp,#0xc]          ;365
0000de  3080              ADDS     r0,r0,#0x80           ;365
0000e0  9003              STR      r0,[sp,#0xc]          ;365
0000e2  6a69              LDR      r1,[r5,#0x24]         ;366
0000e4  9801              LDR      r0,[sp,#4]            ;366
0000e6  4408              ADD      r0,r0,r1              ;366
0000e8  9001              STR      r0,[sp,#4]            ;366
0000ea  f10a0a01          ADD      r10,r10,#1            ;362
                  |L2.238|
0000ee  69e8              LDR      r0,[r5,#0x1c]         ;362
0000f0  4550              CMP      r0,r10                ;362
0000f2  d8ec              BHI      |L2.206|
0000f4  6a69              LDR      r1,[r5,#0x24]         ;368
0000f6  9802              LDR      r0,[sp,#8]            ;368
0000f8  eb000081          ADD      r0,r0,r1,LSL #2       ;368
0000fc  9002              STR      r0,[sp,#8]            ;368
0000fe  1c7f              ADDS     r7,r7,#1              ;359
                  |L2.256|
000100  9804              LDR      r0,[sp,#0x10]         ;359
000102  4287              CMP      r7,r0                 ;359
000104  dbdc              BLT      |L2.192|
000106  bf00              NOP                            ;342
                  |L2.264|
000108  1c76              ADDS     r6,r6,#1              ;339
00010a  3554              ADDS     r5,r5,#0x54           ;339
                  |L2.268|
00010c  6a60              LDR      r0,[r4,#0x24]         ;338
00010e  42b0              CMP      r0,r6                 ;338
000110  dca3              BGT      |L2.90|
000112  f8d4009c          LDR      r0,[r4,#0x9c]         ;372
000116  1c40              ADDS     r0,r0,#1              ;372
000118  f8c4009c          STR      r0,[r4,#0x9c]         ;372
00011c  f8d41140          LDR      r1,[r4,#0x140]        ;372
000120  4288              CMP      r0,r1                 ;372
000122  d201              BCS      |L2.296|
000124  2003              MOVS     r0,#3                 ;373
000126  e77f              B        |L2.40|
                  |L2.296|
000128  2004              MOVS     r0,#4                 ;374
00012a  e77d              B        |L2.40|
;;;376    
                          ENDP


                          AREA ||i.decompress_onepass||, CODE, READONLY, ALIGN=1

                  decompress_onepass PROC
;;;146    METHODDEF(int)
;;;147    decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;148    {
000004  b089              SUB      sp,sp,#0x24
000006  4604              MOV      r4,r0
;;;149      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
000008  f8d461ac          LDR      r6,[r4,#0x1ac]
;;;150      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;151      JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
00000c  f8d4015c          LDR      r0,[r4,#0x15c]
000010  1e40              SUBS     r0,r0,#1
000012  9008              STR      r0,[sp,#0x20]
;;;152      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000014  f8d40140          LDR      r0,[r4,#0x140]
000018  1e40              SUBS     r0,r0,#1
00001a  9007              STR      r0,[sp,#0x1c]
;;;153      int blkn, ci, xindex, yindex, yoffset, useful_width;
;;;154      JSAMPARRAY output_ptr;
;;;155      JDIMENSION start_col, output_col;
;;;156      jpeg_component_info *compptr;
;;;157      inverse_DCT_method_ptr inverse_DCT;
;;;158    
;;;159      /* Loop to process as much as one whole iMCU row */
;;;160      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
00001c  f8d68018          LDR      r8,[r6,#0x18]
000020  e084              B        |L3.300|
                  |L3.34|
;;;161           yoffset++) {
;;;162        for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
000022  6977              LDR      r7,[r6,#0x14]
000024  e07b              B        |L3.286|
                  |L3.38|
;;;163    	 MCU_col_num++) {
;;;164          /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
;;;165          jzero_far((void FAR *) coef->MCU_buffer[0],
000026  f8d42164          LDR      r2,[r4,#0x164]
00002a  01d1              LSLS     r1,r2,#7
00002c  6a30              LDR      r0,[r6,#0x20]
00002e  f7fffffe          BL       jzero_far
;;;166    		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
;;;167          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
000032  f8d401bc          LDR      r0,[r4,#0x1bc]
000036  f1060120          ADD      r1,r6,#0x20
00003a  6842              LDR      r2,[r0,#4]
00003c  4620              MOV      r0,r4
00003e  4790              BLX      r2
000040  b930              CBNZ     r0,|L3.80|
;;;168    	/* Suspension forced; update state counters and exit */
;;;169    	coef->MCU_vert_offset = yoffset;
000042  f8c68018          STR      r8,[r6,#0x18]
;;;170    	coef->MCU_ctr = MCU_col_num;
000046  6177              STR      r7,[r6,#0x14]
;;;171    	return JPEG_SUSPENDED;
000048  2000              MOVS     r0,#0
                  |L3.74|
;;;172          }
;;;173          /* Determine where data should go in output_buf and do the IDCT thing.
;;;174           * We skip dummy blocks at the right and bottom edges (but blkn gets
;;;175           * incremented past them!).  Note the inner loop relies on having
;;;176           * allocated the MCU_buffer[] blocks sequentially.
;;;177           */
;;;178          blkn = 0;			/* index of current DCT block within MCU */
;;;179          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
;;;180    	compptr = cinfo->cur_comp_info[ci];
;;;181    	/* Don't bother to IDCT an uninteresting component. */
;;;182    	if (! compptr->component_needed) {
;;;183    	  blkn += compptr->MCU_blocks;
;;;184    	  continue;
;;;185    	}
;;;186    	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
;;;187    	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
;;;188    						    : compptr->last_col_width;
;;;189    	output_ptr = output_buf[compptr->component_index] +
;;;190    	  yoffset * compptr->DCT_scaled_size;
;;;191    	start_col = MCU_col_num * compptr->MCU_sample_width;
;;;192    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
;;;193    	  if (cinfo->input_iMCU_row < last_iMCU_row ||
;;;194    	      yoffset+yindex < compptr->last_row_height) {
;;;195    	    output_col = start_col;
;;;196    	    for (xindex = 0; xindex < useful_width; xindex++) {
;;;197    	      (*inverse_DCT) (cinfo, compptr,
;;;198    			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
;;;199    			      output_ptr, output_col);
;;;200    	      output_col += compptr->DCT_scaled_size;
;;;201    	    }
;;;202    	  }
;;;203    	  blkn += compptr->MCU_width;
;;;204    	  output_ptr += compptr->DCT_scaled_size;
;;;205    	}
;;;206          }
;;;207        }
;;;208        /* Completed an MCU row, but perhaps not an iMCU row */
;;;209        coef->MCU_ctr = 0;
;;;210      }
;;;211      /* Completed the iMCU row, advance counters for next one */
;;;212      cinfo->output_iMCU_row++;
;;;213      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;214        start_iMCU_row(cinfo);
;;;215        return JPEG_ROW_COMPLETED;
;;;216      }
;;;217      /* Completed the scan */
;;;218      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;219      return JPEG_SCAN_COMPLETED;
;;;220    }
00004a  b00b              ADD      sp,sp,#0x2c
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.80|
000050  f04f0900          MOV      r9,#0                 ;178
000054  46ca              MOV      r10,r9                ;179
000056  e05d              B        |L3.276|
                  |L3.88|
000058  f50470a6          ADD      r0,r4,#0x14c          ;180
00005c  f850502a          LDR      r5,[r0,r10,LSL #2]    ;180
000060  6b28              LDR      r0,[r5,#0x30]         ;182
000062  b910              CBNZ     r0,|L3.106|
000064  6be8              LDR      r0,[r5,#0x3c]         ;183
000066  4481              ADD      r9,r9,r0              ;183
000068  e052              B        |L3.272|
                  |L3.106|
00006a  f8d401c0          LDR      r0,[r4,#0x1c0]        ;186
00006e  1d00              ADDS     r0,r0,#4              ;186
000070  6869              LDR      r1,[r5,#4]            ;186
000072  f8500021          LDR      r0,[r0,r1,LSL #2]     ;186
000076  9001              STR      r0,[sp,#4]            ;186
000078  9808              LDR      r0,[sp,#0x20]         ;187
00007a  4287              CMP      r7,r0                 ;187
00007c  d201              BCS      |L3.130|
00007e  6b68              LDR      r0,[r5,#0x34]         ;187
000080  e000              B        |L3.132|
                  |L3.130|
000082  6c68              LDR      r0,[r5,#0x44]         ;188
                  |L3.132|
000084  9005              STR      r0,[sp,#0x14]         ;188
000086  6869              LDR      r1,[r5,#4]            ;189
000088  980a              LDR      r0,[sp,#0x28]         ;189
00008a  f8501021          LDR      r1,[r0,r1,LSL #2]     ;189
00008e  6a68              LDR      r0,[r5,#0x24]         ;189
000090  fb00f008          MUL      r0,r0,r8              ;189
000094  eb010080          ADD      r0,r1,r0,LSL #2       ;189
000098  9004              STR      r0,[sp,#0x10]         ;189
00009a  6c28              LDR      r0,[r5,#0x40]         ;191
00009c  4378              MULS     r0,r7,r0              ;191
00009e  9003              STR      r0,[sp,#0xc]          ;191
0000a0  2000              MOVS     r0,#0                 ;192
0000a2  9006              STR      r0,[sp,#0x18]         ;192
0000a4  e02f              B        |L3.262|
                  |L3.166|
0000a6  f8d41094          LDR      r1,[r4,#0x94]         ;193
0000aa  9807              LDR      r0,[sp,#0x1c]         ;193
0000ac  4281              CMP      r1,r0                 ;193
0000ae  d304              BCC      |L3.186|
0000b0  9806              LDR      r0,[sp,#0x18]         ;194
0000b2  4440              ADD      r0,r0,r8              ;194
0000b4  6ca9              LDR      r1,[r5,#0x48]         ;194
0000b6  4288              CMP      r0,r1                 ;194
0000b8  da1b              BGE      |L3.242|
                  |L3.186|
0000ba  9803              LDR      r0,[sp,#0xc]          ;195
0000bc  9002              STR      r0,[sp,#8]            ;195
0000be  f04f0b00          MOV      r11,#0                ;196
0000c2  e013              B        |L3.236|
                  |L3.196|
0000c4  9802              LDR      r0,[sp,#8]            ;197
0000c6  eb09010b          ADD      r1,r9,r11             ;197
0000ca  9000              STR      r0,[sp,#0]            ;197
0000cc  f1060020          ADD      r0,r6,#0x20           ;197
0000d0  f8502021          LDR      r2,[r0,r1,LSL #2]     ;197
0000d4  4629              MOV      r1,r5                 ;197
0000d6  4620              MOV      r0,r4                 ;197
0000d8  f8ddc004          LDR      r12,[sp,#4]           ;197
0000dc  9b04              LDR      r3,[sp,#0x10]         ;197
0000de  47e0              BLX      r12                   ;197
0000e0  6a69              LDR      r1,[r5,#0x24]         ;200
0000e2  9802              LDR      r0,[sp,#8]            ;200
0000e4  4408              ADD      r0,r0,r1              ;200
0000e6  9002              STR      r0,[sp,#8]            ;200
0000e8  f10b0b01          ADD      r11,r11,#1            ;196
                  |L3.236|
0000ec  9805              LDR      r0,[sp,#0x14]         ;196
0000ee  4583              CMP      r11,r0                ;196
0000f0  dbe8              BLT      |L3.196|
                  |L3.242|
0000f2  6b68              LDR      r0,[r5,#0x34]         ;203
0000f4  4481              ADD      r9,r9,r0              ;203
0000f6  6a69              LDR      r1,[r5,#0x24]         ;204
0000f8  9804              LDR      r0,[sp,#0x10]         ;204
0000fa  eb000081          ADD      r0,r0,r1,LSL #2       ;204
0000fe  9004              STR      r0,[sp,#0x10]         ;204
000100  9806              LDR      r0,[sp,#0x18]         ;192
000102  1c40              ADDS     r0,r0,#1              ;192
000104  9006              STR      r0,[sp,#0x18]         ;192
                  |L3.262|
000106  6ba9              LDR      r1,[r5,#0x38]         ;192
000108  9806              LDR      r0,[sp,#0x18]         ;192
00010a  4281              CMP      r1,r0                 ;192
00010c  dccb              BGT      |L3.166|
00010e  bf00              NOP                            ;184
                  |L3.272|
000110  f10a0a01          ADD      r10,r10,#1            ;179
                  |L3.276|
000114  f8d40148          LDR      r0,[r4,#0x148]        ;179
000118  4550              CMP      r0,r10                ;179
00011a  dc9d              BGT      |L3.88|
00011c  1c7f              ADDS     r7,r7,#1              ;163
                  |L3.286|
00011e  9808              LDR      r0,[sp,#0x20]         ;162
000120  4287              CMP      r7,r0                 ;162
000122  d980              BLS      |L3.38|
000124  2000              MOVS     r0,#0                 ;209
000126  6170              STR      r0,[r6,#0x14]         ;209
000128  f1080801          ADD      r8,r8,#1              ;161
                  |L3.300|
00012c  69f0              LDR      r0,[r6,#0x1c]         ;160
00012e  4540              CMP      r0,r8                 ;160
000130  f73faf77          BGT      |L3.34|
000134  f1040494          ADD      r4,r4,#0x94           ;212
000138  68a0              LDR      r0,[r4,#8]            ;212
00013a  f1000001          ADD      r0,r0,#1              ;212
00013e  60a0              STR      r0,[r4,#8]            ;212
000140  6820              LDR      r0,[r4,#0]            ;213
000142  f1000001          ADD      r0,r0,#1              ;213
000146  6020              STR      r0,[r4,#0]            ;213
000148  f8d410ac          LDR      r1,[r4,#0xac]         ;213
00014c  f1a40494          SUB      r4,r4,#0x94           ;213
000150  4288              CMP      r0,r1                 ;213
000152  d204              BCS      |L3.350|
000154  4620              MOV      r0,r4                 ;214
000156  f7fffffe          BL       start_iMCU_row
00015a  2003              MOVS     r0,#3                 ;215
00015c  e775              B        |L3.74|
                  |L3.350|
00015e  f8d401b4          LDR      r0,[r4,#0x1b4]        ;218
000162  68c1              LDR      r1,[r0,#0xc]          ;218
000164  4620              MOV      r0,r4                 ;218
000166  4788              BLX      r1                    ;218
000168  2004              MOVS     r0,#4                 ;219
00016a  e76e              B        |L3.74|
;;;221    
                          ENDP


                          AREA ||i.dummy_consume_data||, CODE, READONLY, ALIGN=1

                  dummy_consume_data PROC
;;;227    METHODDEF(int)
;;;228    dummy_consume_data (j_decompress_ptr cinfo)
000000  4601              MOV      r1,r0
;;;229    {
;;;230      GUI_USE_PARA(cinfo);
000002  bf00              NOP      
;;;231      return JPEG_SUSPENDED;	/* Always indicate nothing was done */
000004  2000              MOVS     r0,#0
;;;232    }
000006  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.jinit_d_coef_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_coef_controller PROC
;;;676    GLOBAL(void)
;;;677    jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;678    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;679      my_coef_ptr coef;
;;;680    
;;;681      coef = (my_coef_ptr)
000008  6868              LDR      r0,[r5,#4]
00000a  2258              MOVS     r2,#0x58
00000c  2101              MOVS     r1,#1
00000e  6803              LDR      r3,[r0,#0]
000010  4628              MOV      r0,r5
000012  4798              BLX      r3
000014  4604              MOV      r4,r0
;;;682        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;683    				SIZEOF(my_coef_controller));
;;;684      cinfo->coef = (struct jpeg_d_coef_controller *) coef;
000016  f8c541ac          STR      r4,[r5,#0x1ac]
;;;685      coef->pub.start_input_pass = start_input_pass;
00001a  4827              LDR      r0,|L5.184|
00001c  6020              STR      r0,[r4,#0]
;;;686      coef->pub.start_output_pass = start_output_pass;
00001e  4827              LDR      r0,|L5.188|
000020  60a0              STR      r0,[r4,#8]
;;;687    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;688      coef->coef_bits_latch = NULL;
;;;689    #endif
;;;690    
;;;691      /* Create the coefficient buffer. */
;;;692      if (need_full_buffer) {
000022  f1b80f00          CMP      r8,#0
000026  d02a              BEQ      |L5.126|
;;;693    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;694        /* Allocate a full-image virtual array for each component, */
;;;695        /* padded to a multiple of samp_factor DCT blocks in each direction. */
;;;696        /* Note we ask for a pre-zeroed array. */
;;;697        int ci, access_rows;
;;;698        jpeg_component_info *compptr;
;;;699    
;;;700        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000028  2700              MOVS     r7,#0
00002a  f8d560d8          LDR      r6,[r5,#0xd8]
00002e  e01b              B        |L5.104|
                  |L5.48|
;;;701    	 ci++, compptr++) {
;;;702          access_rows = compptr->v_samp_factor;
000030  f8d6900c          LDR      r9,[r6,#0xc]
;;;703    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;704          /* If block smoothing could be used, need a bigger window */
;;;705          if (cinfo->progressive_mode)
;;;706    	access_rows *= 3;
;;;707    #endif
;;;708          coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
000034  68f1              LDR      r1,[r6,#0xc]
000036  6a30              LDR      r0,[r6,#0x20]
000038  f7fffffe          BL       jround_up
00003c  4682              MOV      r10,r0
00003e  68b1              LDR      r1,[r6,#8]
000040  69f0              LDR      r0,[r6,#0x1c]
000042  f7fffffe          BL       jround_up
000046  4683              MOV      r11,r0
000048  e9cda900          STRD     r10,r9,[sp,#0]
00004c  6868              LDR      r0,[r5,#4]
00004e  465b              MOV      r3,r11
000050  2201              MOVS     r2,#1
000052  4611              MOV      r1,r2
000054  f8d0c014          LDR      r12,[r0,#0x14]
000058  4628              MOV      r0,r5
00005a  47e0              BLX      r12
00005c  f1040148          ADD      r1,r4,#0x48
000060  f8410027          STR      r0,[r1,r7,LSL #2]
000064  1c7f              ADDS     r7,r7,#1              ;701
000066  3654              ADDS     r6,r6,#0x54           ;701
                  |L5.104|
000068  6a68              LDR      r0,[r5,#0x24]         ;700
00006a  42b8              CMP      r0,r7                 ;700
00006c  dce0              BGT      |L5.48|
;;;709    	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
;;;710    	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
;;;711    				(long) compptr->h_samp_factor),
;;;712    	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
;;;713    				(long) compptr->v_samp_factor),
;;;714    	 (JDIMENSION) access_rows);
;;;715        }
;;;716        coef->pub.consume_data = consume_data;
00006e  4814              LDR      r0,|L5.192|
000070  6060              STR      r0,[r4,#4]
;;;717        coef->pub.decompress_data = decompress_data;
000072  4814              LDR      r0,|L5.196|
000074  60e0              STR      r0,[r4,#0xc]
;;;718        coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
000076  f1040048          ADD      r0,r4,#0x48
00007a  6120              STR      r0,[r4,#0x10]
;;;719    #else
;;;720        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;721    #endif
;;;722      } else {
00007c  e019              B        |L5.178|
                  |L5.126|
;;;723        /* We only need a single-MCU buffer. */
;;;724        JBLOCKROW buffer;
;;;725        int i;
;;;726    
;;;727        buffer = (JBLOCKROW)
00007e  6868              LDR      r0,[r5,#4]
000080  f44f62a0          MOV      r2,#0x500
000084  2101              MOVS     r1,#1
000086  6843              LDR      r3,[r0,#4]
000088  4628              MOV      r0,r5
00008a  4798              BLX      r3
00008c  4607              MOV      r7,r0
;;;728          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;729    				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
;;;730        for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
00008e  2600              MOVS     r6,#0
000090  e006              B        |L5.160|
                  |L5.146|
;;;731          coef->MCU_buffer[i] = buffer + i;
000092  eb0711c6          ADD      r1,r7,r6,LSL #7
000096  f1040020          ADD      r0,r4,#0x20
00009a  f8401026          STR      r1,[r0,r6,LSL #2]
00009e  1c76              ADDS     r6,r6,#1              ;730
                  |L5.160|
0000a0  2e0a              CMP      r6,#0xa               ;730
0000a2  dbf6              BLT      |L5.146|
;;;732        }
;;;733        coef->pub.consume_data = dummy_consume_data;
0000a4  4808              LDR      r0,|L5.200|
0000a6  6060              STR      r0,[r4,#4]
;;;734        coef->pub.decompress_data = decompress_onepass;
0000a8  4808              LDR      r0,|L5.204|
0000aa  60e0              STR      r0,[r4,#0xc]
;;;735        coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
0000ac  2000              MOVS     r0,#0
0000ae  6120              STR      r0,[r4,#0x10]
;;;736      }
0000b0  bf00              NOP      
                  |L5.178|
;;;737    }
0000b2  e8bd9ffc          POP      {r2-r12,pc}
                          ENDP

0000b6  0000              DCW      0x0000
                  |L5.184|
                          DCD      start_input_pass
                  |L5.188|
                          DCD      start_output_pass
                  |L5.192|
                          DCD      consume_data
                  |L5.196|
                          DCD      decompress_data
                  |L5.200|
                          DCD      dummy_consume_data
                  |L5.204|
                          DCD      decompress_onepass

                          AREA ||i.start_iMCU_row||, CODE, READONLY, ALIGN=1

                  start_iMCU_row PROC
;;;78     LOCAL(void)
;;;79     start_iMCU_row (j_decompress_ptr cinfo)
000000  f8d011ac          LDR      r1,[r0,#0x1ac]
;;;80     /* Reset within-iMCU-row counters for a new row (input side) */
;;;81     {
;;;82       my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;83     
;;;84       /* In an interleaved scan, an MCU row is the same as an iMCU row.
;;;85        * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
;;;86        * But at the bottom of the image, process only what's left.
;;;87        */
;;;88       if (cinfo->comps_in_scan > 1) {
000004  f8d02148          LDR      r2,[r0,#0x148]
000008  2a01              CMP      r2,#1
00000a  dd02              BLE      |L6.18|
;;;89         coef->MCU_rows_per_iMCU_row = 1;
00000c  2201              MOVS     r2,#1
00000e  61ca              STR      r2,[r1,#0x1c]
000010  e00f              B        |L6.50|
                  |L6.18|
;;;90       } else {
;;;91         if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
000012  f8d02140          LDR      r2,[r0,#0x140]
000016  1e52              SUBS     r2,r2,#1
000018  f8d03094          LDR      r3,[r0,#0x94]
00001c  4293              CMP      r3,r2
00001e  d204              BCS      |L6.42|
;;;92           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
000020  f8d0214c          LDR      r2,[r0,#0x14c]
000024  68d2              LDR      r2,[r2,#0xc]
000026  61ca              STR      r2,[r1,#0x1c]
000028  e003              B        |L6.50|
                  |L6.42|
;;;93         else
;;;94           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
00002a  f8d0214c          LDR      r2,[r0,#0x14c]
00002e  6c92              LDR      r2,[r2,#0x48]
000030  61ca              STR      r2,[r1,#0x1c]
                  |L6.50|
;;;95       }
;;;96     
;;;97       coef->MCU_ctr = 0;
000032  2200              MOVS     r2,#0
000034  614a              STR      r2,[r1,#0x14]
;;;98       coef->MCU_vert_offset = 0;
000036  618a              STR      r2,[r1,#0x18]
;;;99     }
000038  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.start_input_pass||, CODE, READONLY, ALIGN=1

                  start_input_pass PROC
;;;106    METHODDEF(void)
;;;107    start_input_pass (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4604              MOV      r4,r0
;;;109      cinfo->input_iMCU_row = 0;
000004  2000              MOVS     r0,#0
000006  f8c40094          STR      r0,[r4,#0x94]
;;;110      start_iMCU_row(cinfo);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       start_iMCU_row
;;;111    }
000010  bd10              POP      {r4,pc}
;;;112    
                          ENDP


                          AREA ||i.start_output_pass||, CODE, READONLY, ALIGN=1

                  start_output_pass PROC
;;;118    METHODDEF(void)
;;;119    start_output_pass (j_decompress_ptr cinfo)
000000  2100              MOVS     r1,#0
;;;120    {
;;;121    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;122      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;123    
;;;124      /* If multipass, check to see whether to use block smoothing on this pass */
;;;125      if (coef->pub.coef_arrays != NULL) {
;;;126        if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
;;;127          coef->pub.decompress_data = decompress_smooth_data;
;;;128        else
;;;129          coef->pub.decompress_data = decompress_data;
;;;130      }
;;;131    #endif
;;;132      cinfo->output_iMCU_row = 0;
000002  f8c0109c          STR      r1,[r0,#0x9c]
;;;133    }
000006  4770              BX       lr
;;;134    
                          ENDP

