; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\guidev_usagebm.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\guidev_usagebm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\MemDev\GUIDEV_UsageBM.c]
                          THUMB

                          AREA ||i.GUI_USAGE_BM_AddHLine||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_AddHLine PROC
;;;75     */
;;;76     static void GUI_USAGE_BM_AddHLine(GUI_USAGE* p, int x, int y, int len) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b081              SUB      sp,sp,#4
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4691              MOV      r9,r2
;;;77     #if 0   /* Enable for the slower, but smaller version ... xxx*/
;;;78       while (len-- >0)
;;;79         GUI_USAGE_BM_AddPixel(h, x++,y);
;;;80     #else
;;;81       U8* pData;
;;;82       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
00000c  462f              MOV      r7,r5
;;;83       /* Asserts */
;;;84       GUI_DEBUG_ERROROUT3_IF( x<pThis->Public.x0, "GUIDEV.c: MarkPixels: negative x offset, Act= %d, Border= %d, Clip= %d"
;;;85                         ,x, pThis->Public.x0, GUI_Context.ClipRect.x0);
;;;86       /* Calculate pointers */
;;;87       x -= pThis->Public.x0;
00000e  f9b70000          LDRSH    r0,[r7,#0]
000012  1a36              SUBS     r6,r6,r0
;;;88       pData =  (U8*)(pThis+1); 
000014  f1070414          ADD      r4,r7,#0x14
;;;89       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000018  f9b70002          LDRSH    r0,[r7,#2]
00001c  eba90000          SUB      r0,r9,r0
000020  6939              LDR      r1,[r7,#0x10]
000022  fb004401          MLA      r4,r0,r1,r4
;;;90       pData += x>>3;
000026  eb0404e6          ADD      r4,r4,r6,ASR #3
;;;91       /* Set bits */
;;;92       {  
;;;93         int x1 = x+len-1;   /* last pixel */
00002a  9804              LDR      r0,[sp,#0x10]
00002c  4430              ADD      r0,r0,r6
00002e  1e40              SUBS     r0,r0,#1
000030  9000              STR      r0,[sp,#0]
;;;94         int NumBytes = (x1>>3) - (x>>3);
000032  9800              LDR      r0,[sp,#0]
000034  10c0              ASRS     r0,r0,#3
000036  eba008e6          SUB      r8,r0,r6,ASR #3
;;;95         U8 Mask0 = 0xff >> (x&7);
00003a  f0060107          AND      r1,r6,#7
00003e  20ff              MOVS     r0,#0xff
000040  fa40fa01          ASR      r10,r0,r1
;;;96         U8 Mask1 = 0xff << (7-(x1&7));
000044  9800              LDR      r0,[sp,#0]
000046  f0000007          AND      r0,r0,#7
00004a  f1c00107          RSB      r1,r0,#7
00004e  20ff              MOVS     r0,#0xff
000050  4088              LSLS     r0,r0,r1
000052  f0000bff          AND      r11,r0,#0xff
;;;97         if (NumBytes ==0) {
000056  f1b80f00          CMP      r8,#0
00005a  d105              BNE      |L1.104|
;;;98           *pData |= (Mask0&Mask1);
00005c  7820              LDRB     r0,[r4,#0]
00005e  ea0a010b          AND      r1,r10,r11
000062  4308              ORRS     r0,r0,r1
000064  7020              STRB     r0,[r4,#0]
000066  e013              B        |L1.144|
                  |L1.104|
;;;99         } else {
;;;100          *pData++ |= Mask0;               /* Mark first byte */
000068  7820              LDRB     r0,[r4,#0]
00006a  ea40000a          ORR      r0,r0,r10
00006e  f8040b01          STRB     r0,[r4],#1
;;;101          /* Mark middle bytes */
;;;102          if (--NumBytes > 0) {
000072  f1a80001          SUB      r0,r8,#1
000076  f1b00800          SUBS     r8,r0,#0
00007a  dd05              BLE      |L1.136|
;;;103            memset (pData, 0xff, NumBytes);
00007c  22ff              MOVS     r2,#0xff
00007e  4641              MOV      r1,r8
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       __aeabi_memset
;;;104            pData += NumBytes;
000086  4444              ADD      r4,r4,r8
                  |L1.136|
;;;105          }
;;;106          *pData |= Mask1;                 /* Mark last bytes */
000088  7820              LDRB     r0,[r4,#0]
00008a  ea40000b          ORR      r0,r0,r11
00008e  7020              STRB     r0,[r4,#0]
                  |L1.144|
;;;107        }
;;;108      }
;;;109    #endif
;;;110    }
000090  b005              ADD      sp,sp,#0x14
000092  e8bd8ff0          POP      {r4-r11,pc}
;;;111    
                          ENDP


                          AREA ||i.GUI_USAGE_BM_AddPixel||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_AddPixel PROC
;;;54     */
;;;55     static void GUI_USAGE_BM_AddPixel(GUI_USAGE* p, int x, int y) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4614              MOV      r4,r2
;;;56       U8* pData;
;;;57       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
000004  4603              MOV      r3,r0
;;;58       #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
;;;59         if ((x >= pThis->Public.x0 + pThis->Public.XSize) | (x < pThis->Public.x0)
;;;60           | (y >= pThis->Public.y0 + pThis->Public.YSize) | (y < pThis->Public.y0))
;;;61         {
;;;62           GUI_DEBUG_ERROROUT2("GUI_USAGE_BM_AddPixel: parameters out of bounds",x,y);
;;;63         }
;;;64       #endif
;;;65       x -= pThis->Public.x0;
000006  f9b35000          LDRSH    r5,[r3,#0]
00000a  1b49              SUBS     r1,r1,r5
;;;66       pData =  (U8*)(pThis+1); 
00000c  f1030214          ADD      r2,r3,#0x14
;;;67       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000010  f9b35002          LDRSH    r5,[r3,#2]
000014  1b65              SUBS     r5,r4,r5
000016  691e              LDR      r6,[r3,#0x10]
000018  fb052206          MLA      r2,r5,r6,r2
;;;68       pData += x>>3;
00001c  eb0202e1          ADD      r2,r2,r1,ASR #3
;;;69       *pData|= 0x80>>(x&7);
000020  7815              LDRB     r5,[r2,#0]
000022  f0010707          AND      r7,r1,#7
000026  2680              MOVS     r6,#0x80
000028  413e              ASRS     r6,r6,r7
00002a  4335              ORRS     r5,r5,r6
00002c  7015              STRB     r5,[r2,#0]
;;;70     }
00002e  bdf0              POP      {r4-r7,pc}
;;;71     
                          ENDP


                          AREA ||i.GUI_USAGE_BM_Clear||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_Clear PROC
;;;115    */
;;;116    static void GUI_USAGE_BM_Clear(GUI_USAGE* p) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;117      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*) p;
000004  4625              MOV      r5,r4
;;;118      memset (pThis+1, 0, pThis->Public.YSize * pThis->Private.BytesPerLine);
000006  f9b50006          LDRSH    r0,[r5,#6]
00000a  692a              LDR      r2,[r5,#0x10]
00000c  fb00f102          MUL      r1,r0,r2
000010  f1050014          ADD      r0,r5,#0x14
000014  f7fffffe          BL       __aeabi_memclr4
;;;119    }
000018  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP


                          AREA ||i.GUI_USAGE_BM_Create||, CODE, READONLY, ALIGN=2

                  GUI_USAGE_BM_Create PROC
;;;214    */
;;;215    GUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;216      int MemSize;
;;;217      int BytesPerLine;
;;;218      GUI_USAGE_Handle hMem;
;;;219      GUI_USE_PARA(Flags);
000010  bf00              NOP      
;;;220      BytesPerLine = ((xsize+15) >>4)<<1;  /* 2 byte alignment */
000012  f105000f          ADD      r0,r5,#0xf
000016  1100              ASRS     r0,r0,#4
000018  ea4f0940          LSL      r9,r0,#1
;;;221      MemSize = ysize*BytesPerLine +sizeof(GUI_USAGE_BM);
00001c  fb06f009          MUL      r0,r6,r9
000020  3014              ADDS     r0,r0,#0x14
000022  9000              STR      r0,[sp,#0]
;;;222      hMem = GUI_ALLOC_AllocZero(MemSize);
000024  9800              LDR      r0,[sp,#0]
000026  b200              SXTH     r0,r0
000028  f7fffffe          BL       GUI_ALLOC_AllocZero
00002c  4682              MOV      r10,r0
;;;223      /* Check if we can alloc sufficient memory */
;;;224      if (!hMem) {
00002e  f1ba0f00          CMP      r10,#0
000032  d102              BNE      |L4.58|
;;;225        GUI_DEBUG_ERROROUT("GUI_USAGE_BM_Create: Too little memory");
;;;226        return 0;    
000034  2000              MOVS     r0,#0
                  |L4.54|
;;;227      }
;;;228      {
;;;229        GUI_USAGE_BM * pUsage;
;;;230        GUI_LOCK();
;;;231        pUsage = (GUI_USAGE_BM*)GUI_ALLOC_h2p(hMem);
;;;232        pUsage->Public.x0    = x0;
;;;233        pUsage->Public.y0    = y0;
;;;234        pUsage->Public.XSize = xsize;
;;;235        pUsage->Public.YSize = ysize;
;;;236        pUsage->Public.pAPI  = &API;
;;;237        pUsage->Public.UseCnt= 1;
;;;238        pUsage->Private.BytesPerLine= BytesPerLine;
;;;239        GUI_UNLOCK();
;;;240      }
;;;241      return hMem;
;;;242    }
000036  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.58|
00003a  f7fffffe          BL       GUI_Lock
00003e  4650              MOV      r0,r10                ;231
000040  f7fffffe          BL       GUI_ALLOC_h2p
000044  4604              MOV      r4,r0                 ;231
000046  b238              SXTH     r0,r7                 ;232
000048  8020              STRH     r0,[r4,#0]            ;232
00004a  fa0ff088          SXTH     r0,r8                 ;233
00004e  8060              STRH     r0,[r4,#2]            ;233
000050  b228              SXTH     r0,r5                 ;234
000052  80a0              STRH     r0,[r4,#4]            ;234
000054  b230              SXTH     r0,r6                 ;235
000056  80e0              STRH     r0,[r4,#6]            ;235
000058  4804              LDR      r0,|L4.108|
00005a  60a0              STR      r0,[r4,#8]            ;236
00005c  2001              MOVS     r0,#1                 ;237
00005e  81a0              STRH     r0,[r4,#0xc]          ;237
000060  f8c49010          STR      r9,[r4,#0x10]         ;238
000064  f7fffffe          BL       GUI_Unlock
000068  4650              MOV      r0,r10                ;241
00006a  e7e4              B        |L4.54|
;;;243    
                          ENDP

                  |L4.108|
                          DCD      API

                          AREA ||i.GUI_USAGE_BM_GetNextDirty||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_GetNextDirty PROC
;;;124    */
;;;125    static int GUI_USAGE_BM_GetNextDirty(GUI_USAGE* p, int *pxOff, int yOff) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4694              MOV      r12,r2
;;;126      int x = *pxOff;
00000a  6839              LDR      r1,[r7,#0]
;;;127      int xEnd;
;;;128      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
00000c  462e              MOV      r6,r5
;;;129      int xSize = pThis->Public.XSize;
00000e  f9b69004          LDRSH    r9,[r6,#4]
;;;130      U8* pData = (U8*)(pThis+1);
000012  f1060214          ADD      r2,r6,#0x14
;;;131      if (yOff >= pThis->Public.YSize) {
000016  f9b60006          LDRSH    r0,[r6,#6]
00001a  4560              CMP      r0,r12
00001c  dc02              BGT      |L5.36|
;;;132        return 0;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;133      }
;;;134      pData += yOff * pThis->Private.BytesPerLine;
;;;135      pData += (x>>3);
;;;136      if (x>=xSize)
;;;137        return 0;
;;;138      {
;;;139    /* Find first bit */
;;;140        int BytesLeft = ((xSize-1) >>3) - (x>>3);
;;;141        /* Check first byte */
;;;142        U8 Data = (*pData++) << (x&7);
;;;143        while (Data == 0) {
;;;144          if (BytesLeft ==0)
;;;145            return 0;
;;;146          Data = *pData++;
;;;147          BytesLeft--;
;;;148          x= (x+8) & ~7;
;;;149        }
;;;150        while ((Data&0x80) ==0) {
;;;151          Data<<=1;
;;;152          x++;
;;;153        }
;;;154    /* Find last cleared byte */
;;;155        if (Data != 0xff) {   /* This line is simply a speed-opt and may be eliminated */
;;;156          xEnd =x;
;;;157          while (Data&0x40) {
;;;158            Data<<=1;
;;;159            xEnd++;
;;;160          }
;;;161        } else {
;;;162          xEnd =x+7;
;;;163        }
;;;164        if ((xEnd&7) ==7) {
;;;165          while (--BytesLeft >= 0) {
;;;166            if ((Data = *pData++) == 0xff) {
;;;167              xEnd+=8;
;;;168            } else {
;;;169              while (Data&0x80) {
;;;170                Data<<=1;
;;;171                xEnd++;
;;;172              }
;;;173              break;
;;;174            }
;;;175          }
;;;176        }
;;;177    
;;;178      }
;;;179      *pxOff =x;
;;;180      return xEnd-x+1;
;;;181    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L5.36|
000024  6930              LDR      r0,[r6,#0x10]         ;134
000026  fb0c2200          MLA      r2,r12,r0,r2          ;134
00002a  eb0202e1          ADD      r2,r2,r1,ASR #3       ;135
00002e  4549              CMP      r1,r9                 ;136
000030  db01              BLT      |L5.54|
000032  2000              MOVS     r0,#0                 ;137
000034  e7f4              B        |L5.32|
                  |L5.54|
000036  f1a90001          SUB      r0,r9,#1              ;140
00003a  10c0              ASRS     r0,r0,#3              ;140
00003c  eba008e1          SUB      r8,r0,r1,ASR #3       ;140
000040  f8120b01          LDRB     r0,[r2],#1            ;142
000044  f0010a07          AND      r10,r1,#7             ;142
000048  fa00f00a          LSL      r0,r0,r10             ;142
00004c  b2c3              UXTB     r3,r0                 ;142
00004e  e00c              B        |L5.106|
                  |L5.80|
000050  f1b80f00          CMP      r8,#0                 ;144
000054  d101              BNE      |L5.90|
000056  2000              MOVS     r0,#0                 ;145
000058  e7e2              B        |L5.32|
                  |L5.90|
00005a  f8123b01          LDRB     r3,[r2],#1            ;146
00005e  f1a80801          SUB      r8,r8,#1              ;147
000062  f1010008          ADD      r0,r1,#8              ;148
000066  f0200107          BIC      r1,r0,#7              ;148
                  |L5.106|
00006a  2b00              CMP      r3,#0                 ;143
00006c  d0f0              BEQ      |L5.80|
00006e  e002              B        |L5.118|
                  |L5.112|
000070  0658              LSLS     r0,r3,#25             ;151
000072  0e03              LSRS     r3,r0,#24             ;151
000074  1c49              ADDS     r1,r1,#1              ;152
                  |L5.118|
000076  f0130f80          TST      r3,#0x80              ;150
00007a  d0f9              BEQ      |L5.112|
00007c  2bff              CMP      r3,#0xff              ;155
00007e  d008              BEQ      |L5.146|
000080  460c              MOV      r4,r1                 ;156
000082  e002              B        |L5.138|
                  |L5.132|
000084  0658              LSLS     r0,r3,#25             ;158
000086  0e03              LSRS     r3,r0,#24             ;158
000088  1c64              ADDS     r4,r4,#1              ;159
                  |L5.138|
00008a  f0130f40          TST      r3,#0x40              ;157
00008e  d1f9              BNE      |L5.132|
000090  e000              B        |L5.148|
                  |L5.146|
000092  1dcc              ADDS     r4,r1,#7              ;162
                  |L5.148|
000094  f0040007          AND      r0,r4,#7              ;164
000098  2807              CMP      r0,#7                 ;164
00009a  d116              BNE      |L5.202|
00009c  e00f              B        |L5.190|
                  |L5.158|
00009e  f812ab01          LDRB     r10,[r2],#1           ;166
0000a2  4653              MOV      r3,r10                ;166
0000a4  f1ba0fff          CMP      r10,#0xff             ;166
0000a8  d101              BNE      |L5.174|
0000aa  3408              ADDS     r4,r4,#8              ;167
0000ac  e007              B        |L5.190|
                  |L5.174|
0000ae  e002              B        |L5.182|
                  |L5.176|
0000b0  0658              LSLS     r0,r3,#25             ;170
0000b2  0e03              LSRS     r3,r0,#24             ;170
0000b4  1c64              ADDS     r4,r4,#1              ;171
                  |L5.182|
0000b6  f0130f80          TST      r3,#0x80              ;169
0000ba  d1f9              BNE      |L5.176|
0000bc  e004              B        |L5.200|
                  |L5.190|
0000be  f1a80001          SUB      r0,r8,#1              ;165
0000c2  f1b00800          SUBS     r8,r0,#0              ;165
0000c6  daea              BGE      |L5.158|
                  |L5.200|
0000c8  bf00              NOP                            ;173
                  |L5.202|
0000ca  6039              STR      r1,[r7,#0]            ;179
0000cc  1a60              SUBS     r0,r4,r1              ;180
0000ce  1c40              ADDS     r0,r0,#1              ;180
0000d0  e7a6              B        |L5.32|
;;;182    
                          ENDP


                          AREA ||i._GUI_USAGE_BM_Delete||, CODE, READONLY, ALIGN=1

                  _GUI_USAGE_BM_Delete PROC
;;;186    */
;;;187    static void _GUI_USAGE_BM_Delete(GUI_MEMDEV_Handle hDevUsage) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;188      GUI_ALLOC_Free(hDevUsage);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       GUI_ALLOC_Free
;;;189    }
00000a  bd10              POP      {r4,pc}
;;;190    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  API
                          DCD      GUI_USAGE_BM_AddPixel
                          DCD      GUI_USAGE_BM_AddHLine
                          DCD      GUI_USAGE_BM_Clear
                          DCD      0x00000000
                          DCD      _GUI_USAGE_BM_Delete
                          DCD      GUI_USAGE_BM_GetNextDirty
