; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\gui_uc_encodeutf8.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\gui_uc_encodeutf8.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\Core\GUI_UC_EncodeUTF8.c]
                          THUMB

                          AREA ||i.GUI_UC_SetEncodeUTF8||, CODE, READONLY, ALIGN=2

                  GUI_UC_SetEncodeUTF8 PROC
;;;146    */
;;;147    void GUI_UC_SetEncodeUTF8(void) {
000000  b510              PUSH     {r4,lr}
;;;148      #if GUI_SUPPORT_UNICODE
;;;149        GUI_LOCK();
000002  f7fffffe          BL       GUI_Lock
;;;150        GUI_Context.pUC_API = &_API_Table;
000006  4803              LDR      r0,|L1.20|
000008  4903              LDR      r1,|L1.24|
00000a  6208              STR      r0,[r1,#0x20]  ; GUI_Context
;;;151        GUI_UNLOCK();
00000c  f7fffffe          BL       GUI_Unlock
;;;152      #endif
;;;153    }
000010  bd10              POP      {r4,pc}
;;;154    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      _API_Table
                  |L1.24|
                          DCD      GUI_Context

                          AREA ||i._CalcSizeOfChar||, CODE, READONLY, ALIGN=1

                  _CalcSizeOfChar PROC
;;;86     */
;;;87     static int _CalcSizeOfChar(U16 Char) {
000000  4601              MOV      r1,r0
;;;88       int r;
;;;89       if (Char & 0xF800) {                /* Single byte (ASCII)  */
000002  f4114f78          TST      r1,#0xf800
000006  d001              BEQ      |L2.12|
;;;90         r = 3;
000008  2003              MOVS     r0,#3
00000a  e006              B        |L2.26|
                  |L2.12|
;;;91       } else if (Char & 0xFF80) {         /* Double byte sequence */
00000c  f64f7280          MOV      r2,#0xff80
000010  4211              TST      r1,r2
000012  d001              BEQ      |L2.24|
;;;92         r = 2;
000014  2002              MOVS     r0,#2
000016  e000              B        |L2.26|
                  |L2.24|
;;;93       } else {                            /* 3 byte sequence      */
;;;94         r = 1;
000018  2001              MOVS     r0,#1
                  |L2.26|
;;;95       }
;;;96       return r;
;;;97     }
00001a  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i._Encode||, CODE, READONLY, ALIGN=1

                  _Encode PROC
;;;105    */
;;;106    static int _Encode(char *s, U16 Char) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;107      int r;
;;;108      r = _CalcSizeOfChar(Char);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       _CalcSizeOfChar
00000c  4606              MOV      r6,r0
;;;109      switch (r) {
00000e  2e01              CMP      r6,#1
000010  d004              BEQ      |L3.28|
000012  2e02              CMP      r6,#2
000014  d004              BEQ      |L3.32|
000016  2e03              CMP      r6,#3
000018  d11e              BNE      |L3.88|
00001a  e00c              B        |L3.54|
                  |L3.28|
;;;110      case 1:
;;;111        *s = (char)Char;
00001c  7025              STRB     r5,[r4,#0]
;;;112        break;
00001e  e01b              B        |L3.88|
                  |L3.32|
;;;113      case 2:
;;;114        *s++ = 0xC0 | (Char >> 6);
000020  20c0              MOVS     r0,#0xc0
000022  ea4010a5          ORR      r0,r0,r5,ASR #6
000026  f8040b01          STRB     r0,[r4],#1
;;;115        *s   = 0x80 | (Char & 0x3F);
00002a  f005003f          AND      r0,r5,#0x3f
00002e  f0400080          ORR      r0,r0,#0x80
000032  7020              STRB     r0,[r4,#0]
;;;116        break;
000034  e010              B        |L3.88|
                  |L3.54|
;;;117      case 3:
;;;118        *s++ = 0xE0 | (Char >> 12);
000036  20e0              MOVS     r0,#0xe0
000038  ea403025          ORR      r0,r0,r5,ASR #12
00003c  f8040b01          STRB     r0,[r4],#1
;;;119        *s++ = 0x80 | ((Char >> 6) & 0x3F);
000040  f3c51085          UBFX     r0,r5,#6,#6
000044  f0400080          ORR      r0,r0,#0x80
000048  f8040b01          STRB     r0,[r4],#1
;;;120        *s   = 0x80 | (Char & 0x3F);
00004c  f005003f          AND      r0,r5,#0x3f
000050  f0400080          ORR      r0,r0,#0x80
000054  7020              STRB     r0,[r4,#0]
;;;121        break;
000056  bf00              NOP      
                  |L3.88|
000058  bf00              NOP                            ;112
;;;122      }
;;;123      return r;
00005a  4630              MOV      r0,r6
;;;124    }
00005c  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP


                          AREA ||i._GetCharCode||, CODE, READONLY, ALIGN=1

                  _GetCharCode PROC
;;;34     */
;;;35     static U16 _GetCharCode(const char GUI_UNI_PTR * s) {
000000  4602              MOV      r2,r0
;;;36       U16 r;
;;;37       U8 Char = *(const U8*)s;
000002  7811              LDRB     r1,[r2,#0]
;;;38       if ((Char & 0x80) == 0) {                /* Single byte (ASCII)  */
000004  f0110f80          TST      r1,#0x80
000008  d101              BNE      |L4.14|
;;;39         r = Char;
00000a  4608              MOV      r0,r1
00000c  e021              B        |L4.82|
                  |L4.14|
;;;40       } else if ((Char & 0xe0) == 0xc0) {      /* Double byte sequence */
00000e  f00103e0          AND      r3,r1,#0xe0
000012  2bc0              CMP      r3,#0xc0
000014  d108              BNE      |L4.40|
;;;41         r = (Char & 0x1f) << 6;
000016  06cb              LSLS     r3,r1,#27
000018  0d58              LSRS     r0,r3,#21
;;;42         Char = *(++s);
00001a  1c53              ADDS     r3,r2,#1
00001c  461a              MOV      r2,r3
00001e  7819              LDRB     r1,[r3,#0]
;;;43         Char &= 0x3f;
000020  f001013f          AND      r1,r1,#0x3f
;;;44         r |= Char;
000024  4308              ORRS     r0,r0,r1
000026  e014              B        |L4.82|
                  |L4.40|
;;;45       } else if ((Char & 0xf0) == 0xe0) {      /* 3 byte sequence      */
000028  f00103f0          AND      r3,r1,#0xf0
00002c  2be0              CMP      r3,#0xe0
00002e  d10f              BNE      |L4.80|
;;;46         r = (Char & 0x0f) << 12;
000030  070b              LSLS     r3,r1,#28
000032  0c18              LSRS     r0,r3,#16
;;;47         Char = *(++s);
000034  1c53              ADDS     r3,r2,#1
000036  461a              MOV      r2,r3
000038  7819              LDRB     r1,[r3,#0]
;;;48         Char &= 0x3f;
00003a  f001013f          AND      r1,r1,#0x3f
;;;49         r |= (Char << 6);
00003e  ea401081          ORR      r0,r0,r1,LSL #6
;;;50         Char = *(++s);
000042  1c53              ADDS     r3,r2,#1
000044  461a              MOV      r2,r3
000046  7819              LDRB     r1,[r3,#0]
;;;51         Char &= 0x3f;
000048  f001013f          AND      r1,r1,#0x3f
;;;52         r |= Char;
00004c  4308              ORRS     r0,r0,r1
00004e  e000              B        |L4.82|
                  |L4.80|
;;;53       } else {
;;;54         GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;55         r = 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
000050  2001              MOVS     r0,#1
                  |L4.82|
;;;56       }
;;;57       return r;
;;;58     }
000052  4770              BX       lr
;;;59     
                          ENDP


                          AREA ||i._GetCharSize||, CODE, READONLY, ALIGN=1

                  _GetCharSize PROC
;;;66     */
;;;67     static int _GetCharSize(const char GUI_UNI_PTR * s) {
000000  4602              MOV      r2,r0
;;;68       U8 Char = *s;
000002  7811              LDRB     r1,[r2,#0]
;;;69       if ((Char & 0x80) == 0) {
000004  f0110f80          TST      r1,#0x80
000008  d101              BNE      |L5.14|
;;;70         return 1;
00000a  2001              MOVS     r0,#1
                  |L5.12|
;;;71       } else if ((Char & 0xe0) == 0xc0) {
;;;72         return 2;
;;;73       } else if ((Char & 0xf0) == 0xe0) {
;;;74         return 3;
;;;75       }
;;;76       GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;77       return 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
;;;78     }
00000c  4770              BX       lr
                  |L5.14|
00000e  f00100e0          AND      r0,r1,#0xe0           ;71
000012  28c0              CMP      r0,#0xc0              ;71
000014  d101              BNE      |L5.26|
000016  2002              MOVS     r0,#2                 ;72
000018  e7f8              B        |L5.12|
                  |L5.26|
00001a  f00100f0          AND      r0,r1,#0xf0           ;73
00001e  28e0              CMP      r0,#0xe0              ;73
000020  d101              BNE      |L5.38|
000022  2003              MOVS     r0,#3                 ;74
000024  e7f2              B        |L5.12|
                  |L5.38|
000026  2001              MOVS     r0,#1                 ;77
000028  e7f0              B        |L5.12|
;;;79     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _API_Table
                          DCD      _GetCharCode
                          DCD      _GetCharSize
                          DCD      _CalcSizeOfChar
                          DCD      _Encode
