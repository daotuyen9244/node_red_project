; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_sem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCOS-II\Source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemAccept||, CODE, READONLY, ALIGN=1

                  OSSemAccept PROC
;;;48     #if OS_SEM_ACCEPT_EN > 0u
;;;49     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         INT16U     cnt;
;;;52     #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;53         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0u
;;;59         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;60             return (0u);
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L1.16|
;;;64             return (0u);
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         cnt = pevent->OSEventCnt;
;;;68         if (cnt > 0u) {                                   /* See if resource is available                  */
;;;69             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;70         }
;;;71         OS_EXIT_CRITICAL();
;;;72         return (cnt);                                     /* Return semaphore count                        */
;;;73     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;66
000016  8925              LDRH     r5,[r4,#8]            ;67
000018  b115              CBZ      r5,|L1.32|
00001a  8920              LDRH     r0,[r4,#8]            ;69
00001c  1e40              SUBS     r0,r0,#1              ;69
00001e  8120              STRH     r0,[r4,#8]            ;69
                  |L1.32|
000020  4630              MOV      r0,r6                 ;71
000022  f7fffffe          BL       OS_CPU_SR_Restore
000026  4628              MOV      r0,r5                 ;72
000028  e7f1              B        |L1.14|
;;;74     #endif
                          ENDP


                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;93     
;;;94     OS_EVENT  *OSSemCreate (INT16U cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4605              MOV      r5,r0
;;;96         OS_EVENT  *pevent;
;;;97     #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;104        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;105            OS_SAFETY_CRITICAL_EXCEPTION();
;;;106            return ((OS_EVENT *)0);
;;;107        }
;;;108    #endif
;;;109    
;;;110        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000006  4810              LDR      r0,|L2.72|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b108              CBZ      r0,|L2.16|
;;;111            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;112        }
;;;113        OS_ENTER_CRITICAL();
;;;114        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;115        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;116            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;117        }
;;;118        OS_EXIT_CRITICAL();
;;;119        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;120            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;121            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;122            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;123    #if OS_EVENT_NAME_EN > 0u
;;;124            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;125    #endif
;;;126            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;127        }
;;;128        return (pevent);
;;;129    }
00000e  bd70              POP      {r4-r6,pc}
                  |L2.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;113
000016  480d              LDR      r0,|L2.76|
000018  6804              LDR      r4,[r0,#0]            ;114  ; OSEventFreeList
00001a  6800              LDR      r0,[r0,#0]            ;115  ; OSEventFreeList
00001c  b120              CBZ      r0,|L2.40|
00001e  480b              LDR      r0,|L2.76|
000020  6800              LDR      r0,[r0,#0]            ;116  ; OSEventFreeList
000022  6840              LDR      r0,[r0,#4]            ;116
000024  4909              LDR      r1,|L2.76|
000026  6008              STR      r0,[r1,#0]            ;116  ; OSEventFreeList
                  |L2.40|
000028  4630              MOV      r0,r6                 ;118
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  b14c              CBZ      r4,|L2.68|
000030  2003              MOVS     r0,#3                 ;120
000032  7020              STRB     r0,[r4,#0]            ;120
000034  8125              STRH     r5,[r4,#8]            ;121
000036  2000              MOVS     r0,#0                 ;122
000038  6060              STR      r0,[r4,#4]            ;122
00003a  a005              ADR      r0,|L2.80|
00003c  6120              STR      r0,[r4,#0x10]         ;124
00003e  4620              MOV      r0,r4                 ;126
000040  f7fffffe          BL       OS_EventWaitListInit
                  |L2.68|
000044  4620              MOV      r0,r4                 ;128
000046  e7e2              B        |L2.14|
;;;130    
                          ENDP

                  |L2.72|
                          DCD      OSIntNesting
                  |L2.76|
                          DCD      OSEventFreeList
                  |L2.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;169    #if OS_SEM_DEL_EN > 0u
;;;170    OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;171                         INT8U      opt,
;;;172                         INT8U     *perr)
;;;173    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;174        BOOLEAN    tasks_waiting;
;;;175        OS_EVENT  *pevent_return;
;;;176    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;177        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;178    #endif
;;;179    
;;;180    
;;;181    
;;;182    #ifdef OS_SAFETY_CRITICAL
;;;183        if (perr == (INT8U *)0) {
;;;184            OS_SAFETY_CRITICAL_EXCEPTION();
;;;185            return ((OS_EVENT *)0);
;;;186        }
;;;187    #endif
;;;188    
;;;189    #if OS_ARG_CHK_EN > 0u
;;;190        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;191            *perr = OS_ERR_PEVENT_NULL;
;;;192            return (pevent);
;;;193        }
;;;194    #endif
;;;195        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L3.30|
;;;196            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;197            return (pevent);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;198        }
;;;199        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;200            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;201            return (pevent);
;;;202        }
;;;203        OS_ENTER_CRITICAL();
;;;204        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
;;;205            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;206        } else {
;;;207            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;208        }
;;;209        switch (opt) {
;;;210            case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
;;;211                 if (tasks_waiting == OS_FALSE) {
;;;212    #if OS_EVENT_NAME_EN > 0u
;;;213                     pevent->OSEventName    = (INT8U *)(void *)"?";
;;;214    #endif
;;;215                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;216                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;217                     pevent->OSEventCnt     = 0u;
;;;218                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;219                     OS_EXIT_CRITICAL();
;;;220                     *perr                  = OS_ERR_NONE;
;;;221                     pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
;;;222                 } else {
;;;223                     OS_EXIT_CRITICAL();
;;;224                     *perr                  = OS_ERR_TASK_WAITING;
;;;225                     pevent_return          = pevent;
;;;226                 }
;;;227                 break;
;;;228    
;;;229            case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
;;;230                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
;;;231                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;232                 }
;;;233    #if OS_EVENT_NAME_EN > 0u
;;;234                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;235    #endif
;;;236                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;237                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;238                 pevent->OSEventCnt     = 0u;
;;;239                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;240                 OS_EXIT_CRITICAL();
;;;241                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;242                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;243                 }
;;;244                 *perr                  = OS_ERR_NONE;
;;;245                 pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
;;;246                 break;
;;;247    
;;;248            default:
;;;249                 OS_EXIT_CRITICAL();
;;;250                 *perr                  = OS_ERR_INVALID_OPT;
;;;251                 pevent_return          = pevent;
;;;252                 break;
;;;253        }
;;;254        return (pevent_return);
;;;255    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  482d              LDR      r0,|L3.212|
000020  7800              LDRB     r0,[r0,#0]            ;199  ; OSIntNesting
000022  b118              CBZ      r0,|L3.44|
000024  200f              MOVS     r0,#0xf               ;200
000026  7028              STRB     r0,[r5,#0]            ;200
000028  4620              MOV      r0,r4                 ;201
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4681              MOV      r9,r0                 ;203
000032  7aa0              LDRB     r0,[r4,#0xa]          ;204
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;205
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;207
                  |L3.60|
00003c  f1b80f00          CMP      r8,#0                 ;209
000040  d003              BEQ      |L3.74|
000042  f1b80f01          CMP      r8,#1                 ;209
000046  d13a              BNE      |L3.190|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a022              ADR      r0,|L3.216|
00004e  6120              STR      r0,[r4,#0x10]         ;213
000050  2000              MOVS     r0,#0                 ;215
000052  7020              STRB     r0,[r4,#0]            ;215
000054  4821              LDR      r0,|L3.220|
000056  6800              LDR      r0,[r0,#0]            ;216  ; OSEventFreeList
000058  6060              STR      r0,[r4,#4]            ;216
00005a  2000              MOVS     r0,#0                 ;217
00005c  8120              STRH     r0,[r4,#8]            ;217
00005e  481f              LDR      r0,|L3.220|
000060  6004              STR      r4,[r0,#0]            ;218  ; OSEventFreeList
000062  4648              MOV      r0,r9                 ;219
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;220
00006a  7028              STRB     r0,[r5,#0]            ;220
00006c  2600              MOVS     r6,#0                 ;221
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4648              MOV      r0,r9                 ;223
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;224
000078  7028              STRB     r0,[r5,#0]            ;224
00007a  4626              MOV      r6,r4                 ;225
                  |L3.124|
00007c  e026              B        |L3.204|
                  |L3.126|
00007e  e005              B        |L3.140|
                  |L3.128|
000080  2300              MOVS     r3,#0                 ;231
000082  2201              MOVS     r2,#1                 ;231
000084  4619              MOV      r1,r3                 ;231
000086  4620              MOV      r0,r4                 ;231
000088  f7fffffe          BL       OS_EventTaskRdy
                  |L3.140|
00008c  7aa0              LDRB     r0,[r4,#0xa]          ;230
00008e  2800              CMP      r0,#0                 ;230
000090  d1f6              BNE      |L3.128|
000092  a011              ADR      r0,|L3.216|
000094  6120              STR      r0,[r4,#0x10]         ;234
000096  2000              MOVS     r0,#0                 ;236
000098  7020              STRB     r0,[r4,#0]            ;236
00009a  4810              LDR      r0,|L3.220|
00009c  6800              LDR      r0,[r0,#0]            ;237  ; OSEventFreeList
00009e  6060              STR      r0,[r4,#4]            ;237
0000a0  2000              MOVS     r0,#0                 ;238
0000a2  8120              STRH     r0,[r4,#8]            ;238
0000a4  480d              LDR      r0,|L3.220|
0000a6  6004              STR      r4,[r0,#0]            ;239  ; OSEventFreeList
0000a8  4648              MOV      r0,r9                 ;240
0000aa  f7fffffe          BL       OS_CPU_SR_Restore
0000ae  2f01              CMP      r7,#1                 ;241
0000b0  d101              BNE      |L3.182|
0000b2  f7fffffe          BL       OS_Sched
                  |L3.182|
0000b6  2000              MOVS     r0,#0                 ;244
0000b8  7028              STRB     r0,[r5,#0]            ;244
0000ba  2600              MOVS     r6,#0                 ;245
0000bc  e006              B        |L3.204|
                  |L3.190|
0000be  4648              MOV      r0,r9                 ;249
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  2007              MOVS     r0,#7                 ;250
0000c6  7028              STRB     r0,[r5,#0]            ;250
0000c8  4626              MOV      r6,r4                 ;251
0000ca  bf00              NOP                            ;252
                  |L3.204|
0000cc  bf00              NOP                            ;227
0000ce  4630              MOV      r0,r6                 ;254
0000d0  e7a3              B        |L3.26|
;;;256    #endif
                          ENDP

0000d2  0000              DCW      0x0000
                  |L3.212|
                          DCD      OSIntNesting
                  |L3.216|
0000d8  3f00              DCB      "?",0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L3.220|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;290    /*$PAGE*/
;;;291    void  OSSemPend (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;292                     INT32U     timeout,
;;;293                     INT8U     *perr)
;;;294    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;295    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;296        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;297    #endif
;;;298    
;;;299    
;;;300    
;;;301    #ifdef OS_SAFETY_CRITICAL
;;;302        if (perr == (INT8U *)0) {
;;;303            OS_SAFETY_CRITICAL_EXCEPTION();
;;;304            return;
;;;305        }
;;;306    #endif
;;;307    
;;;308    #if OS_ARG_CHK_EN > 0u
;;;309        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;310            *perr = OS_ERR_PEVENT_NULL;
;;;311            return;
;;;312        }
;;;313    #endif
;;;314        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L4.26|
;;;315            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
                  |L4.22|
;;;316            return;
;;;317        }
;;;318        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;319            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;320            return;
;;;321        }
;;;322        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;323            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;324            return;
;;;325        }
;;;326        OS_ENTER_CRITICAL();
;;;327        if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
;;;328            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;329            OS_EXIT_CRITICAL();
;;;330            *perr = OS_ERR_NONE;
;;;331            return;
;;;332        }
;;;333                                                          /* Otherwise, must wait until event occurs       */
;;;334        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;335        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;336        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;337        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;338        OS_EXIT_CRITICAL();
;;;339        OS_Sched();                                       /* Find next highest priority task ready         */
;;;340        OS_ENTER_CRITICAL();
;;;341        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;342            case OS_STAT_PEND_OK:
;;;343                 *perr = OS_ERR_NONE;
;;;344                 break;
;;;345    
;;;346            case OS_STAT_PEND_ABORT:
;;;347                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;348                 break;
;;;349    
;;;350            case OS_STAT_PEND_TO:
;;;351            default:
;;;352                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;353                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;354                 break;
;;;355        }
;;;356        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;357        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;358        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;359    #if (OS_EVENT_MULTI_EN > 0u)
;;;360        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;361    #endif
;;;362        OS_EXIT_CRITICAL();
;;;363    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  4832              LDR      r0,|L4.228|
00001c  7800              LDRB     r0,[r0,#0]            ;318  ; OSIntNesting
00001e  b110              CBZ      r0,|L4.38|
000020  2002              MOVS     r0,#2                 ;319
000022  7020              STRB     r0,[r4,#0]            ;319
000024  e7f7              B        |L4.22|
                  |L4.38|
000026  4830              LDR      r0,|L4.232|
000028  7800              LDRB     r0,[r0,#0]            ;322  ; OSLockNesting
00002a  b110              CBZ      r0,|L4.50|
00002c  200d              MOVS     r0,#0xd               ;323
00002e  7020              STRB     r0,[r4,#0]            ;323
000030  e7f1              B        |L4.22|
                  |L4.50|
000032  f7fffffe          BL       OS_CPU_SR_Save
000036  4607              MOV      r7,r0                 ;326
000038  8928              LDRH     r0,[r5,#8]            ;327
00003a  b140              CBZ      r0,|L4.78|
00003c  8928              LDRH     r0,[r5,#8]            ;328
00003e  1e40              SUBS     r0,r0,#1              ;328
000040  8128              STRH     r0,[r5,#8]            ;328
000042  4638              MOV      r0,r7                 ;329
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;330
00004a  7020              STRB     r0,[r4,#0]            ;330
00004c  e7e3              B        |L4.22|
                  |L4.78|
00004e  4827              LDR      r0,|L4.236|
000050  6800              LDR      r0,[r0,#0]            ;334  ; OSTCBCur
000052  f8900034          LDRB     r0,[r0,#0x34]         ;334
000056  f0400001          ORR      r0,r0,#1              ;334
00005a  4924              LDR      r1,|L4.236|
00005c  6809              LDR      r1,[r1,#0]            ;334  ; OSTCBCur
00005e  f8810034          STRB     r0,[r1,#0x34]         ;334
000062  2000              MOVS     r0,#0                 ;335
000064  4921              LDR      r1,|L4.236|
000066  6809              LDR      r1,[r1,#0]            ;335  ; OSTCBCur
000068  f8810035          STRB     r0,[r1,#0x35]         ;335
00006c  481f              LDR      r0,|L4.236|
00006e  6800              LDR      r0,[r0,#0]            ;336  ; OSTCBCur
000070  6306              STR      r6,[r0,#0x30]         ;336
000072  4628              MOV      r0,r5                 ;337
000074  f7fffffe          BL       OS_EventTaskWait
000078  4638              MOV      r0,r7                 ;338
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  f7fffffe          BL       OS_Sched
000082  f7fffffe          BL       OS_CPU_SR_Save
000086  4607              MOV      r7,r0                 ;340
000088  4818              LDR      r0,|L4.236|
00008a  6800              LDR      r0,[r0,#0]            ;341  ; OSTCBCur
00008c  f8900035          LDRB     r0,[r0,#0x35]         ;341
000090  b120              CBZ      r0,|L4.156|
000092  2801              CMP      r0,#1                 ;341
000094  d009              BEQ      |L4.170|
000096  2802              CMP      r0,#2                 ;341
000098  d106              BNE      |L4.168|
00009a  e002              B        |L4.162|
                  |L4.156|
00009c  2000              MOVS     r0,#0                 ;343
00009e  7020              STRB     r0,[r4,#0]            ;343
0000a0  e00b              B        |L4.186|
                  |L4.162|
0000a2  200e              MOVS     r0,#0xe               ;347
0000a4  7020              STRB     r0,[r4,#0]            ;347
0000a6  e008              B        |L4.186|
                  |L4.168|
0000a8  bf00              NOP                            ;350
                  |L4.170|
0000aa  4629              MOV      r1,r5                 ;352
0000ac  480f              LDR      r0,|L4.236|
0000ae  6800              LDR      r0,[r0,#0]            ;352  ; OSTCBCur
0000b0  f7fffffe          BL       OS_EventTaskRemove
0000b4  200a              MOVS     r0,#0xa               ;353
0000b6  7020              STRB     r0,[r4,#0]            ;353
0000b8  bf00              NOP                            ;354
                  |L4.186|
0000ba  bf00              NOP                            ;344
0000bc  2000              MOVS     r0,#0                 ;356
0000be  490b              LDR      r1,|L4.236|
0000c0  6809              LDR      r1,[r1,#0]            ;356  ; OSTCBCur
0000c2  f8810034          STRB     r0,[r1,#0x34]         ;356
0000c6  4909              LDR      r1,|L4.236|
0000c8  6809              LDR      r1,[r1,#0]            ;357  ; OSTCBCur
0000ca  f8810035          STRB     r0,[r1,#0x35]         ;357
0000ce  4907              LDR      r1,|L4.236|
0000d0  6809              LDR      r1,[r1,#0]            ;358  ; OSTCBCur
0000d2  61c8              STR      r0,[r1,#0x1c]         ;358
0000d4  4905              LDR      r1,|L4.236|
0000d6  6809              LDR      r1,[r1,#0]            ;360  ; OSTCBCur
0000d8  6208              STR      r0,[r1,#0x20]         ;360
0000da  4638              MOV      r0,r7                 ;362
0000dc  f7fffffe          BL       OS_CPU_SR_Restore
0000e0  bf00              NOP      
0000e2  e798              B        |L4.22|
;;;364    
                          ENDP

                  |L4.228|
                          DCD      OSIntNesting
                  |L4.232|
                          DCD      OSLockNesting
                  |L4.236|
                          DCD      OSTCBCur

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=1

                  OSSemPendAbort PROC
;;;399    #if OS_SEM_PEND_ABORT_EN > 0u
;;;400    INT8U  OSSemPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;401                           INT8U      opt,
;;;402                           INT8U     *perr)
;;;403    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;404        INT8U      nbr_tasks;
;;;405    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;406        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;407    #endif
;;;408    
;;;409    
;;;410    
;;;411    #ifdef OS_SAFETY_CRITICAL
;;;412        if (perr == (INT8U *)0) {
;;;413            OS_SAFETY_CRITICAL_EXCEPTION();
;;;414            return (0u);
;;;415        }
;;;416    #endif
;;;417    
;;;418    #if OS_ARG_CHK_EN > 0u
;;;419        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;420            *perr = OS_ERR_PEVENT_NULL;
;;;421            return (0u);
;;;422        }
;;;423    #endif
;;;424        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L5.30|
;;;425            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;426            return (0u);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;427        }
;;;428        OS_ENTER_CRITICAL();
;;;429        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
;;;430            nbr_tasks = 0u;
;;;431            switch (opt) {
;;;432                case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;433                     while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
;;;434                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;435                         nbr_tasks++;
;;;436                     }
;;;437                     break;
;;;438    
;;;439                case OS_PEND_OPT_NONE:
;;;440                default:                                  /* No,  ready HPT       waiting on semaphore     */
;;;441                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;442                     nbr_tasks++;
;;;443                     break;
;;;444            }
;;;445            OS_EXIT_CRITICAL();
;;;446            OS_Sched();                                   /* Find HPT ready to run                         */
;;;447            *perr = OS_ERR_PEND_ABORT;
;;;448            return (nbr_tasks);
;;;449        }
;;;450        OS_EXIT_CRITICAL();
;;;451        *perr = OS_ERR_NONE;
;;;452        return (0u);                                      /* No tasks waiting on semaphore                 */
;;;453    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;428
000024  7aa0              LDRB     r0,[r4,#0xa]          ;429
000026  b320              CBZ      r0,|L5.114|
000028  2600              MOVS     r6,#0                 ;430
00002a  b17f              CBZ      r7,|L5.76|
00002c  2f01              CMP      r7,#1                 ;431
00002e  d10c              BNE      |L5.74|
000030  e007              B        |L5.66|
                  |L5.50|
000032  2302              MOVS     r3,#2                 ;434
000034  2201              MOVS     r2,#1                 ;434
000036  2100              MOVS     r1,#0                 ;434
000038  4620              MOV      r0,r4                 ;434
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;435
000040  b2c6              UXTB     r6,r0                 ;435
                  |L5.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;433
000044  2800              CMP      r0,#0                 ;433
000046  d1f4              BNE      |L5.50|
000048  e009              B        |L5.94|
                  |L5.74|
00004a  bf00              NOP                            ;439
                  |L5.76|
00004c  2302              MOVS     r3,#2                 ;441
00004e  2201              MOVS     r2,#1                 ;441
000050  2100              MOVS     r1,#0                 ;441
000052  4620              MOV      r0,r4                 ;441
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;442
00005a  b2c6              UXTB     r6,r0                 ;442
00005c  bf00              NOP                            ;443
                  |L5.94|
00005e  bf00              NOP                            ;437
000060  4640              MOV      r0,r8                 ;445
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;447
00006c  7028              STRB     r0,[r5,#0]            ;447
00006e  4630              MOV      r0,r6                 ;448
000070  e7d3              B        |L5.26|
                  |L5.114|
000072  4640              MOV      r0,r8                 ;450
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;451
00007a  7028              STRB     r0,[r5,#0]            ;451
00007c  bf00              NOP                            ;452
00007e  e7cc              B        |L5.26|
;;;454    #endif
                          ENDP


                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=1

                  OSSemPost PROC
;;;474    
;;;475    INT8U  OSSemPost (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
000002  4604              MOV      r4,r0
;;;477    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;478        OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;479    #endif
;;;480    
;;;481    
;;;482    
;;;483    #if OS_ARG_CHK_EN > 0u
;;;484        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;485            return (OS_ERR_PEVENT_NULL);
;;;486        }
;;;487    #endif
;;;488        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L6.16|
;;;489            return (OS_ERR_EVENT_TYPE);
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;490        }
;;;491        OS_ENTER_CRITICAL();
;;;492        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
;;;493                                                          /* Ready HPT waiting on event                    */
;;;494            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;495            OS_EXIT_CRITICAL();
;;;496            OS_Sched();                                   /* Find HPT ready to run                         */
;;;497            return (OS_ERR_NONE);
;;;498        }
;;;499        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;500            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;501            OS_EXIT_CRITICAL();
;;;502            return (OS_ERR_NONE);
;;;503        }
;;;504        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;505        return (OS_ERR_SEM_OVF);
;;;506    }
00000e  bd70              POP      {r4-r6,pc}
                  |L6.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4605              MOV      r5,r0                 ;491
000016  7aa0              LDRB     r0,[r4,#0xa]          ;492
000018  b160              CBZ      r0,|L6.52|
00001a  2300              MOVS     r3,#0                 ;494
00001c  2201              MOVS     r2,#1                 ;494
00001e  4619              MOV      r1,r3                 ;494
000020  4620              MOV      r0,r4                 ;494
000022  f7fffffe          BL       OS_EventTaskRdy
000026  4628              MOV      r0,r5                 ;495
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  f7fffffe          BL       OS_Sched
000030  2000              MOVS     r0,#0                 ;497
000032  e7ec              B        |L6.14|
                  |L6.52|
000034  8920              LDRH     r0,[r4,#8]            ;499
000036  f64f71ff          MOV      r1,#0xffff            ;499
00003a  4288              CMP      r0,r1                 ;499
00003c  d207              BCS      |L6.78|
00003e  8920              LDRH     r0,[r4,#8]            ;500
000040  1c40              ADDS     r0,r0,#1              ;500
000042  8120              STRH     r0,[r4,#8]            ;500
000044  4628              MOV      r0,r5                 ;501
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  2000              MOVS     r0,#0                 ;502
00004c  e7df              B        |L6.14|
                  |L6.78|
00004e  4628              MOV      r0,r5                 ;504
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2033              MOVS     r0,#0x33              ;505
000056  e7da              B        |L6.14|
;;;507    
                          ENDP


                          AREA ||i.OSSemQuery||, CODE, READONLY, ALIGN=1

                  OSSemQuery PROC
;;;528    #if OS_SEM_QUERY_EN > 0u
;;;529    INT8U  OSSemQuery (OS_EVENT     *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;530                       OS_SEM_DATA  *p_sem_data)
;;;531    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;532        INT8U       i;
;;;533        OS_PRIO    *psrc;
;;;534        OS_PRIO    *pdest;
;;;535    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;536        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;537    #endif
;;;538    
;;;539    
;;;540    
;;;541    #if OS_ARG_CHK_EN > 0u
;;;542        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;543            return (OS_ERR_PEVENT_NULL);
;;;544        }
;;;545        if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
;;;546            return (OS_ERR_PDATA_NULL);
;;;547        }
;;;548    #endif
;;;549        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d002              BEQ      |L7.24|
;;;550            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L7.20|
;;;551        }
;;;552        OS_ENTER_CRITICAL();
;;;553        p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
;;;554        psrc                   = &pevent->OSEventTbl[0];
;;;555        pdest                  = &p_sem_data->OSEventTbl[0];
;;;556        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;557            *pdest++ = *psrc++;
;;;558        }
;;;559        p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
;;;560        OS_EXIT_CRITICAL();
;;;561        return (OS_ERR_NONE);
;;;562    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L7.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;552
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;553
000020  71a8              STRB     r0,[r5,#6]            ;553
000022  f104070b          ADD      r7,r4,#0xb            ;554
000026  f1050802          ADD      r8,r5,#2              ;555
00002a  2600              MOVS     r6,#0                 ;556
00002c  e005              B        |L7.58|
                  |L7.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;557
000032  f8080b01          STRB     r0,[r8],#1            ;557
000036  1c70              ADDS     r0,r6,#1              ;556
000038  b2c6              UXTB     r6,r0                 ;556
                  |L7.58|
00003a  2e04              CMP      r6,#4                 ;556
00003c  d3f7              BCC      |L7.46|
00003e  8920              LDRH     r0,[r4,#8]            ;559
000040  8028              STRH     r0,[r5,#0]            ;559
000042  4648              MOV      r0,r9                 ;560
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;561
00004a  e7e3              B        |L7.20|
;;;563    #endif                                                     /* OS_SEM_QUERY_EN                          */
                          ENDP


                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=1

                  OSSemSet PROC
;;;590    #if OS_SEM_SET_EN > 0u
;;;591    void  OSSemSet (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;592                    INT16U     cnt,
;;;593                    INT8U     *perr)
;;;594    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;595    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;596        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;597    #endif
;;;598    
;;;599    
;;;600    
;;;601    #ifdef OS_SAFETY_CRITICAL
;;;602        if (perr == (INT8U *)0) {
;;;603            OS_SAFETY_CRITICAL_EXCEPTION();
;;;604            return;
;;;605        }
;;;606    #endif
;;;607    
;;;608    #if OS_ARG_CHK_EN > 0u
;;;609        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;610            *perr = OS_ERR_PEVENT_NULL;
;;;611            return;
;;;612        }
;;;613    #endif
;;;614        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L8.26|
;;;615            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7028              STRB     r0,[r5,#0]
                  |L8.22|
;;;616            return;
;;;617        }
;;;618        OS_ENTER_CRITICAL();
;;;619        *perr = OS_ERR_NONE;
;;;620        if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
;;;621            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;622        } else {                                          /* No                                            */
;;;623            if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
;;;624                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;625            } else {
;;;626                *perr              = OS_ERR_TASK_WAITING;
;;;627            }
;;;628        }
;;;629        OS_EXIT_CRITICAL();
;;;630    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L8.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;618
000020  2000              MOVS     r0,#0                 ;619
000022  7028              STRB     r0,[r5,#0]            ;619
000024  8920              LDRH     r0,[r4,#8]            ;620
000026  b108              CBZ      r0,|L8.44|
000028  8126              STRH     r6,[r4,#8]            ;621
00002a  e005              B        |L8.56|
                  |L8.44|
00002c  7aa0              LDRB     r0,[r4,#0xa]          ;623
00002e  b908              CBNZ     r0,|L8.52|
000030  8126              STRH     r6,[r4,#8]            ;624
000032  e001              B        |L8.56|
                  |L8.52|
000034  2049              MOVS     r0,#0x49              ;626
000036  7028              STRB     r0,[r5,#0]            ;626
                  |L8.56|
000038  4638              MOV      r0,r7                 ;629
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  bf00              NOP      
000040  e7e9              B        |L8.22|
;;;631    #endif
                          ENDP

