; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_core.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||i.OSEventNameGet||, CODE, READONLY, ALIGN=2

                  OSEventNameGet PROC
;;;107    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;108    INT8U  OSEventNameGet (OS_EVENT   *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;109                           INT8U     **pname,
;;;110                           INT8U      *perr)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112        INT8U      len;
;;;113    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;114        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;115    #endif
;;;116    
;;;117    
;;;118    
;;;119    #ifdef OS_SAFETY_CRITICAL
;;;120        if (perr == (INT8U *)0) {
;;;121            OS_SAFETY_CRITICAL_EXCEPTION();
;;;122            return (0u);
;;;123        }
;;;124    #endif
;;;125    
;;;126    #if OS_ARG_CHK_EN > 0u
;;;127        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;128            *perr = OS_ERR_PEVENT_NULL;
;;;129            return (0u);
;;;130        }
;;;131        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;132            *perr = OS_ERR_PNAME_NULL;
;;;133            return (0u);
;;;134        }
;;;135    #endif
;;;136        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4815              LDR      r0,|L1.100|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L1.28|
;;;137            *perr  = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7020              STRB     r0,[r4,#0]
;;;138            return (0u);
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;139        }
;;;140        switch (pevent->OSEventType) {
;;;141            case OS_EVENT_TYPE_SEM:
;;;142            case OS_EVENT_TYPE_MUTEX:
;;;143            case OS_EVENT_TYPE_MBOX:
;;;144            case OS_EVENT_TYPE_Q:
;;;145                 break;
;;;146    
;;;147            default:
;;;148                 *perr = OS_ERR_EVENT_TYPE;
;;;149                 return (0u);
;;;150        }
;;;151        OS_ENTER_CRITICAL();
;;;152        *pname = pevent->OSEventName;
;;;153        len    = OS_StrLen(*pname);
;;;154        OS_EXIT_CRITICAL();
;;;155        *perr  = OS_ERR_NONE;
;;;156        return (len);
;;;157    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  7828              LDRB     r0,[r5,#0]            ;140
00001e  2801              CMP      r0,#1                 ;140
000020  d008              BEQ      |L1.52|
000022  2802              CMP      r0,#2                 ;140
000024  d007              BEQ      |L1.54|
000026  2803              CMP      r0,#3                 ;140
000028  d002              BEQ      |L1.48|
00002a  2804              CMP      r0,#4                 ;140
00002c  d104              BNE      |L1.56|
00002e  e000              B        |L1.50|
                  |L1.48|
000030  bf00              NOP                            ;142
                  |L1.50|
000032  bf00              NOP                            ;143
                  |L1.52|
000034  bf00              NOP                            ;144
                  |L1.54|
000036  e003              B        |L1.64|
                  |L1.56|
000038  2001              MOVS     r0,#1                 ;148
00003a  7020              STRB     r0,[r4,#0]            ;148
00003c  2000              MOVS     r0,#0                 ;149
00003e  e7eb              B        |L1.24|
                  |L1.64|
000040  bf00              NOP                            ;145
000042  f7fffffe          BL       OS_CPU_SR_Save
000046  4607              MOV      r7,r0                 ;151
000048  6928              LDR      r0,[r5,#0x10]         ;152
00004a  6030              STR      r0,[r6,#0]            ;152
00004c  6830              LDR      r0,[r6,#0]            ;153
00004e  f7fffffe          BL       OS_StrLen
000052  4680              MOV      r8,r0                 ;153
000054  4638              MOV      r0,r7                 ;154
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2000              MOVS     r0,#0                 ;155
00005c  7020              STRB     r0,[r4,#0]            ;155
00005e  4640              MOV      r0,r8                 ;156
000060  e7da              B        |L1.24|
;;;158    #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      OSIntNesting

                          AREA ||i.OSEventNameSet||, CODE, READONLY, ALIGN=2

                  OSEventNameSet PROC
;;;187    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;188    void  OSEventNameSet (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;189                          INT8U     *pname,
;;;190                          INT8U     *perr)
;;;191    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;192    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;193        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;194    #endif
;;;195    
;;;196    
;;;197    
;;;198    #ifdef OS_SAFETY_CRITICAL
;;;199        if (perr == (INT8U *)0) {
;;;200            OS_SAFETY_CRITICAL_EXCEPTION();
;;;201            return;
;;;202        }
;;;203    #endif
;;;204    
;;;205    #if OS_ARG_CHK_EN > 0u
;;;206        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;207            *perr = OS_ERR_PEVENT_NULL;
;;;208            return;
;;;209        }
;;;210        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;211            *perr = OS_ERR_PNAME_NULL;
;;;212            return;
;;;213        }
;;;214    #endif
;;;215        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4811              LDR      r0,|L2.84|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L2.26|
;;;216            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L2.22|
;;;217            return;
;;;218        }
;;;219        switch (pevent->OSEventType) {
;;;220            case OS_EVENT_TYPE_SEM:
;;;221            case OS_EVENT_TYPE_MUTEX:
;;;222            case OS_EVENT_TYPE_MBOX:
;;;223            case OS_EVENT_TYPE_Q:
;;;224                 break;
;;;225    
;;;226            default:
;;;227                 *perr = OS_ERR_EVENT_TYPE;
;;;228                 return;
;;;229        }
;;;230        OS_ENTER_CRITICAL();
;;;231        pevent->OSEventName = pname;
;;;232        OS_EXIT_CRITICAL();
;;;233        *perr = OS_ERR_NONE;
;;;234    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  7828              LDRB     r0,[r5,#0]            ;219
00001c  2801              CMP      r0,#1                 ;219
00001e  d008              BEQ      |L2.50|
000020  2802              CMP      r0,#2                 ;219
000022  d007              BEQ      |L2.52|
000024  2803              CMP      r0,#3                 ;219
000026  d002              BEQ      |L2.46|
000028  2804              CMP      r0,#4                 ;219
00002a  d104              BNE      |L2.54|
00002c  e000              B        |L2.48|
                  |L2.46|
00002e  bf00              NOP                            ;221
                  |L2.48|
000030  bf00              NOP                            ;222
                  |L2.50|
000032  bf00              NOP                            ;223
                  |L2.52|
000034  e002              B        |L2.60|
                  |L2.54|
000036  2001              MOVS     r0,#1                 ;227
000038  7020              STRB     r0,[r4,#0]            ;227
00003a  e7ec              B        |L2.22|
                  |L2.60|
00003c  bf00              NOP                            ;224
00003e  f7fffffe          BL       OS_CPU_SR_Save
000042  4607              MOV      r7,r0                 ;230
000044  612e              STR      r6,[r5,#0x10]         ;231
000046  4638              MOV      r0,r7                 ;232
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2000              MOVS     r0,#0                 ;233
00004e  7020              STRB     r0,[r4,#0]            ;233
000050  bf00              NOP      
000052  e7e0              B        |L2.22|
;;;235    #endif
                          ENDP

                  |L2.84|
                          DCD      OSIntNesting

                          AREA ||i.OSEventPendMulti||, CODE, READONLY, ALIGN=2

                  OSEventPendMulti PROC
;;;309    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;310    INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;311                              OS_EVENT  **pevents_rdy,
;;;312                              void      **pmsgs_rdy,
;;;313                              INT32U      timeout,
;;;314                              INT8U      *perr)
;;;315    {
000004  b083              SUB      sp,sp,#0xc
000006  4681              MOV      r9,r0
000008  460e              MOV      r6,r1
00000a  4615              MOV      r5,r2
00000c  f8dd8040          LDR      r8,[sp,#0x40]
;;;316        OS_EVENT  **pevents;
;;;317        OS_EVENT   *pevent;
;;;318    #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;319        OS_Q       *pq;
;;;320    #endif
;;;321        BOOLEAN     events_rdy;
;;;322        INT16U      events_rdy_nbr;
;;;323        INT8U       events_stat;
;;;324    #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
;;;325        OS_CPU_SR   cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;326    #endif
;;;327    
;;;328    
;;;329    
;;;330    #ifdef OS_SAFETY_CRITICAL
;;;331        if (perr == (INT8U *)0) {
;;;332            OS_SAFETY_CRITICAL_EXCEPTION();
;;;333            return (0u);
;;;334        }
;;;335    #endif
;;;336    
;;;337    #if (OS_ARG_CHK_EN > 0u)
;;;338        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;339           *perr =  OS_ERR_PEVENT_NULL;
;;;340            return (0u);
;;;341        }
;;;342        if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
;;;343           *perr =  OS_ERR_PEVENT_NULL;
;;;344            return (0u);
;;;345        }
;;;346        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;347           *perr =  OS_ERR_PEVENT_NULL;
;;;348            return (0u);
;;;349        }
;;;350        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;351           *perr =  OS_ERR_PEVENT_NULL;
;;;352            return (0u);
;;;353        }
;;;354    #endif
;;;355    
;;;356       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
000014  6030              STR      r0,[r6,#0]
;;;357    
;;;358        pevents     =  pevents_pend;
000016  46ca              MOV      r10,r9
;;;359        pevent      = *pevents;
000018  f8da4000          LDR      r4,[r10,#0]
;;;360        while  (pevent != (OS_EVENT *)0) {
00001c  e018              B        |L3.80|
                  |L3.30|
;;;361            switch (pevent->OSEventType) {                  /* Validate event block types                  */
00001e  7820              LDRB     r0,[r4,#0]
000020  2806              CMP      r0,#6
000022  d207              BCS      |L3.52|
000024  e8dff000          TBB      [pc,r0]
000028  06040503          DCB      0x06,0x04,0x05,0x03
00002c  0708              DCB      0x07,0x08
;;;362    #if (OS_SEM_EN  > 0u)
;;;363                case OS_EVENT_TYPE_SEM:
;;;364                     break;
00002e  e00a              B        |L3.70|
;;;365    #endif
;;;366    #if (OS_MBOX_EN > 0u)
;;;367                case OS_EVENT_TYPE_MBOX:
;;;368                     break;
000030  e009              B        |L3.70|
;;;369    #endif
;;;370    #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
;;;371                case OS_EVENT_TYPE_Q:
;;;372                     break;
000032  e008              B        |L3.70|
                  |L3.52|
;;;373    #endif
;;;374    
;;;375                case OS_EVENT_TYPE_MUTEX:
000034  bf00              NOP      
;;;376                case OS_EVENT_TYPE_FLAG:
000036  bf00              NOP      
;;;377                default:
;;;378                    *perr = OS_ERR_EVENT_TYPE;
000038  2001              MOVS     r0,#1
00003a  f8880000          STRB     r0,[r8,#0]
;;;379                     return (0u);
00003e  2000              MOVS     r0,#0
                  |L3.64|
;;;380            }
;;;381            pevents++;
;;;382            pevent = *pevents;
;;;383        }
;;;384    
;;;385        if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
;;;386           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;387            return (0u);
;;;388        }
;;;389        if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
;;;390           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;391            return (0u);
;;;392        }
;;;393    
;;;394    /*$PAGE*/
;;;395        events_rdy     =  OS_FALSE;
;;;396        events_rdy_nbr =  0u;
;;;397        events_stat    =  OS_STAT_RDY;
;;;398        pevents        =  pevents_pend;
;;;399        pevent         = *pevents;
;;;400        OS_ENTER_CRITICAL();
;;;401        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;402            switch (pevent->OSEventType) {
;;;403    #if (OS_SEM_EN > 0u)
;;;404                case OS_EVENT_TYPE_SEM:
;;;405                     if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
;;;406                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;407                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;408                          events_rdy   =  OS_TRUE;
;;;409                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if (OS_MBOX_EN > 0u)
;;;419                case OS_EVENT_TYPE_MBOX:
;;;420                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;421                                                            /* ... return available message,           ... */
;;;422                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;423                         pevent->OSEventPtr  = (void *)0;
;;;424                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;425                          events_rdy         =  OS_TRUE;
;;;426                          events_rdy_nbr++;
;;;427    
;;;428                     } else {
;;;429                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;430                     }
;;;431                     break;
;;;432    #endif
;;;433    
;;;434    #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;435                case OS_EVENT_TYPE_Q:
;;;436                     pq = (OS_Q *)pevent->OSEventPtr;
;;;437                     if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
;;;438                                                            /* ... return available message,           ... */
;;;439                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;440                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;441                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;442                         }
;;;443                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;444                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;445                          events_rdy   = OS_TRUE;
;;;446                          events_rdy_nbr++;
;;;447    
;;;448                     } else {
;;;449                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;450                     }
;;;451                     break;
;;;452    #endif
;;;453    
;;;454                case OS_EVENT_TYPE_MUTEX:
;;;455                case OS_EVENT_TYPE_FLAG:
;;;456                default:
;;;457                     OS_EXIT_CRITICAL();
;;;458                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;459                    *perr        =  OS_ERR_EVENT_TYPE;
;;;460                     return (events_rdy_nbr);
;;;461            }
;;;462            pevents++;
;;;463            pevent = *pevents;
;;;464        }
;;;465    
;;;466        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;467           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;468            OS_EXIT_CRITICAL();
;;;469           *perr        =  OS_ERR_NONE;
;;;470            return (events_rdy_nbr);
;;;471        }
;;;472    /*$PAGE*/
;;;473                                                            /* Otherwise, must wait until any event occurs */
;;;474        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;475                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;476        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;477        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;478        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;479    
;;;480        OS_EXIT_CRITICAL();
;;;481        OS_Sched();                                         /* Find next highest priority task ready       */
;;;482        OS_ENTER_CRITICAL();
;;;483    
;;;484        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;485            case OS_STAT_PEND_OK:
;;;486            case OS_STAT_PEND_ABORT:
;;;487                 pevent = OSTCBCur->OSTCBEventPtr;
;;;488                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;489                    *pevents_rdy++   =  pevent;             /* ... return available event ...              */
;;;490                    *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
;;;491                      events_rdy_nbr =  1;
;;;492    
;;;493                 } else {                                   /* Else NO event available, handle as timeout  */
;;;494                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;495                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;496                 }
;;;497                 break;
;;;498    
;;;499            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;500            default:                                        /* ... remove task from events' wait lists     */
;;;501                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;502                 break;
;;;503        }
;;;504    
;;;505        switch (OSTCBCur->OSTCBStatPend) {
;;;506            case OS_STAT_PEND_OK:
;;;507                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;508    #if (OS_SEM_EN > 0u)
;;;509                     case OS_EVENT_TYPE_SEM:
;;;510                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;511                          break;
;;;512    #endif
;;;513    
;;;514    #if ((OS_MBOX_EN > 0u) ||                 \
;;;515        ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
;;;516                     case OS_EVENT_TYPE_MBOX:
;;;517                     case OS_EVENT_TYPE_Q:
;;;518                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;519                          break;
;;;520    #endif
;;;521    
;;;522                     case OS_EVENT_TYPE_MUTEX:
;;;523                     case OS_EVENT_TYPE_FLAG:
;;;524                     default:
;;;525                          OS_EXIT_CRITICAL();
;;;526                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;527                         *perr        =  OS_ERR_EVENT_TYPE;
;;;528                          return (events_rdy_nbr);
;;;529                 }
;;;530                *perr = OS_ERR_NONE;
;;;531                 break;
;;;532    
;;;533            case OS_STAT_PEND_ABORT:
;;;534                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;535                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;536                 break;
;;;537    
;;;538            case OS_STAT_PEND_TO:
;;;539            default:
;;;540                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;541                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;542                 break;
;;;543        }
;;;544    
;;;545        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;546        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;547        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;548        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;549    #if ((OS_MBOX_EN > 0u) ||                 \
;;;550        ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
;;;551        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;552    #endif
;;;553        OS_EXIT_CRITICAL();
;;;554    
;;;555        return (events_rdy_nbr);
;;;556    }
000040  b007              ADD      sp,sp,#0x1c
000042  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.70|
000046  bf00              NOP                            ;364
000048  f10a0a04          ADD      r10,r10,#4            ;381
00004c  f8da4000          LDR      r4,[r10,#0]           ;382
                  |L3.80|
000050  2c00              CMP      r4,#0                 ;360
000052  d1e4              BNE      |L3.30|
000054  488c              LDR      r0,|L3.648|
000056  7800              LDRB     r0,[r0,#0]            ;385  ; OSIntNesting
000058  b120              CBZ      r0,|L3.100|
00005a  2002              MOVS     r0,#2                 ;386
00005c  f8880000          STRB     r0,[r8,#0]            ;386
000060  2000              MOVS     r0,#0                 ;387
000062  e7ed              B        |L3.64|
                  |L3.100|
000064  4889              LDR      r0,|L3.652|
000066  7800              LDRB     r0,[r0,#0]            ;389  ; OSLockNesting
000068  b120              CBZ      r0,|L3.116|
00006a  200d              MOVS     r0,#0xd               ;390
00006c  f8880000          STRB     r0,[r8,#0]            ;390
000070  2000              MOVS     r0,#0                 ;391
000072  e7e5              B        |L3.64|
                  |L3.116|
000074  2000              MOVS     r0,#0                 ;395
000076  9002              STR      r0,[sp,#8]            ;395
000078  9001              STR      r0,[sp,#4]            ;396
00007a  4683              MOV      r11,r0                ;397
00007c  46ca              MOV      r10,r9                ;398
00007e  f8da4000          LDR      r4,[r10,#0]           ;399
000082  f7fffffe          BL       OS_CPU_SR_Save
000086  9000              STR      r0,[sp,#0]            ;400
000088  e057              B        |L3.314|
                  |L3.138|
00008a  7820              LDRB     r0,[r4,#0]            ;402
00008c  2806              CMP      r0,#6                 ;402
00008e  d243              BCS      |L3.280|
000090  e8dff000          TBB      [pc,r0]               ;402
000094  42152603          DCB      0x42,0x15,0x26,0x03
000098  4344              DCB      0x43,0x44
00009a  8920              LDRH     r0,[r4,#8]            ;405
00009c  b160              CBZ      r0,|L3.184|
00009e  8920              LDRH     r0,[r4,#8]            ;406
0000a0  1e40              SUBS     r0,r0,#1              ;406
0000a2  8120              STRH     r0,[r4,#8]            ;406
0000a4  c610              STM      r6!,{r4}              ;407
0000a6  2001              MOVS     r0,#1                 ;408
0000a8  9002              STR      r0,[sp,#8]            ;408
0000aa  2000              MOVS     r0,#0                 ;409
0000ac  c501              STM      r5!,{r0}              ;409
0000ae  9801              LDR      r0,[sp,#4]            ;410
0000b0  1c40              ADDS     r0,r0,#1              ;410
0000b2  b280              UXTH     r0,r0                 ;410
0000b4  9001              STR      r0,[sp,#4]            ;410
0000b6  e001              B        |L3.188|
                  |L3.184|
0000b8  f04b0b01          ORR      r11,r11,#1            ;413
                  |L3.188|
0000bc  e038              B        |L3.304|
0000be  6860              LDR      r0,[r4,#4]            ;420
0000c0  b158              CBZ      r0,|L3.218|
0000c2  6860              LDR      r0,[r4,#4]            ;422
0000c4  c501              STM      r5!,{r0}              ;422
0000c6  2000              MOVS     r0,#0                 ;423
0000c8  6060              STR      r0,[r4,#4]            ;423
0000ca  c610              STM      r6!,{r4}              ;424
0000cc  2001              MOVS     r0,#1                 ;425
0000ce  9002              STR      r0,[sp,#8]            ;425
0000d0  9801              LDR      r0,[sp,#4]            ;426
0000d2  1c40              ADDS     r0,r0,#1              ;426
0000d4  b280              UXTH     r0,r0                 ;426
0000d6  9001              STR      r0,[sp,#4]            ;426
0000d8  e001              B        |L3.222|
                  |L3.218|
0000da  f04b0b02          ORR      r11,r11,#2            ;429
                  |L3.222|
0000de  e027              B        |L3.304|
0000e0  6867              LDR      r7,[r4,#4]            ;436
0000e2  8af8              LDRH     r0,[r7,#0x16]         ;437
0000e4  b1a8              CBZ      r0,|L3.274|
0000e6  6939              LDR      r1,[r7,#0x10]         ;439
0000e8  1d08              ADDS     r0,r1,#4              ;439
0000ea  6138              STR      r0,[r7,#0x10]         ;439
0000ec  6808              LDR      r0,[r1,#0]            ;439
0000ee  c501              STM      r5!,{r0}              ;439
0000f0  68b9              LDR      r1,[r7,#8]            ;440
0000f2  6938              LDR      r0,[r7,#0x10]         ;440
0000f4  4288              CMP      r0,r1                 ;440
0000f6  d101              BNE      |L3.252|
0000f8  6878              LDR      r0,[r7,#4]            ;441
0000fa  6138              STR      r0,[r7,#0x10]         ;441
                  |L3.252|
0000fc  8af8              LDRH     r0,[r7,#0x16]         ;443
0000fe  1e40              SUBS     r0,r0,#1              ;443
000100  82f8              STRH     r0,[r7,#0x16]         ;443
000102  c610              STM      r6!,{r4}              ;444
000104  2001              MOVS     r0,#1                 ;445
000106  9002              STR      r0,[sp,#8]            ;445
000108  9801              LDR      r0,[sp,#4]            ;446
00010a  1c40              ADDS     r0,r0,#1              ;446
00010c  b280              UXTH     r0,r0                 ;446
00010e  9001              STR      r0,[sp,#4]            ;446
000110  e001              B        |L3.278|
                  |L3.274|
000112  f04b0b04          ORR      r11,r11,#4            ;449
                  |L3.278|
000116  e00b              B        |L3.304|
                  |L3.280|
000118  bf00              NOP                            ;454
00011a  bf00              NOP                            ;455
00011c  9800              LDR      r0,[sp,#0]            ;457
00011e  f7fffffe          BL       OS_CPU_SR_Restore
000122  2000              MOVS     r0,#0                 ;458
000124  6030              STR      r0,[r6,#0]            ;458
000126  2001              MOVS     r0,#1                 ;459
000128  f8880000          STRB     r0,[r8,#0]            ;459
00012c  9801              LDR      r0,[sp,#4]            ;460
00012e  e787              B        |L3.64|
                  |L3.304|
000130  bf00              NOP                            ;415
000132  f10a0a04          ADD      r10,r10,#4            ;462
000136  f8da4000          LDR      r4,[r10,#0]           ;463
                  |L3.314|
00013a  2c00              CMP      r4,#0                 ;401
00013c  d1a5              BNE      |L3.138|
00013e  9802              LDR      r0,[sp,#8]            ;466
000140  2801              CMP      r0,#1                 ;466
000142  d109              BNE      |L3.344|
000144  2000              MOVS     r0,#0                 ;467
000146  6030              STR      r0,[r6,#0]            ;467
000148  9800              LDR      r0,[sp,#0]            ;468
00014a  f7fffffe          BL       OS_CPU_SR_Restore
00014e  2000              MOVS     r0,#0                 ;469
000150  f8880000          STRB     r0,[r8,#0]            ;469
000154  9801              LDR      r0,[sp,#4]            ;470
000156  e773              B        |L3.64|
                  |L3.344|
000158  484d              LDR      r0,|L3.656|
00015a  6800              LDR      r0,[r0,#0]            ;474  ; OSTCBCur
00015c  f8900034          LDRB     r0,[r0,#0x34]         ;474
000160  f04b0180          ORR      r1,r11,#0x80          ;474
000164  4308              ORRS     r0,r0,r1              ;474
000166  494a              LDR      r1,|L3.656|
000168  6809              LDR      r1,[r1,#0]            ;474  ; OSTCBCur
00016a  f8810034          STRB     r0,[r1,#0x34]         ;474
00016e  2000              MOVS     r0,#0                 ;476
000170  4947              LDR      r1,|L3.656|
000172  6809              LDR      r1,[r1,#0]            ;476  ; OSTCBCur
000174  f8810035          STRB     r0,[r1,#0x35]         ;476
000178  4945              LDR      r1,|L3.656|
00017a  9806              LDR      r0,[sp,#0x18]         ;477
00017c  6809              LDR      r1,[r1,#0]            ;477  ; OSTCBCur
00017e  6308              STR      r0,[r1,#0x30]         ;477
000180  4648              MOV      r0,r9                 ;478
000182  f7fffffe          BL       OS_EventTaskWaitMulti
000186  9800              LDR      r0,[sp,#0]            ;480
000188  f7fffffe          BL       OS_CPU_SR_Restore
00018c  f7fffffe          BL       OS_Sched
000190  f7fffffe          BL       OS_CPU_SR_Save
000194  9000              STR      r0,[sp,#0]            ;482
000196  483e              LDR      r0,|L3.656|
000198  6800              LDR      r0,[r0,#0]            ;484  ; OSTCBCur
00019a  f8900035          LDRB     r0,[r0,#0x35]         ;484
00019e  b120              CBZ      r0,|L3.426|
0001a0  2801              CMP      r0,#1                 ;484
0001a2  d019              BEQ      |L3.472|
0001a4  2802              CMP      r0,#2                 ;484
0001a6  d116              BNE      |L3.470|
0001a8  e000              B        |L3.428|
                  |L3.426|
0001aa  bf00              NOP                            ;486
                  |L3.428|
0001ac  4838              LDR      r0,|L3.656|
0001ae  6800              LDR      r0,[r0,#0]            ;487  ; OSTCBCur
0001b0  69c4              LDR      r4,[r0,#0x1c]         ;487
0001b2  b12c              CBZ      r4,|L3.448|
0001b4  c610              STM      r6!,{r4}              ;489
0001b6  2000              MOVS     r0,#0                 ;490
0001b8  6030              STR      r0,[r6,#0]            ;490
0001ba  2001              MOVS     r0,#1                 ;491
0001bc  9001              STR      r0,[sp,#4]            ;491
0001be  e009              B        |L3.468|
                  |L3.448|
0001c0  2001              MOVS     r0,#1                 ;494
0001c2  4933              LDR      r1,|L3.656|
0001c4  6809              LDR      r1,[r1,#0]            ;494  ; OSTCBCur
0001c6  f8810035          STRB     r0,[r1,#0x35]         ;494
0001ca  4649              MOV      r1,r9                 ;495
0001cc  4830              LDR      r0,|L3.656|
0001ce  6800              LDR      r0,[r0,#0]            ;495  ; OSTCBCur
0001d0  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L3.468|
0001d4  e006              B        |L3.484|
                  |L3.470|
0001d6  bf00              NOP                            ;499
                  |L3.472|
0001d8  4649              MOV      r1,r9                 ;501
0001da  482d              LDR      r0,|L3.656|
0001dc  6800              LDR      r0,[r0,#0]            ;501  ; OSTCBCur
0001de  f7fffffe          BL       OS_EventTaskRemoveMulti
0001e2  bf00              NOP                            ;502
                  |L3.484|
0001e4  bf00              NOP                            ;497
0001e6  482a              LDR      r0,|L3.656|
0001e8  6800              LDR      r0,[r0,#0]            ;505  ; OSTCBCur
0001ea  f8900035          LDRB     r0,[r0,#0x35]         ;505
0001ee  b120              CBZ      r0,|L3.506|
0001f0  2801              CMP      r0,#1                 ;505
0001f2  d02b              BEQ      |L3.588|
0001f4  2802              CMP      r0,#2                 ;505
0001f6  d128              BNE      |L3.586|
0001f8  e021              B        |L3.574|
                  |L3.506|
0001fa  7820              LDRB     r0,[r4,#0]            ;507
0001fc  2806              CMP      r0,#6                 ;507
0001fe  d20d              BCS      |L3.540|
000200  e8dff000          TBB      [pc,r0]               ;507
000204  0c060703          DCB      0x0c,0x06,0x07,0x03
000208  0d0e              DCB      0x0d,0x0e
00020a  2000              MOVS     r0,#0                 ;510
00020c  c501              STM      r5!,{r0}              ;510
00020e  e011              B        |L3.564|
000210  bf00              NOP                            ;517
000212  481f              LDR      r0,|L3.656|
000214  6800              LDR      r0,[r0,#0]            ;518  ; OSTCBCur
000216  6a40              LDR      r0,[r0,#0x24]         ;518
000218  c501              STM      r5!,{r0}              ;518
00021a  e00b              B        |L3.564|
                  |L3.540|
00021c  bf00              NOP                            ;522
00021e  bf00              NOP                            ;523
000220  9800              LDR      r0,[sp,#0]            ;525
000222  f7fffffe          BL       OS_CPU_SR_Restore
000226  2000              MOVS     r0,#0                 ;526
000228  6030              STR      r0,[r6,#0]            ;526
00022a  2001              MOVS     r0,#1                 ;527
00022c  f8880000          STRB     r0,[r8,#0]            ;527
000230  9801              LDR      r0,[sp,#4]            ;528
000232  e705              B        |L3.64|
                  |L3.564|
000234  bf00              NOP                            ;511
000236  2000              MOVS     r0,#0                 ;530
000238  f8880000          STRB     r0,[r8,#0]            ;530
00023c  e00c              B        |L3.600|
                  |L3.574|
00023e  2000              MOVS     r0,#0                 ;534
000240  c501              STM      r5!,{r0}              ;534
000242  200e              MOVS     r0,#0xe               ;535
000244  f8880000          STRB     r0,[r8,#0]            ;535
000248  e006              B        |L3.600|
                  |L3.586|
00024a  bf00              NOP                            ;538
                  |L3.588|
00024c  2000              MOVS     r0,#0                 ;540
00024e  c501              STM      r5!,{r0}              ;540
000250  200a              MOVS     r0,#0xa               ;541
000252  f8880000          STRB     r0,[r8,#0]            ;541
000256  bf00              NOP                            ;542
                  |L3.600|
000258  bf00              NOP                            ;531
00025a  2000              MOVS     r0,#0                 ;545
00025c  490c              LDR      r1,|L3.656|
00025e  6809              LDR      r1,[r1,#0]            ;545  ; OSTCBCur
000260  f8810034          STRB     r0,[r1,#0x34]         ;545
000264  490a              LDR      r1,|L3.656|
000266  6809              LDR      r1,[r1,#0]            ;546  ; OSTCBCur
000268  f8810035          STRB     r0,[r1,#0x35]         ;546
00026c  4908              LDR      r1,|L3.656|
00026e  6809              LDR      r1,[r1,#0]            ;547  ; OSTCBCur
000270  61c8              STR      r0,[r1,#0x1c]         ;547
000272  4907              LDR      r1,|L3.656|
000274  6809              LDR      r1,[r1,#0]            ;548  ; OSTCBCur
000276  6208              STR      r0,[r1,#0x20]         ;548
000278  4905              LDR      r1,|L3.656|
00027a  6809              LDR      r1,[r1,#0]            ;551  ; OSTCBCur
00027c  6248              STR      r0,[r1,#0x24]         ;551
00027e  9800              LDR      r0,[sp,#0]            ;553
000280  f7fffffe          BL       OS_CPU_SR_Restore
000284  9801              LDR      r0,[sp,#4]            ;555
000286  e6db              B        |L3.64|
;;;557    #endif
                          ENDP

                  |L3.648|
                          DCD      OSIntNesting
                  |L3.652|
                          DCD      OSLockNesting
                  |L3.656|
                          DCD      OSTCBCur

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;572    
;;;573    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;574    {
;;;575        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;576    
;;;577        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;578    
;;;579        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;580    
;;;581        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;582    
;;;583        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;584    
;;;585    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;586        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;587    #endif
;;;588    
;;;589    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;590        OS_MemInit();                                                /* Initialize the memory manager            */
00001a  f7fffffe          BL       OS_MemInit
;;;591    #endif
;;;592    
;;;593    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;594        OS_QInit();                                                  /* Initialize the message queue structures  */
00001e  f7fffffe          BL       OS_QInit
;;;595    #endif
;;;596    
;;;597        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000022  f7fffffe          BL       OS_InitTaskIdle
;;;598    #if OS_TASK_STAT_EN > 0u
;;;599        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000026  f7fffffe          BL       OS_InitTaskStat
;;;600    #endif
;;;601    
;;;602    #if OS_TMR_EN > 0u
;;;603        OSTmr_Init();                                                /* Initialize the Timer Manager             */
00002a  f7fffffe          BL       OSTmr_Init
;;;604    #endif
;;;605    
;;;606        OSInitHookEnd();                                             /* Call port specific init. code            */
00002e  f7fffffe          BL       OSInitHookEnd
;;;607    
;;;608    #if OS_DEBUG_EN > 0u
;;;609        OSDebugInit();
000032  f7fffffe          BL       OSDebugInit
;;;610    #endif
;;;611    }
000036  bd10              POP      {r4,pc}
;;;612    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;637    
;;;638    void  OSIntEnter (void)
000000  4806              LDR      r0,|L5.28|
;;;639    {
;;;640        if (OSRunning == OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L5.26|
;;;641            if (OSIntNesting < 255u) {
000008  4805              LDR      r0,|L5.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L5.26|
;;;642                OSIntNesting++;                      /* Increment ISR nesting level                        */
000010  4803              LDR      r0,|L5.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L5.32|
000018  7008              STRB     r0,[r1,#0]
                  |L5.26|
;;;643            }
;;;644        }
;;;645    }
00001a  4770              BX       lr
;;;646    /*$PAGE*/
                          ENDP

                  |L5.28|
                          DCD      OSRunning
                  |L5.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;665    
;;;666    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;667    {
;;;668    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;669        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;670    #endif
;;;671    
;;;672    
;;;673    
;;;674        if (OSRunning == OS_TRUE) {
000004  481a              LDR      r0,|L6.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L6.110|
;;;675            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;676            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L6.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b120              CBZ      r0,|L6.34|
;;;677                OSIntNesting--;
000018  4816              LDR      r0,|L6.116|
00001a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  4915              LDR      r1,|L6.116|
000020  7008              STRB     r0,[r1,#0]
                  |L6.34|
;;;678            }
;;;679            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000022  4814              LDR      r0,|L6.116|
000024  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000026  b9f8              CBNZ     r0,|L6.104|
;;;680                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000028  4813              LDR      r0,|L6.120|
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b9e0              CBNZ     r0,|L6.104|
;;;681                    OS_SchedNew();
00002e  f7fffffe          BL       OS_SchedNew
;;;682                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000032  4812              LDR      r0,|L6.124|
000034  4912              LDR      r1,|L6.128|
000036  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000038  f8500021          LDR      r0,[r0,r1,LSL #2]
00003c  4911              LDR      r1,|L6.132|
00003e  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;683                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000040  480f              LDR      r0,|L6.128|
000042  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000044  4910              LDR      r1,|L6.136|
000046  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000048  4288              CMP      r0,r1
00004a  d00d              BEQ      |L6.104|
;;;684    #if OS_TASK_PROFILE_EN > 0u
;;;685                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004c  480d              LDR      r0,|L6.132|
00004e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000050  6bc0              LDR      r0,[r0,#0x3c]
000052  1c40              ADDS     r0,r0,#1
000054  490b              LDR      r1,|L6.132|
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  63c8              STR      r0,[r1,#0x3c]
;;;686    #endif
;;;687                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L6.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L6.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;688                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L6.104|
;;;689                    }
;;;690                }
;;;691            }
;;;692            OS_EXIT_CRITICAL();
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L6.110|
;;;693        }
;;;694    }
00006e  bd10              POP      {r4,pc}
;;;695    /*$PAGE*/
                          ENDP

                  |L6.112|
                          DCD      OSRunning
                  |L6.116|
                          DCD      OSIntNesting
                  |L6.120|
                          DCD      OSLockNesting
                  |L6.124|
                          DCD      OSTCBPrioTbl
                  |L6.128|
                          DCD      OSPrioHighRdy
                  |L6.132|
                          DCD      OSTCBHighRdy
                  |L6.136|
                          DCD      OSPrioCur
                  |L6.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;738    #if OS_SCHED_LOCK_EN > 0u
;;;739    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;740    {
;;;741    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;742        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;743    #endif
;;;744    
;;;745    
;;;746    
;;;747        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000004  480b              LDR      r0,|L7.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L7.48|
;;;748            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;749            if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
000012  4809              LDR      r0,|L7.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L7.42|
;;;750                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000018  4808              LDR      r0,|L7.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L7.42|
;;;751                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L7.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L7.60|
000028  7008              STRB     r0,[r1,#0]
                  |L7.42|
;;;752                }
;;;753            }
;;;754            OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L7.48|
;;;755        }
;;;756    }
000030  bd10              POP      {r4,pc}
;;;757    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      OSRunning
                  |L7.56|
                          DCD      OSIntNesting
                  |L7.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;775    #if OS_SCHED_LOCK_EN > 0u
;;;776    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;777    {
;;;778    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;779        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;780    #endif
;;;781    
;;;782    
;;;783    
;;;784        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L8.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d121              BNE      |L8.80|
;;;785            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;786            if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000012  4811              LDR      r0,|L8.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b9c0              CBNZ     r0,|L8.74|
;;;787                if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000018  4810              LDR      r0,|L8.92|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  b188              CBZ      r0,|L8.66|
;;;788                    OSLockNesting--;                           /* Decrement lock nesting level             */
00001e  480f              LDR      r0,|L8.92|
000020  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000022  1e40              SUBS     r0,r0,#1
000024  490d              LDR      r1,|L8.92|
000026  7008              STRB     r0,[r1,#0]
;;;789                    if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000028  4608              MOV      r0,r1
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b928              CBNZ     r0,|L8.58|
;;;790                        OS_EXIT_CRITICAL();
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;791                        OS_Sched();                            /* See if a HPT is ready                    */
000034  f7fffffe          BL       OS_Sched
000038  e00a              B        |L8.80|
                  |L8.58|
;;;792                    } else {
;;;793                        OS_EXIT_CRITICAL();
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  e006              B        |L8.80|
                  |L8.66|
;;;794                    }
;;;795                } else {
;;;796                    OS_EXIT_CRITICAL();
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  e002              B        |L8.80|
                  |L8.74|
;;;797                }
;;;798            } else {
;;;799                OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L8.80|
;;;800            }
;;;801        }
;;;802    }
000050  bd10              POP      {r4,pc}
;;;803    #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L8.84|
                          DCD      OSRunning
                  |L8.88|
                          DCD      OSIntNesting
                  |L8.92|
                          DCD      OSLockNesting

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;825    
;;;826    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;827    {
;;;828        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L9.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L9.46|
;;;829            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;830            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L9.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L9.56|
000012  7008              STRB     r0,[r1,#0]
;;;831            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L9.60|
000016  4907              LDR      r1,|L9.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L9.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;832            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L9.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;833            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L9.46|
;;;834        }
;;;835    }
00002e  bd10              POP      {r4,pc}
;;;836    /*$PAGE*/
                          ENDP

                  |L9.48|
                          DCD      OSRunning
                  |L9.52|
                          DCD      OSPrioHighRdy
                  |L9.56|
                          DCD      OSPrioCur
                  |L9.60|
                          DCD      OSTCBPrioTbl
                  |L9.64|
                          DCD      OSTCBHighRdy
                  |L9.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;857    #if OS_TASK_STAT_EN > 0u
;;;858    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;859    {
;;;860    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;861        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;862    #endif
;;;863    
;;;864    
;;;865    
;;;866        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;867        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;868        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L10.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;869        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;870        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001c  2064              MOVS     r0,#0x64
00001e  f7fffffe          BL       OSTimeDly
;;;871        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;872        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L10.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L10.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;873        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L10.72|
000034  7008              STRB     r0,[r1,#0]
;;;874        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;875    }
00003c  bd10              POP      {r4,pc}
;;;876    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L10.64|
                          DCD      OSIdleCtr
                  |L10.68|
                          DCD      OSIdleCtrMax
                  |L10.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;891    
;;;892    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;893    {
;;;894        OS_TCB    *ptcb;
;;;895    #if OS_TICK_STEP_EN > 0u
;;;896        BOOLEAN    step;
;;;897    #endif
;;;898    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;899        OS_CPU_SR  cpu_sr = 0u;
000002  2600              MOVS     r6,#0
;;;900    #endif
;;;901    
;;;902    
;;;903    
;;;904    #if OS_TIME_TICK_HOOK_EN > 0u
;;;905        OSTimeTickHook();                                      /* Call user definable hook                     */
000004  f7fffffe          BL       OSTimeTickHook
;;;906    #endif
;;;907    #if OS_TIME_GET_SET_EN > 0u
;;;908        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;909        OSTime++;
00000e  4833              LDR      r0,|L11.220|
000010  6800              LDR      r0,[r0,#0]  ; OSTime
000012  1c40              ADDS     r0,r0,#1
000014  4931              LDR      r1,|L11.220|
000016  6008              STR      r0,[r1,#0]  ; OSTime
;;;910        OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;911    #endif
;;;912        if (OSRunning == OS_TRUE) {
00001e  4830              LDR      r0,|L11.224|
000020  7800              LDRB     r0,[r0,#0]  ; OSRunning
000022  2801              CMP      r0,#1
000024  d157              BNE      |L11.214|
;;;913    #if OS_TICK_STEP_EN > 0u
;;;914            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000026  482f              LDR      r0,|L11.228|
000028  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
00002a  b120              CBZ      r0,|L11.54|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L11.58|
000030  2802              CMP      r0,#2
000032  d109              BNE      |L11.72|
000034  e003              B        |L11.62|
                  |L11.54|
;;;915                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;916                     step = OS_TRUE;
000036  2501              MOVS     r5,#1
;;;917                     break;
000038  e00b              B        |L11.82|
                  |L11.58|
;;;918    
;;;919                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;920                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
00003a  2500              MOVS     r5,#0
;;;921                     break;
00003c  e009              B        |L11.82|
                  |L11.62|
;;;922    
;;;923                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;924                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
00003e  2501              MOVS     r5,#1
;;;925                     OSTickStepState = OS_TICK_STEP_WAIT;
000040  2001              MOVS     r0,#1
000042  4928              LDR      r1,|L11.228|
000044  7008              STRB     r0,[r1,#0]
;;;926                     break;
000046  e004              B        |L11.82|
                  |L11.72|
;;;927    
;;;928                default:                                       /* Invalid case, correct situation              */
;;;929                     step            = OS_TRUE;
000048  2501              MOVS     r5,#1
;;;930                     OSTickStepState = OS_TICK_STEP_DIS;
00004a  2000              MOVS     r0,#0
00004c  4925              LDR      r1,|L11.228|
00004e  7008              STRB     r0,[r1,#0]
;;;931                     break;
000050  bf00              NOP      
                  |L11.82|
000052  bf00              NOP                            ;917
;;;932            }
;;;933            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000054  b905              CBNZ     r5,|L11.88|
                  |L11.86|
;;;934                return;
;;;935            }
;;;936    #endif
;;;937            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;938            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;939                OS_ENTER_CRITICAL();
;;;940                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
;;;941                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
;;;942                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
;;;943    
;;;944                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;945                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;946                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;947                        } else {
;;;948                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;949                        }
;;;950    
;;;951                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;952                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;953                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;954                        }
;;;955                    }
;;;956                }
;;;957                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;958                OS_EXIT_CRITICAL();
;;;959            }
;;;960        }
;;;961    }
000056  bd70              POP      {r4-r6,pc}
                  |L11.88|
000058  4823              LDR      r0,|L11.232|
00005a  6804              LDR      r4,[r0,#0]            ;937  ; OSTCBList
00005c  e037              B        |L11.206|
                  |L11.94|
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4606              MOV      r6,r0                 ;939
000064  6b20              LDR      r0,[r4,#0x30]         ;940
000066  b370              CBZ      r0,|L11.198|
000068  6b20              LDR      r0,[r4,#0x30]         ;941
00006a  1e40              SUBS     r0,r0,#1              ;941
00006c  6320              STR      r0,[r4,#0x30]         ;941
00006e  6b20              LDR      r0,[r4,#0x30]         ;942
000070  bb48              CBNZ     r0,|L11.198|
000072  f8940034          LDRB     r0,[r4,#0x34]         ;944
000076  f0100f37          TST      r0,#0x37              ;944
00007a  d009              BEQ      |L11.144|
00007c  f8140f34          LDRB     r0,[r4,#0x34]!        ;945
000080  f00000c8          AND      r0,r0,#0xc8           ;945
000084  7020              STRB     r0,[r4,#0]            ;945
000086  2001              MOVS     r0,#1                 ;946
000088  7060              STRB     r0,[r4,#1]            ;946
00008a  f1a40434          SUB      r4,r4,#0x34           ;946
00008e  e002              B        |L11.150|
                  |L11.144|
000090  2000              MOVS     r0,#0                 ;948
000092  f8840035          STRB     r0,[r4,#0x35]         ;948
                  |L11.150|
000096  f8940034          LDRB     r0,[r4,#0x34]         ;951
00009a  f0100f08          TST      r0,#8                 ;951
00009e  d112              BNE      |L11.198|
0000a0  f1040438          ADD      r4,r4,#0x38           ;952
0000a4  78a0              LDRB     r0,[r4,#2]            ;952
0000a6  4911              LDR      r1,|L11.236|
0000a8  7809              LDRB     r1,[r1,#0]            ;952  ; OSRdyGrp
0000aa  ea400001          ORR      r0,r0,r1              ;952
0000ae  490f              LDR      r1,|L11.236|
0000b0  7008              STRB     r0,[r1,#0]            ;952
0000b2  7820              LDRB     r0,[r4,#0]            ;953
0000b4  490e              LDR      r1,|L11.240|
0000b6  5c08              LDRB     r0,[r1,r0]            ;953
0000b8  7861              LDRB     r1,[r4,#1]            ;953
0000ba  ea400001          ORR      r0,r0,r1              ;953
0000be  f8141938          LDRB     r1,[r4],#-0x38        ;953
0000c2  4a0b              LDR      r2,|L11.240|
0000c4  5450              STRB     r0,[r2,r1]            ;953
                  |L11.198|
0000c6  6964              LDR      r4,[r4,#0x14]         ;957
0000c8  4630              MOV      r0,r6                 ;958
0000ca  f7fffffe          BL       OS_CPU_SR_Restore
                  |L11.206|
0000ce  f8940036          LDRB     r0,[r4,#0x36]         ;938
0000d2  281f              CMP      r0,#0x1f              ;938
0000d4  d1c3              BNE      |L11.94|
                  |L11.214|
0000d6  bf00              NOP      
0000d8  e7bd              B        |L11.86|
;;;962    
                          ENDP

0000da  0000              DCW      0x0000
                  |L11.220|
                          DCD      OSTime
                  |L11.224|
                          DCD      OSRunning
                  |L11.228|
                          DCD      OSTickStepState
                  |L11.232|
                          DCD      OSTCBList
                  |L11.236|
                          DCD      OSRdyGrp
                  |L11.240|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;977    
;;;978    INT16U  OSVersion (void)
000000  f44f7092          MOV      r0,#0x124
;;;979    {
;;;980        return (OS_VERSION);
;;;981    }
000004  4770              BX       lr
;;;982    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;996    #if OS_TASK_DEL_EN > 0u
;;;997    void  OS_Dummy (void)
000000  4770              BX       lr
;;;998    {
;;;999    }
;;;1000   #endif
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;1030   #if (OS_EVENT_EN)
;;;1031   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1032                           void      *pmsg,
;;;1033                           INT8U      msk,
;;;1034                           INT8U      pend_stat)
;;;1035   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;1036       OS_TCB   *ptcb;
;;;1037       INT8U     y;
;;;1038       INT8U     x;
;;;1039       INT8U     prio;
;;;1040   #if OS_LOWEST_PRIO > 63u
;;;1041       OS_PRIO  *ptbl;
;;;1042   #endif
;;;1043   
;;;1044   
;;;1045   #if OS_LOWEST_PRIO <= 63u
;;;1046       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000c  7aa8              LDRB     r0,[r5,#0xa]
00000e  491d              LDR      r1,|L14.132|
000010  5c0e              LDRB     r6,[r1,r0]
;;;1047       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000012  f105000b          ADD      r0,r5,#0xb
000016  5d80              LDRB     r0,[r0,r6]
000018  f811b000          LDRB     r11,[r1,r0]
;;;1048       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001c  eb0b00c6          ADD      r0,r11,r6,LSL #3
000020  f0000aff          AND      r10,r0,#0xff
;;;1049   #else
;;;1050       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1051           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1052       } else {
;;;1053           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1054       }
;;;1055       ptbl = &pevent->OSEventTbl[y];
;;;1056       if ((*ptbl & 0xFFu) != 0u) {
;;;1057           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1058       } else {
;;;1059           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1060       }
;;;1061       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1062   #endif
;;;1063   
;;;1064       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000024  4818              LDR      r0,|L14.136|
000026  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1065       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00002a  2000              MOVS     r0,#0
00002c  f1040424          ADD      r4,r4,#0x24
000030  60e0              STR      r0,[r4,#0xc]
;;;1066   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1067       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000032  6027              STR      r7,[r4,#0]
;;;1068   #else
;;;1069       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1070   #endif
;;;1071       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000034  7c20              LDRB     r0,[r4,#0x10]
000036  ea200008          BIC      r0,r0,r8
00003a  7420              STRB     r0,[r4,#0x10]
;;;1072       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00003c  f8849011          STRB     r9,[r4,#0x11]
;;;1073                                                           /* See if task is ready (could be susp'd)      */
;;;1074       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000040  7c20              LDRB     r0,[r4,#0x10]
000042  f1a40424          SUB      r4,r4,#0x24
000046  f0100f08          TST      r0,#8
00004a  d10d              BNE      |L14.104|
;;;1075           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00004c  f894003a          LDRB     r0,[r4,#0x3a]
000050  490e              LDR      r1,|L14.140|
000052  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000054  4308              ORRS     r0,r0,r1
000056  490d              LDR      r1,|L14.140|
000058  7008              STRB     r0,[r1,#0]
;;;1076           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
00005a  480d              LDR      r0,|L14.144|
00005c  5d80              LDRB     r0,[r0,r6]
00005e  f8941039          LDRB     r1,[r4,#0x39]
000062  4308              ORRS     r0,r0,r1
000064  490a              LDR      r1,|L14.144|
000066  5588              STRB     r0,[r1,r6]
                  |L14.104|
;;;1077       }
;;;1078   
;;;1079       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000068  4629              MOV      r1,r5
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OS_EventTaskRemove
;;;1080   #if (OS_EVENT_MULTI_EN > 0u)
;;;1081       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000070  6a20              LDR      r0,[r4,#0x20]
000072  b120              CBZ      r0,|L14.126|
;;;1082           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000074  4620              MOV      r0,r4
000076  6a21              LDR      r1,[r4,#0x20]
000078  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1083           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
00007c  61e5              STR      r5,[r4,#0x1c]
                  |L14.126|
;;;1084       }
;;;1085   #endif
;;;1086   
;;;1087       return (prio);
00007e  4650              MOV      r0,r10
;;;1088   }
000080  e8bd8ff0          POP      {r4-r11,pc}
;;;1089   #endif
                          ENDP

                  |L14.132|
                          DCD      OSUnMapTbl
                  |L14.136|
                          DCD      OSTCBPrioTbl
                  |L14.140|
                          DCD      OSRdyGrp
                  |L14.144|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1182   #if (OS_EVENT_EN)
;;;1183   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1184                             OS_EVENT *pevent)
;;;1185   {
;;;1186       INT8U  y;
;;;1187   
;;;1188   
;;;1189       y                       =  ptcb->OSTCBY;
000002  f8902038          LDRB     r2,[r0,#0x38]
;;;1190       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000006  f101030b          ADD      r3,r1,#0xb
00000a  5c9b              LDRB     r3,[r3,r2]
00000c  f8904039          LDRB     r4,[r0,#0x39]
000010  43a3              BICS     r3,r3,r4
000012  f101040b          ADD      r4,r1,#0xb
000016  54a3              STRB     r3,[r4,r2]
;;;1191       if (pevent->OSEventTbl[y] == 0u) {
000018  4623              MOV      r3,r4
00001a  5c9b              LDRB     r3,[r3,r2]
00001c  b923              CBNZ     r3,|L15.40|
;;;1192           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001e  7a8b              LDRB     r3,[r1,#0xa]
000020  f890403a          LDRB     r4,[r0,#0x3a]
000024  43a3              BICS     r3,r3,r4
000026  728b              STRB     r3,[r1,#0xa]
                  |L15.40|
;;;1193       }
;;;1194   }
000028  bd10              POP      {r4,pc}
;;;1195   #endif
                          ENDP


                          AREA ||i.OS_EventTaskRemoveMulti||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemoveMulti PROC
;;;1212   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;1213   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1214                                  OS_EVENT **pevents_multi)
;;;1215   {
000002  4602              MOV      r2,r0
;;;1216       OS_EVENT **pevents;
;;;1217       OS_EVENT  *pevent;
;;;1218       INT8U      y;
;;;1219       OS_PRIO    bity;
;;;1220       OS_PRIO    bitx;
;;;1221   
;;;1222   
;;;1223       y       =  ptcb->OSTCBY;
000004  f8124f38          LDRB     r4,[r2,#0x38]!
;;;1224       bity    =  ptcb->OSTCBBitY;
000008  7895              LDRB     r5,[r2,#2]
;;;1225       bitx    =  ptcb->OSTCBBitX;
00000a  7856              LDRB     r6,[r2,#1]
00000c  f1a20238          SUB      r2,r2,#0x38
;;;1226       pevents =  pevents_multi;
000010  460b              MOV      r3,r1
;;;1227       pevent  = *pevents;
000012  6818              LDR      r0,[r3,#0]
;;;1228       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
000014  e00f              B        |L16.54|
                  |L16.22|
;;;1229           pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
000016  f100070b          ADD      r7,r0,#0xb
00001a  5d3f              LDRB     r7,[r7,r4]
00001c  43b7              BICS     r7,r7,r6
00001e  f1000c0b          ADD      r12,r0,#0xb
000022  f80c7004          STRB     r7,[r12,r4]
;;;1230           if (pevent->OSEventTbl[y] == 0u) {
000026  4667              MOV      r7,r12
000028  5d3f              LDRB     r7,[r7,r4]
00002a  b917              CBNZ     r7,|L16.50|
;;;1231               pevent->OSEventGrp &= (OS_PRIO)~bity;
00002c  7a87              LDRB     r7,[r0,#0xa]
00002e  43af              BICS     r7,r7,r5
000030  7287              STRB     r7,[r0,#0xa]
                  |L16.50|
;;;1232           }
;;;1233           pevents++;
000032  1d1b              ADDS     r3,r3,#4
;;;1234           pevent = *pevents;
000034  6818              LDR      r0,[r3,#0]
                  |L16.54|
000036  2800              CMP      r0,#0                 ;1228
000038  d1ed              BNE      |L16.22|
;;;1235       }
;;;1236   }
00003a  bdf0              POP      {r4-r7,pc}
;;;1237   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1105   #if (OS_EVENT_EN)
;;;1106   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;1107   {
;;;1108       INT8U  y;
;;;1109   
;;;1110   
;;;1111       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4a1b              LDR      r2,|L17.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;1112   
;;;1113       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000008  4a19              LDR      r2,|L17.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8923038          LDRB     r3,[r2,#0x38]
000010  f100020b          ADD      r2,r0,#0xb
000014  5cd2              LDRB     r2,[r2,r3]
000016  4b16              LDR      r3,|L17.112|
000018  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00001a  f8933039          LDRB     r3,[r3,#0x39]
00001e  431a              ORRS     r2,r2,r3
000020  4b13              LDR      r3,|L17.112|
000022  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000024  f8934038          LDRB     r4,[r3,#0x38]
000028  f100030b          ADD      r3,r0,#0xb
00002c  551a              STRB     r2,[r3,r4]
;;;1114       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00002e  7a82              LDRB     r2,[r0,#0xa]
000030  4b0f              LDR      r3,|L17.112|
000032  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000034  f893303a          LDRB     r3,[r3,#0x3a]
000038  431a              ORRS     r2,r2,r3
00003a  7282              STRB     r2,[r0,#0xa]
;;;1115   
;;;1116       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00003c  4a0c              LDR      r2,|L17.112|
00003e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000040  f8921038          LDRB     r1,[r2,#0x38]
;;;1117       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000044  4a0b              LDR      r2,|L17.116|
000046  5c52              LDRB     r2,[r2,r1]
000048  4b09              LDR      r3,|L17.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933039          LDRB     r3,[r3,#0x39]
000050  439a              BICS     r2,r2,r3
000052  4b08              LDR      r3,|L17.116|
000054  545a              STRB     r2,[r3,r1]
;;;1118       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000056  461a              MOV      r2,r3
000058  5c52              LDRB     r2,[r2,r1]
00005a  b942              CBNZ     r2,|L17.110|
;;;1119           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005c  4a04              LDR      r2,|L17.112|
00005e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000060  f892303a          LDRB     r3,[r2,#0x3a]
000064  4a04              LDR      r2,|L17.120|
000066  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000068  439a              BICS     r2,r2,r3
00006a  4b03              LDR      r3,|L17.120|
00006c  701a              STRB     r2,[r3,#0]
                  |L17.110|
;;;1120       }
;;;1121   }
00006e  bd10              POP      {r4,pc}
;;;1122   #endif
                          ENDP

                  |L17.112|
                          DCD      OSTCBCur
                  |L17.116|
                          DCD      OSRdyTbl
                  |L17.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventTaskWaitMulti||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWaitMulti PROC
;;;1139   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;1140   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
000000  b570              PUSH     {r4-r6,lr}
;;;1141   {
000002  4601              MOV      r1,r0
;;;1142       OS_EVENT **pevents;
;;;1143       OS_EVENT  *pevent;
;;;1144       INT8U      y;
;;;1145   
;;;1146   
;;;1147       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000004  2400              MOVS     r4,#0
000006  4d20              LDR      r5,|L18.136|
000008  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00000a  61ec              STR      r4,[r5,#0x1c]
;;;1148       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00000c  4c1e              LDR      r4,|L18.136|
00000e  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000010  6221              STR      r1,[r4,#0x20]
;;;1149   
;;;1150       pevents =  pevents_wait;
000012  460b              MOV      r3,r1
;;;1151       pevent  = *pevents;
000014  6818              LDR      r0,[r3,#0]
;;;1152       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
000016  e01b              B        |L18.80|
                  |L18.24|
;;;1153           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000018  4c1b              LDR      r4,|L18.136|
00001a  6824              LDR      r4,[r4,#0]  ; OSTCBCur
00001c  f8945038          LDRB     r5,[r4,#0x38]
000020  f100040b          ADD      r4,r0,#0xb
000024  5d64              LDRB     r4,[r4,r5]
000026  4d18              LDR      r5,|L18.136|
000028  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00002a  f8955039          LDRB     r5,[r5,#0x39]
00002e  432c              ORRS     r4,r4,r5
000030  4d15              LDR      r5,|L18.136|
000032  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000034  f8956038          LDRB     r6,[r5,#0x38]
000038  f100050b          ADD      r5,r0,#0xb
00003c  55ac              STRB     r4,[r5,r6]
;;;1154           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00003e  7a84              LDRB     r4,[r0,#0xa]
000040  4d11              LDR      r5,|L18.136|
000042  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000044  f895503a          LDRB     r5,[r5,#0x3a]
000048  432c              ORRS     r4,r4,r5
00004a  7284              STRB     r4,[r0,#0xa]
;;;1155           pevents++;
00004c  1d1b              ADDS     r3,r3,#4
;;;1156           pevent = *pevents;
00004e  6818              LDR      r0,[r3,#0]
                  |L18.80|
000050  2800              CMP      r0,#0                 ;1152
000052  d1e1              BNE      |L18.24|
;;;1157       }
;;;1158   
;;;1159       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000054  4c0c              LDR      r4,|L18.136|
000056  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000058  f8942038          LDRB     r2,[r4,#0x38]
;;;1160       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005c  4c0b              LDR      r4,|L18.140|
00005e  5ca4              LDRB     r4,[r4,r2]
000060  4d09              LDR      r5,|L18.136|
000062  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000064  f8955039          LDRB     r5,[r5,#0x39]
000068  43ac              BICS     r4,r4,r5
00006a  4d08              LDR      r5,|L18.140|
00006c  54ac              STRB     r4,[r5,r2]
;;;1161       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00006e  462c              MOV      r4,r5
000070  5ca4              LDRB     r4,[r4,r2]
000072  b944              CBNZ     r4,|L18.134|
;;;1162           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000074  4c04              LDR      r4,|L18.136|
000076  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000078  f894503a          LDRB     r5,[r4,#0x3a]
00007c  4c04              LDR      r4,|L18.144|
00007e  7824              LDRB     r4,[r4,#0]  ; OSRdyGrp
000080  43ac              BICS     r4,r4,r5
000082  4d03              LDR      r5,|L18.144|
000084  702c              STRB     r4,[r5,#0]
                  |L18.134|
;;;1163       }
;;;1164   }
000086  bd70              POP      {r4-r6,pc}
;;;1165   #endif
                          ENDP

                  |L18.136|
                          DCD      OSTCBCur
                  |L18.140|
                          DCD      OSRdyTbl
                  |L18.144|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1252   #if (OS_EVENT_EN)
;;;1253   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  4601              MOV      r1,r0
;;;1254   {
;;;1255       INT8U  i;
;;;1256   
;;;1257   
;;;1258       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000002  2200              MOVS     r2,#0
000004  728a              STRB     r2,[r1,#0xa]
;;;1259       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e005              B        |L19.22|
                  |L19.10|
;;;1260           pevent->OSEventTbl[i] = 0u;
00000a  2300              MOVS     r3,#0
00000c  f101020b          ADD      r2,r1,#0xb
000010  5413              STRB     r3,[r2,r0]
000012  1c42              ADDS     r2,r0,#1              ;1259
000014  b2d0              UXTB     r0,r2                 ;1259
                  |L19.22|
000016  2804              CMP      r0,#4                 ;1259
000018  d3f7              BCC      |L19.10|
;;;1261       }
;;;1262   }
00001a  4770              BX       lr
;;;1263   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1277   
;;;1278   static  void  OS_InitEventList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
;;;1280   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1281   #if (OS_MAX_EVENTS > 1u)
;;;1282       INT16U     ix;
;;;1283       INT16U     ix_next;
;;;1284       OS_EVENT  *pevent1;
;;;1285       OS_EVENT  *pevent2;
;;;1286   
;;;1287   
;;;1288       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  21c8              MOVS     r1,#0xc8
000004  4813              LDR      r0,|L20.84|
000006  f7fffffe          BL       OS_MemClr
;;;1289       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00000a  2400              MOVS     r4,#0
00000c  e011              B        |L20.50|
                  |L20.14|
;;;1290           ix_next = ix + 1u;
00000e  1c60              ADDS     r0,r4,#1
000010  b285              UXTH     r5,r0
;;;1291           pevent1 = &OSEventTbl[ix];
000012  eb040084          ADD      r0,r4,r4,LSL #2
000016  490f              LDR      r1,|L20.84|
000018  eb010380          ADD      r3,r1,r0,LSL #2
;;;1292           pevent2 = &OSEventTbl[ix_next];
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  eb010680          ADD      r6,r1,r0,LSL #2
;;;1293           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000024  2000              MOVS     r0,#0
000026  7018              STRB     r0,[r3,#0]
;;;1294           pevent1->OSEventPtr     = pevent2;
000028  605e              STR      r6,[r3,#4]
;;;1295   #if OS_EVENT_NAME_EN > 0u
;;;1296           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00002a  a00b              ADR      r0,|L20.88|
00002c  6118              STR      r0,[r3,#0x10]
00002e  1c60              ADDS     r0,r4,#1              ;1289
000030  b284              UXTH     r4,r0                 ;1289
                  |L20.50|
000032  2c09              CMP      r4,#9                 ;1289
000034  d3eb              BCC      |L20.14|
;;;1297   #endif
;;;1298       }
;;;1299       pevent1                         = &OSEventTbl[ix];
000036  eb040084          ADD      r0,r4,r4,LSL #2
00003a  4906              LDR      r1,|L20.84|
00003c  eb010380          ADD      r3,r1,r0,LSL #2
;;;1300       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000040  2000              MOVS     r0,#0
000042  7018              STRB     r0,[r3,#0]
;;;1301       pevent1->OSEventPtr             = (OS_EVENT *)0;
000044  6058              STR      r0,[r3,#4]
;;;1302   #if OS_EVENT_NAME_EN > 0u
;;;1303       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
000046  a004              ADR      r0,|L20.88|
000048  6118              STR      r0,[r3,#0x10]
;;;1304   #endif
;;;1305       OSEventFreeList                 = &OSEventTbl[0];
00004a  4608              MOV      r0,r1
00004c  4903              LDR      r1,|L20.92|
00004e  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1306   #else
;;;1307       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1308       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1309       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1310   #if OS_EVENT_NAME_EN > 0u
;;;1311       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1312   #endif
;;;1313   #endif
;;;1314   #endif
;;;1315   }
000050  bd70              POP      {r4-r6,pc}
;;;1316   /*$PAGE*/
                          ENDP

000052  0000              DCW      0x0000
                  |L20.84|
                          DCD      OSEventTbl
                  |L20.88|
000058  3f00              DCB      "?",0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L20.92|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;1329   
;;;1330   static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;1331   {
;;;1332   #if OS_TIME_GET_SET_EN > 0u
;;;1333       OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000002  490a              LDR      r1,|L21.44|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;1334   #endif
;;;1335   
;;;1336       OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000006  490a              LDR      r1,|L21.48|
000008  7008              STRB     r0,[r1,#0]
;;;1337       OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
00000a  490a              LDR      r1,|L21.52|
00000c  7008              STRB     r0,[r1,#0]
;;;1338   
;;;1339       OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
00000e  490a              LDR      r1,|L21.56|
000010  7008              STRB     r0,[r1,#0]
;;;1340   
;;;1341       OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000012  490a              LDR      r1,|L21.60|
000014  7008              STRB     r0,[r1,#0]
;;;1342   
;;;1343       OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000016  490a              LDR      r1,|L21.64|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1344       OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
00001a  490a              LDR      r1,|L21.68|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1345   
;;;1346   #if OS_TASK_STAT_EN > 0u
;;;1347       OSIdleCtrRun              = 0uL;
00001e  490a              LDR      r1,|L21.72|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1348       OSIdleCtrMax              = 0uL;
000022  490a              LDR      r1,|L21.76|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1349       OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000026  490a              LDR      r1,|L21.80|
000028  7008              STRB     r0,[r1,#0]
;;;1350   #endif
;;;1351   
;;;1352   #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;1353       OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
;;;1354   #endif
;;;1355   }
00002a  4770              BX       lr
;;;1356   /*$PAGE*/
                          ENDP

                  |L21.44|
                          DCD      OSTime
                  |L21.48|
                          DCD      OSIntNesting
                  |L21.52|
                          DCD      OSLockNesting
                  |L21.56|
                          DCD      OSTaskCtr
                  |L21.60|
                          DCD      OSRunning
                  |L21.64|
                          DCD      OSCtxSwCtr
                  |L21.68|
                          DCD      OSIdleCtr
                  |L21.72|
                          DCD      OSIdleCtrRun
                  |L21.76|
                          DCD      OSIdleCtrMax
                  |L21.80|
                          DCD      OSStatRdy

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;1369   
;;;1370   static  void  OS_InitRdyList (void)
000000  2100              MOVS     r1,#0
;;;1371   {
;;;1372       INT8U  i;
;;;1373   
;;;1374   
;;;1375       OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000002  4a0a              LDR      r2,|L22.44|
000004  7011              STRB     r1,[r2,#0]
;;;1376       for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e004              B        |L22.20|
                  |L22.10|
;;;1377           OSRdyTbl[i] = 0u;
00000a  2100              MOVS     r1,#0
00000c  4a08              LDR      r2,|L22.48|
00000e  5411              STRB     r1,[r2,r0]
000010  1c41              ADDS     r1,r0,#1              ;1376
000012  b2c8              UXTB     r0,r1                 ;1376
                  |L22.20|
000014  2804              CMP      r0,#4                 ;1376
000016  d3f8              BCC      |L22.10|
;;;1378       }
;;;1379   
;;;1380       OSPrioCur     = 0u;
000018  2100              MOVS     r1,#0
00001a  4a06              LDR      r2,|L22.52|
00001c  7011              STRB     r1,[r2,#0]
;;;1381       OSPrioHighRdy = 0u;
00001e  4a06              LDR      r2,|L22.56|
000020  7011              STRB     r1,[r2,#0]
;;;1382   
;;;1383       OSTCBHighRdy  = (OS_TCB *)0;
000022  4a06              LDR      r2,|L22.60|
000024  6011              STR      r1,[r2,#0]  ; OSTCBHighRdy
;;;1384       OSTCBCur      = (OS_TCB *)0;
000026  4a06              LDR      r2,|L22.64|
000028  6011              STR      r1,[r2,#0]  ; OSTCBCur
;;;1385   }
00002a  4770              BX       lr
;;;1386   
                          ENDP

                  |L22.44|
                          DCD      OSRdyGrp
                  |L22.48|
                          DCD      OSRdyTbl
                  |L22.52|
                          DCD      OSPrioCur
                  |L22.56|
                          DCD      OSPrioHighRdy
                  |L22.60|
                          DCD      OSTCBHighRdy
                  |L22.64|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1524   
;;;1525   static  void  OS_InitTCBList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1526   {
;;;1527       INT8U    ix;
;;;1528       INT8U    ix_next;
;;;1529       OS_TCB  *ptcb1;
;;;1530       OS_TCB  *ptcb2;
;;;1531   
;;;1532   
;;;1533       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f61f2          MOV      r1,#0x790
000006  4818              LDR      r0,|L23.104|
000008  f7fffffe          BL       OS_MemClr
;;;1534       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  2180              MOVS     r1,#0x80
00000e  4817              LDR      r0,|L23.108|
000010  f7fffffe          BL       OS_MemClr
;;;1535       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000014  2400              MOVS     r4,#0
000016  e013              B        |L23.64|
                  |L23.24|
;;;1536           ix_next =  ix + 1u;
000018  1c60              ADDS     r0,r4,#1
00001a  b2c5              UXTB     r5,r0
;;;1537           ptcb1   = &OSTCBTbl[ix];
00001c  eb040044          ADD      r0,r4,r4,LSL #1
000020  eb0000c4          ADD      r0,r0,r4,LSL #3
000024  4910              LDR      r1,|L23.104|
000026  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1538           ptcb2   = &OSTCBTbl[ix_next];
00002a  eb050045          ADD      r0,r5,r5,LSL #1
00002e  eb0000c5          ADD      r0,r0,r5,LSL #3
000032  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;1539           ptcb1->OSTCBNext = ptcb2;
000036  615e              STR      r6,[r3,#0x14]
;;;1540   #if OS_TASK_NAME_EN > 0u
;;;1541           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
000038  a00d              ADR      r0,|L23.112|
00003a  6518              STR      r0,[r3,#0x50]
00003c  1c60              ADDS     r0,r4,#1              ;1535
00003e  b2c4              UXTB     r4,r0                 ;1535
                  |L23.64|
000040  2c15              CMP      r4,#0x15              ;1535
000042  d3e9              BCC      |L23.24|
;;;1542   #endif
;;;1543       }
;;;1544       ptcb1                   = &OSTCBTbl[ix];
000044  eb040044          ADD      r0,r4,r4,LSL #1
000048  eb0000c4          ADD      r0,r0,r4,LSL #3
00004c  4906              LDR      r1,|L23.104|
00004e  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1545       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000052  2000              MOVS     r0,#0
000054  6158              STR      r0,[r3,#0x14]
;;;1546   #if OS_TASK_NAME_EN > 0u
;;;1547       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000056  a006              ADR      r0,|L23.112|
000058  6518              STR      r0,[r3,#0x50]
;;;1548   #endif
;;;1549       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00005a  2000              MOVS     r0,#0
00005c  4905              LDR      r1,|L23.116|
00005e  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1550       OSTCBFreeList           = &OSTCBTbl[0];
000060  4801              LDR      r0,|L23.104|
000062  4905              LDR      r1,|L23.120|
000064  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1551   }
000066  bd70              POP      {r4-r6,pc}
;;;1552   /*$PAGE*/
                          ENDP

                  |L23.104|
                          DCD      OSTCBTbl
                  |L23.108|
                          DCD      OSTCBPrioTbl
                  |L23.112|
000070  3f00              DCB      "?",0
000072  00                DCB      0
000073  00                DCB      0
                  |L23.116|
                          DCD      OSTCBList
                  |L23.120|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;1400   
;;;1401   static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;1402   {
000002  b087              SUB      sp,sp,#0x1c
;;;1403   #if OS_TASK_NAME_EN > 0u
;;;1404       INT8U  err;
;;;1405   #endif
;;;1406   
;;;1407   
;;;1408   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1409       #if OS_STK_GROWTH == 1u
;;;1410       (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L24.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  231f              MOVS     r3,#0x1f
00001a  4a07              LDR      r2,|L24.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L24.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1411                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1412                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
;;;1413                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1414                             OS_TASK_IDLE_ID,
;;;1415                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1416                             OS_TASK_IDLE_STK_SIZE,
;;;1417                             (void *)0,                                 /* No TCB extension                     */
;;;1418                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1419       #else
;;;1420       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1421                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1422                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1423                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1424                             OS_TASK_IDLE_ID,
;;;1425                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
;;;1426                             OS_TASK_IDLE_STK_SIZE,
;;;1427                             (void *)0,                                 /* No TCB extension                     */
;;;1428                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1429       #endif
;;;1430   #else
;;;1431       #if OS_STK_GROWTH == 1u
;;;1432       (void)OSTaskCreate(OS_TaskIdle,
;;;1433                          (void *)0,
;;;1434                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
;;;1435                          OS_TASK_IDLE_PRIO);
;;;1436       #else
;;;1437       (void)OSTaskCreate(OS_TaskIdle,
;;;1438                          (void *)0,
;;;1439                          &OSTaskIdleStk[0],
;;;1440                          OS_TASK_IDLE_PRIO);
;;;1441       #endif
;;;1442   #endif
;;;1443   
;;;1444   #if OS_TASK_NAME_EN > 0u
;;;1445       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L24.64|
000028  201f              MOVS     r0,#0x1f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1446   #endif
;;;1447   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1448   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      OSTaskIdleStk
                  |L24.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L24.60|
                          DCD      OS_TaskIdle
                  |L24.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1462   #if OS_TASK_STAT_EN > 0u
;;;1463   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1464   {
000002  b087              SUB      sp,sp,#0x1c
;;;1465   #if OS_TASK_NAME_EN > 0u
;;;1466       INT8U  err;
;;;1467   #endif
;;;1468   
;;;1469   
;;;1470   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1471       #if OS_STK_GROWTH == 1u
;;;1472       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L25.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  231e              MOVS     r3,#0x1e
00001a  4a07              LDR      r2,|L25.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L25.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1473                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1474                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
;;;1475                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1476                             OS_TASK_STAT_ID,
;;;1477                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1478                             OS_TASK_STAT_STK_SIZE,
;;;1479                             (void *)0,                                   /* No TCB extension               */
;;;1480                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1481       #else
;;;1482       (void)OSTaskCreateExt(OS_TaskStat,
;;;1483                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1484                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1485                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1486                             OS_TASK_STAT_ID,
;;;1487                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
;;;1488                             OS_TASK_STAT_STK_SIZE,
;;;1489                             (void *)0,                                   /* No TCB extension               */
;;;1490                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1491       #endif
;;;1492   #else
;;;1493       #if OS_STK_GROWTH == 1u
;;;1494       (void)OSTaskCreate(OS_TaskStat,
;;;1495                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1496                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
;;;1497                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1498       #else
;;;1499       (void)OSTaskCreate(OS_TaskStat,
;;;1500                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1501                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1502                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1503       #endif
;;;1504   #endif
;;;1505   
;;;1506   #if OS_TASK_NAME_EN > 0u
;;;1507       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L25.64|
000028  201e              MOVS     r0,#0x1e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1508   #endif
;;;1509   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1510   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L25.52|
                          DCD      OSTaskStatStk
                  |L25.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L25.60|
                          DCD      OS_TaskStat
                  |L25.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1572   
;;;1573   void  OS_MemClr (INT8U  *pdest,
000000  e004              B        |L26.12|
                  |L26.2|
;;;1574                    INT16U  size)
;;;1575   {
;;;1576       while (size > 0u) {
;;;1577           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1578           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L26.12|
00000c  2900              CMP      r1,#0                 ;1576
00000e  d1f8              BNE      |L26.2|
;;;1579       }
;;;1580   }
000010  4770              BX       lr
;;;1581   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1605   
;;;1606   void  OS_MemCopy (INT8U  *pdest,
000000  e005              B        |L27.14|
                  |L27.2|
;;;1607                     INT8U  *psrc,
;;;1608                     INT16U  size)
;;;1609   {
;;;1610       while (size > 0u) {
;;;1611           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1612           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L27.14|
00000e  2a00              CMP      r2,#0                 ;1610
000010  d1f7              BNE      |L27.2|
;;;1613       }
;;;1614   }
000012  4770              BX       lr
;;;1615   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1632   
;;;1633   void  OS_Sched (void)
000000  b510              PUSH     {r4,lr}
;;;1634   {
;;;1635   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1636       OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;1637   #endif
;;;1638   
;;;1639   
;;;1640   
;;;1641       OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1642       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00000a  4813              LDR      r0,|L28.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f8              CBNZ     r0,|L28.80|
;;;1643           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000010  4812              LDR      r0,|L28.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9e0              CBNZ     r0,|L28.80|
;;;1644               OS_SchedNew();
000016  f7fffffe          BL       OS_SchedNew
;;;1645               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001a  4811              LDR      r0,|L28.96|
00001c  4911              LDR      r1,|L28.100|
00001e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000020  f8500021          LDR      r0,[r0,r1,LSL #2]
000024  4910              LDR      r1,|L28.104|
000026  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1646               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000028  480e              LDR      r0,|L28.100|
00002a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00002c  490f              LDR      r1,|L28.108|
00002e  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000030  4288              CMP      r0,r1
000032  d00d              BEQ      |L28.80|
;;;1647   #if OS_TASK_PROFILE_EN > 0u
;;;1648                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000034  480c              LDR      r0,|L28.104|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6bc0              LDR      r0,[r0,#0x3c]
00003a  1c40              ADDS     r0,r0,#1
00003c  490a              LDR      r1,|L28.104|
00003e  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000040  63c8              STR      r0,[r1,#0x3c]
;;;1649   #endif
;;;1650                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000042  480b              LDR      r0,|L28.112|
000044  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000046  1c40              ADDS     r0,r0,#1
000048  4909              LDR      r1,|L28.112|
00004a  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1651                   OS_TASK_SW();                          /* Perform a context switch                     */
00004c  f7fffffe          BL       OSCtxSw
                  |L28.80|
;;;1652               }
;;;1653           }
;;;1654       }
;;;1655       OS_EXIT_CRITICAL();
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_CPU_SR_Restore
;;;1656   }
000056  bd10              POP      {r4,pc}
;;;1657   
                          ENDP

                  |L28.88|
                          DCD      OSIntNesting
                  |L28.92|
                          DCD      OSLockNesting
                  |L28.96|
                          DCD      OSTCBPrioTbl
                  |L28.100|
                          DCD      OSPrioHighRdy
                  |L28.104|
                          DCD      OSTCBHighRdy
                  |L28.108|
                          DCD      OSPrioCur
                  |L28.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1674   
;;;1675   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L29.28|
;;;1676   {
;;;1677   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1678       INT8U   y;
;;;1679   
;;;1680   
;;;1681       y             = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L29.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1682       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L29.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L29.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L29.40|
000016  7011              STRB     r1,[r2,#0]
;;;1683   #else                                            /* We support up to 256 tasks                         */
;;;1684       INT8U     y;
;;;1685       OS_PRIO  *ptbl;
;;;1686   
;;;1687   
;;;1688       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1689           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1690       } else {
;;;1691           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1692       }
;;;1693       ptbl = &OSRdyTbl[y];
;;;1694       if ((*ptbl & 0xFFu) != 0u) {
;;;1695           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1696       } else {
;;;1697           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1698       }
;;;1699   #endif
;;;1700   }
000018  4770              BX       lr
;;;1701   
                          ENDP

00001a  0000              DCW      0x0000
                  |L29.28|
                          DCD      OSUnMapTbl
                  |L29.32|
                          DCD      OSRdyGrp
                  |L29.36|
                          DCD      OSRdyTbl
                  |L29.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1719   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1720   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1721   {
;;;1722       INT8U  len;
;;;1723   
;;;1724   
;;;1725   #if OS_ARG_CHK_EN > 0u
;;;1726       if (psrc == (INT8U *)0) {
;;;1727           return (0u);
;;;1728       }
;;;1729   #endif
;;;1730   
;;;1731       len = 0u;
000002  2000              MOVS     r0,#0
;;;1732       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L30.12|
                  |L30.6|
;;;1733           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1734           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L30.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1732
00000e  2a00              CMP      r2,#0                 ;1732
000010  d1f9              BNE      |L30.6|
;;;1735       }
;;;1736       return (len);
;;;1737   }
000012  4770              BX       lr
;;;1738   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1928   
;;;1929   INT8U  OS_TCBInit (INT8U    prio,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1930                      OS_STK  *ptos,
;;;1931                      OS_STK  *pbos,
;;;1932                      INT16U   id,
;;;1933                      INT32U   stk_size,
;;;1934                      void    *pext,
;;;1935                      INT16U   opt)
;;;1936   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1937       OS_TCB    *ptcb;
;;;1938   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1939       OS_CPU_SR  cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1940   #endif
;;;1941   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1942       INT8U      i;
;;;1943   #endif
;;;1944   
;;;1945   
;;;1946       OS_ENTER_CRITICAL();
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  9000              STR      r0,[sp,#0]
;;;1947       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001a  4846              LDR      r0,|L31.308|
00001c  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1948       if (ptcb != (OS_TCB *)0) {
00001e  2c00              CMP      r4,#0
000020  d07d              BEQ      |L31.286|
;;;1949           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000022  f104041c          ADD      r4,r4,#0x1c
000026  f8540c08          LDR      r0,[r4,#-8]
00002a  4942              LDR      r1,|L31.308|
00002c  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1950           OS_EXIT_CRITICAL();
00002e  9800              LDR      r0,[sp,#0]
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;1951           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000034  f8447c1c          STR      r7,[r4,#-0x1c]
;;;1952           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000038  76a5              STRB     r5,[r4,#0x1a]
;;;1953           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00003a  2000              MOVS     r0,#0
00003c  7620              STRB     r0,[r4,#0x18]
;;;1954           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00003e  7660              STRB     r0,[r4,#0x19]
;;;1955           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
000040  6160              STR      r0,[r4,#0x14]
;;;1956   
;;;1957   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1958           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000042  f844bc18          STR      r11,[r4,#-0x18]
;;;1959           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000046  f844ac10          STR      r10,[r4,#-0x10]
;;;1960           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00004a  f8448c14          STR      r8,[r4,#-0x14]
;;;1961           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00004e  980c              LDR      r0,[sp,#0x30]
000050  f8240c0c          STRH     r0,[r4,#-0xc]
;;;1962           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000054  f8249c0a          STRH     r9,[r4,#-0xa]
;;;1963   #else
;;;1964           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1965           stk_size                 = stk_size;
;;;1966           pbos                     = pbos;
;;;1967           opt                      = opt;
;;;1968           id                       = id;
;;;1969   #endif
;;;1970   
;;;1971   #if OS_TASK_DEL_EN > 0u
;;;1972           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000058  2000              MOVS     r0,#0
00005a  77e0              STRB     r0,[r4,#0x1f]
;;;1973   #endif
;;;1974   
;;;1975   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1976           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00005c  10e8              ASRS     r0,r5,#3
00005e  7720              STRB     r0,[r4,#0x1c]
;;;1977           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
000060  f0050007          AND      r0,r5,#7
000064  76e0              STRB     r0,[r4,#0x1b]
;;;1978   #else                                                             /* Pre-compute X, Y                  */
;;;1979           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1980           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1981   #endif
;;;1982                                                                     /* Pre-compute BitX and BitY         */
;;;1983           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000066  7f21              LDRB     r1,[r4,#0x1c]
000068  2001              MOVS     r0,#1
00006a  4088              LSLS     r0,r0,r1
00006c  77a0              STRB     r0,[r4,#0x1e]
;;;1984           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00006e  7ee1              LDRB     r1,[r4,#0x1b]
000070  2001              MOVS     r0,#1
000072  4088              LSLS     r0,r0,r1
000074  7760              STRB     r0,[r4,#0x1d]
;;;1985   
;;;1986   #if (OS_EVENT_EN)
;;;1987           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000076  2000              MOVS     r0,#0
000078  6020              STR      r0,[r4,#0]
;;;1988   #if (OS_EVENT_MULTI_EN > 0u)
;;;1989           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
00007a  6060              STR      r0,[r4,#4]
;;;1990   #endif
;;;1991   #endif
;;;1992   
;;;1993   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;1994           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00007c  60e0              STR      r0,[r4,#0xc]
;;;1995   #endif
;;;1996   
;;;1997   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;1998           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00007e  60a0              STR      r0,[r4,#8]
;;;1999   #endif
;;;2000   
;;;2001   #if OS_TASK_PROFILE_EN > 0u
;;;2002           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000080  6220              STR      r0,[r4,#0x20]
;;;2003           ptcb->OSTCBCyclesStart = 0uL;
000082  62a0              STR      r0,[r4,#0x28]
;;;2004           ptcb->OSTCBCyclesTot   = 0uL;
000084  6260              STR      r0,[r4,#0x24]
;;;2005           ptcb->OSTCBStkBase     = (OS_STK *)0;
000086  62e0              STR      r0,[r4,#0x2c]
;;;2006           ptcb->OSTCBStkUsed     = 0uL;
000088  6320              STR      r0,[r4,#0x30]
;;;2007   #endif
;;;2008   
;;;2009   #if OS_TASK_NAME_EN > 0u
;;;2010           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
00008a  a02b              ADR      r0,|L31.312|
00008c  6360              STR      r0,[r4,#0x34]
00008e  f1a4041c          SUB      r4,r4,#0x1c
;;;2011   #endif
;;;2012   
;;;2013   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2014           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
000092  f04f0600          MOV      r6,#0
000096  e006              B        |L31.166|
                  |L31.152|
;;;2015               ptcb->OSTCBRegTbl[i] = 0u;
000098  2100              MOVS     r1,#0
00009a  f1040054          ADD      r0,r4,#0x54
00009e  f8401026          STR      r1,[r0,r6,LSL #2]
0000a2  1c70              ADDS     r0,r6,#1              ;2014
0000a4  b2c6              UXTB     r6,r0                 ;2014
                  |L31.166|
0000a6  2e01              CMP      r6,#1                 ;2014
0000a8  dbf6              BLT      |L31.152|
;;;2016           }
;;;2017   #endif
;;;2018   
;;;2019           OSTCBInitHook(ptcb);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       OSTCBInitHook
;;;2020   
;;;2021           OS_ENTER_CRITICAL();
0000b0  f7fffffe          BL       OS_CPU_SR_Save
0000b4  9000              STR      r0,[sp,#0]
;;;2022           OSTCBPrioTbl[prio] = ptcb;
0000b6  4821              LDR      r0,|L31.316|
0000b8  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2023           OS_EXIT_CRITICAL();
0000bc  9800              LDR      r0,[sp,#0]
0000be  f7fffffe          BL       OS_CPU_SR_Restore
;;;2024   
;;;2025           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       OSTaskCreateHook
;;;2026   
;;;2027           OS_ENTER_CRITICAL();
0000c8  f7fffffe          BL       OS_CPU_SR_Save
0000cc  9000              STR      r0,[sp,#0]
;;;2028           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000ce  481c              LDR      r0,|L31.320|
0000d0  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000d2  6160              STR      r0,[r4,#0x14]
;;;2029           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000d4  2000              MOVS     r0,#0
0000d6  61a0              STR      r0,[r4,#0x18]
;;;2030           if (OSTCBList != (OS_TCB *)0) {
0000d8  4819              LDR      r0,|L31.320|
0000da  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000dc  b110              CBZ      r0,|L31.228|
;;;2031               OSTCBList->OSTCBPrev = ptcb;
0000de  4818              LDR      r0,|L31.320|
0000e0  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000e2  6184              STR      r4,[r0,#0x18]
                  |L31.228|
;;;2032           }
;;;2033           OSTCBList               = ptcb;
0000e4  4816              LDR      r0,|L31.320|
0000e6  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2034           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000e8  f1040438          ADD      r4,r4,#0x38
0000ec  78a0              LDRB     r0,[r4,#2]
0000ee  4915              LDR      r1,|L31.324|
0000f0  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000f2  ea400001          ORR      r0,r0,r1
0000f6  4913              LDR      r1,|L31.324|
0000f8  7008              STRB     r0,[r1,#0]
;;;2035           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000fa  7820              LDRB     r0,[r4,#0]
0000fc  4912              LDR      r1,|L31.328|
0000fe  5c08              LDRB     r0,[r1,r0]
000100  7861              LDRB     r1,[r4,#1]
000102  ea400001          ORR      r0,r0,r1
000106  f8141938          LDRB     r1,[r4],#-0x38
00010a  4a0f              LDR      r2,|L31.328|
00010c  5450              STRB     r0,[r2,r1]
;;;2036           OSTaskCtr++;                                       /* Increment the #tasks counter             */
00010e  480f              LDR      r0,|L31.332|
000110  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
000112  f1000001          ADD      r0,r0,#1
000116  490d              LDR      r1,|L31.332|
000118  7008              STRB     r0,[r1,#0]
;;;2037           OS_EXIT_CRITICAL();
00011a  9800              LDR      r0,[sp,#0]
00011c  e000              B        |L31.288|
                  |L31.286|
00011e  e004              B        |L31.298|
                  |L31.288|
000120  f7fffffe          BL       OS_CPU_SR_Restore
;;;2038           return (OS_ERR_NONE);
000124  2000              MOVS     r0,#0
                  |L31.294|
;;;2039       }
;;;2040       OS_EXIT_CRITICAL();
;;;2041       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2042   }
000126  e8bd8ff8          POP      {r3-r11,pc}
                  |L31.298|
00012a  9800              LDR      r0,[sp,#0]            ;2040
00012c  f7fffffe          BL       OS_CPU_SR_Restore
000130  2042              MOVS     r0,#0x42              ;2041
000132  e7f8              B        |L31.294|
                          ENDP

                  |L31.308|
                          DCD      OSTCBFreeList
                  |L31.312|
000138  3f00              DCB      "?",0
00013a  00                DCB      0
00013b  00                DCB      0
                  |L31.316|
                          DCD      OSTCBPrioTbl
                  |L31.320|
                          DCD      OSTCBList
                  |L31.324|
                          DCD      OSRdyGrp
                  |L31.328|
                          DCD      OSRdyTbl
                  |L31.332|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1760   
;;;1761   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1762   {
;;;1763   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1764       OS_CPU_SR  cpu_sr = 0u;
;;;1765   #endif
;;;1766   
;;;1767   
;;;1768   
;;;1769       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1770       for (;;) {
000004  bf00              NOP      
                  |L32.6|
;;;1771           OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4604              MOV      r4,r0
;;;1772           OSIdleCtr++;
00000c  4805              LDR      r0,|L32.36|
00000e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000010  1c40              ADDS     r0,r0,#1
000012  4904              LDR      r1,|L32.36|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1773           OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;1774           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001c  f7fffffe          BL       OSTaskIdleHook
000020  e7f1              B        |L32.6|
;;;1775       }
;;;1776   }
;;;1777   /*$PAGE*/
                          ENDP

000022  0000              DCW      0x0000
                  |L32.36|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1802   #if OS_TASK_STAT_EN > 0u
;;;1803   void  OS_TaskStat (void *p_arg)
000000  bf00              NOP      
;;;1804   {
;;;1805   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1806       OS_CPU_SR  cpu_sr = 0u;
;;;1807   #endif
;;;1808   
;;;1809   
;;;1810   
;;;1811       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1812       while (OSStatRdy == OS_FALSE) {
000004  e002              B        |L33.12|
                  |L33.6|
;;;1813           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000006  20c8              MOVS     r0,#0xc8
000008  f7fffffe          BL       OSTimeDly
                  |L33.12|
00000c  481f              LDR      r0,|L33.140|
00000e  7800              LDRB     r0,[r0,#0]            ;1812  ; OSStatRdy
000010  2800              CMP      r0,#0                 ;1812
000012  d0f8              BEQ      |L33.6|
;;;1814       }
;;;1815       OSIdleCtrMax /= 100uL;
000014  481e              LDR      r0,|L33.144|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000018  2164              MOVS     r1,#0x64
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  491c              LDR      r1,|L33.144|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1816       if (OSIdleCtrMax == 0uL) {
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000026  b928              CBNZ     r0,|L33.52|
;;;1817           OSCPUUsage = 0u;
000028  2000              MOVS     r0,#0
00002a  491a              LDR      r1,|L33.148|
00002c  7008              STRB     r0,[r1,#0]
;;;1818   #if OS_TASK_SUSPEND_EN > 0u
;;;1819           (void)OSTaskSuspend(OS_PRIO_SELF);
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       OSTaskSuspend
                  |L33.52|
;;;1820   #else
;;;1821           for (;;) {
;;;1822               OSTimeDly(OS_TICKS_PER_SEC);
;;;1823           }
;;;1824   #endif
;;;1825       }
;;;1826       OS_ENTER_CRITICAL();
000034  f7fffffe          BL       OS_CPU_SR_Save
000038  4604              MOV      r4,r0
;;;1827       OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
00003a  4815              LDR      r0,|L33.144|
00003c  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
00003e  2164              MOVS     r1,#0x64
000040  4348              MULS     r0,r1,r0
000042  4915              LDR      r1,|L33.152|
000044  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1828       OS_EXIT_CRITICAL();
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_CPU_SR_Restore
;;;1829       for (;;) {
00004c  bf00              NOP      
                  |L33.78|
;;;1830           OS_ENTER_CRITICAL();
00004e  f7fffffe          BL       OS_CPU_SR_Save
000052  4604              MOV      r4,r0
;;;1831           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
000054  4810              LDR      r0,|L33.152|
000056  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000058  4910              LDR      r1,|L33.156|
00005a  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1832           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00005c  2000              MOVS     r0,#0
00005e  490e              LDR      r1,|L33.152|
000060  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1833           OS_EXIT_CRITICAL();
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       OS_CPU_SR_Restore
;;;1834           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
000068  480c              LDR      r0,|L33.156|
00006a  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
00006c  4908              LDR      r1,|L33.144|
00006e  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000070  fbb0f0f1          UDIV     r0,r0,r1
000074  f1c00064          RSB      r0,r0,#0x64
000078  4906              LDR      r1,|L33.148|
00007a  7008              STRB     r0,[r1,#0]
;;;1835           OSTaskStatHook();                        /* Invoke user definable hook                         */
00007c  f7fffffe          BL       OSTaskStatHook
;;;1836   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1837           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000080  f7fffffe          BL       OS_TaskStatStkChk
;;;1838   #endif
;;;1839           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
000084  2064              MOVS     r0,#0x64
000086  f7fffffe          BL       OSTimeDly
00008a  e7e0              B        |L33.78|
;;;1840       }
;;;1841   }
;;;1842   #endif
                          ENDP

                  |L33.140|
                          DCD      OSStatRdy
                  |L33.144|
                          DCD      OSIdleCtrMax
                  |L33.148|
                          DCD      OSCPUUsage
                  |L33.152|
                          DCD      OSIdleCtr
                  |L33.156|
                          DCD      OSIdleCtrRun

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1856   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1857   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1858   {
;;;1859       OS_TCB      *ptcb;
;;;1860       OS_STK_DATA  stk_data;
;;;1861       INT8U        err;
;;;1862       INT8U        prio;
;;;1863   
;;;1864   
;;;1865       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L34.48|
                  |L34.6|
;;;1866           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1867           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L34.44|
;;;1868               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L34.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1869               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L34.44|
;;;1870                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L34.44|
;;;1871   #if OS_TASK_PROFILE_EN > 0u
;;;1872                       #if OS_STK_GROWTH == 1u
;;;1873                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  64a0              STR      r0,[r4,#0x48]
;;;1874                       #else
;;;1875                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1876                       #endif
;;;1877                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000028  9801              LDR      r0,[sp,#4]
00002a  64e0              STR      r0,[r4,#0x4c]
                  |L34.44|
00002c  1c68              ADDS     r0,r5,#1              ;1865
00002e  b2c5              UXTB     r5,r0                 ;1865
                  |L34.48|
000030  2d1f              CMP      r5,#0x1f              ;1865
000032  dde8              BLE      |L34.6|
;;;1878   #endif
;;;1879                   }
;;;1880               }
;;;1881           }
;;;1882       }
;;;1883   }
000034  bd7c              POP      {r2-r6,pc}
;;;1884   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L34.56|
                          DCD      OSTCBPrioTbl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        200
                  OSFlagTbl
                          %        80
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        1936
                  OSMemTbl
                          %        120
                  OSQTbl
                          %        24
                  OSTmrTbl
                          %        640
                  OSTmrTaskStk
                          %        512
                  OSTmrWheelTbl
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
000020  0000              DCB      0x00,0x00
                  OSRunning
000022  00                DCB      0x00
                  OSTaskCtr
000023  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
                  OSTmrFree
000048  0000              DCB      0x00,0x00
                  OSTmrUsed
00004a  0000              DCB      0x00,0x00
                  OSTmrTime
                          DCD      0x00000000
                  OSTmrSem
                          DCD      0x00000000
                  OSTmrSemSignal
                          DCD      0x00000000
                  OSTmrFreeList
                          DCD      0x00000000
