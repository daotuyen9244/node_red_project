; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdmerge.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdmerge.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jdmerge.c]
                          THUMB

                          AREA ||i.build_ycc_rgb_table||, CODE, READONLY, ALIGN=2

                  build_ycc_rgb_table PROC
;;;82     LOCAL(void)
;;;83     build_ycc_rgb_table (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4605              MOV      r5,r0
;;;85       my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
000006  f8d541c4          LDR      r4,[r5,#0x1c4]
;;;86       int i;
;;;87       INT32 x;
;;;88       SHIFT_TEMPS
;;;89     
;;;90       upsample->Cr_r_tab = (int *)
00000a  6868              LDR      r0,[r5,#4]
00000c  f44f6280          MOV      r2,#0x400
000010  2101              MOVS     r1,#1
000012  6803              LDR      r3,[r0,#0]
000014  4628              MOV      r0,r5
000016  4798              BLX      r3
000018  6120              STR      r0,[r4,#0x10]
;;;91         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;92     				(MAXJSAMPLE+1) * SIZEOF(int));
;;;93       upsample->Cb_b_tab = (int *)
00001a  6868              LDR      r0,[r5,#4]
00001c  f44f6280          MOV      r2,#0x400
000020  2101              MOVS     r1,#1
000022  6803              LDR      r3,[r0,#0]
000024  4628              MOV      r0,r5
000026  4798              BLX      r3
000028  6160              STR      r0,[r4,#0x14]
;;;94         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;95     				(MAXJSAMPLE+1) * SIZEOF(int));
;;;96       upsample->Cr_g_tab = (INT32 *)
00002a  6868              LDR      r0,[r5,#4]
00002c  f44f6280          MOV      r2,#0x400
000030  2101              MOVS     r1,#1
000032  6803              LDR      r3,[r0,#0]
000034  4628              MOV      r0,r5
000036  4798              BLX      r3
000038  61a0              STR      r0,[r4,#0x18]
;;;97         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;98     				(MAXJSAMPLE+1) * SIZEOF(INT32));
;;;99       upsample->Cb_g_tab = (INT32 *)
00003a  6868              LDR      r0,[r5,#4]
00003c  f44f6280          MOV      r2,#0x400
000040  2101              MOVS     r1,#1
000042  6803              LDR      r3,[r0,#0]
000044  4628              MOV      r0,r5
000046  4798              BLX      r3
000048  61e0              STR      r0,[r4,#0x1c]
;;;100        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;101    				(MAXJSAMPLE+1) * SIZEOF(INT32));
;;;102    
;;;103      for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
00004a  2600              MOVS     r6,#0
00004c  f06f077f          MVN      r7,#0x7f
000050  e020              B        |L1.148|
                  |L1.82|
;;;104        /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
;;;105        /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
;;;106        /* Cr=>R value is nearest int to 1.40200 * x */
;;;107        upsample->Cr_r_tab[i] = (int)
000052  4912              LDR      r1,|L1.156|
000054  fb07f001          MUL      r0,r7,r1
000058  f5004000          ADD      r0,r0,#0x8000
00005c  1400              ASRS     r0,r0,#16
00005e  6921              LDR      r1,[r4,#0x10]
000060  f8410026          STR      r0,[r1,r6,LSL #2]
;;;108    		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
;;;109        /* Cb=>B value is nearest int to 1.77200 * x */
;;;110        upsample->Cb_b_tab[i] = (int)
000064  490e              LDR      r1,|L1.160|
000066  fb07f001          MUL      r0,r7,r1
00006a  f5004000          ADD      r0,r0,#0x8000
00006e  1400              ASRS     r0,r0,#16
000070  6961              LDR      r1,[r4,#0x14]
000072  f8410026          STR      r0,[r1,r6,LSL #2]
;;;111    		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
;;;112        /* Cr=>G value is scaled-up -0.71414 * x */
;;;113        upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
000076  480b              LDR      r0,|L1.164|
000078  4378              MULS     r0,r7,r0
00007a  69a1              LDR      r1,[r4,#0x18]
00007c  f8410026          STR      r0,[r1,r6,LSL #2]
;;;114        /* Cb=>G value is scaled-up -0.34414 * x */
;;;115        /* We also add in ONE_HALF so that need not do it in inner loop */
;;;116        upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
000080  4909              LDR      r1,|L1.168|
000082  fb07f001          MUL      r0,r7,r1
000086  f5004000          ADD      r0,r0,#0x8000
00008a  69e1              LDR      r1,[r4,#0x1c]
00008c  f8410026          STR      r0,[r1,r6,LSL #2]
000090  1c76              ADDS     r6,r6,#1              ;103
000092  1c7f              ADDS     r7,r7,#1              ;103
                  |L1.148|
000094  2eff              CMP      r6,#0xff              ;103
000096  dddc              BLE      |L1.82|
;;;117      }
;;;118    }
000098  e8bd81f0          POP      {r4-r8,pc}
;;;119    
                          ENDP

                  |L1.156|
                          DCD      0x000166e9
                  |L1.160|
                          DCD      0x0001c5a2
                  |L1.164|
                          DCD      0xffff492e
                  |L1.168|
                          DCD      0xffffa7e6

                          AREA ||i.h2v1_merged_upsample||, CODE, READONLY, ALIGN=1

                  h2v1_merged_upsample PROC
;;;228    METHODDEF(void)
;;;229    h2v1_merged_upsample (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;230    		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
;;;231    		      JSAMPARRAY output_buf)
;;;232    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
;;;233      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
00000a  f8d4c1c4          LDR      r12,[r4,#0x1c4]
;;;234      register int y, cred, cgreen, cblue;
;;;235      int cb, cr;
;;;236      register JSAMPROW outptr;
;;;237      JSAMPROW inptr0, inptr1, inptr2;
;;;238      JDIMENSION col;
;;;239      /* copy these pointers into registers if possible */
;;;240      register JSAMPLE * range_limit = cinfo->sample_range_limit;
00000e  f8d42144          LDR      r2,[r4,#0x144]
;;;241      int * Crrtab = upsample->Cr_r_tab;
000012  f8dcb010          LDR      r11,[r12,#0x10]
000016  f8cdb00c          STR      r11,[sp,#0xc]
;;;242      int * Cbbtab = upsample->Cb_b_tab;
00001a  f8dcb014          LDR      r11,[r12,#0x14]
00001e  f8cdb008          STR      r11,[sp,#8]
;;;243      INT32 * Crgtab = upsample->Cr_g_tab;
000022  f8dcb018          LDR      r11,[r12,#0x18]
000026  f8cdb004          STR      r11,[sp,#4]
;;;244      INT32 * Cbgtab = upsample->Cb_g_tab;
00002a  f8dcb01c          LDR      r11,[r12,#0x1c]
00002e  f8cdb000          STR      r11,[sp,#0]
;;;245      SHIFT_TEMPS
;;;246    
;;;247      inptr0 = input_buf[0][in_row_group_ctr];
000032  f8ddb020          LDR      r11,[sp,#0x20]
000036  f8dbb000          LDR      r11,[r11,#0]
00003a  f85b6027          LDR      r6,[r11,r7,LSL #2]
;;;248      inptr1 = input_buf[1][in_row_group_ctr];
00003e  f8ddb020          LDR      r11,[sp,#0x20]
000042  f8dbb004          LDR      r11,[r11,#4]
000046  f85bb027          LDR      r11,[r11,r7,LSL #2]
00004a  f8cdb018          STR      r11,[sp,#0x18]
;;;249      inptr2 = input_buf[2][in_row_group_ctr];
00004e  f8ddb020          LDR      r11,[sp,#0x20]
000052  f8dbb008          LDR      r11,[r11,#8]
000056  f85bb027          LDR      r11,[r11,r7,LSL #2]
00005a  f8cdb014          STR      r11,[sp,#0x14]
;;;250      outptr = output_buf[0];
00005e  f8ddb028          LDR      r11,[sp,#0x28]
000062  f8db0000          LDR      r0,[r11,#0]
;;;251      /* Loop for each pair of output pixels */
;;;252      for (col = cinfo->output_width >> 1; col > 0; col--) {
000066  f8d4b070          LDR      r11,[r4,#0x70]
00006a  ea4f0b5b          LSR      r11,r11,#1
00006e  f8cdb010          STR      r11,[sp,#0x10]
000072  e04e              B        |L2.274|
                  |L2.116|
;;;253        /* Do the chroma part of the calculation */
;;;254        cb = GETJSAMPLE(*inptr1++);
000074  f8ddb018          LDR      r11,[sp,#0x18]
000078  f81b3b01          LDRB     r3,[r11],#1
00007c  f8cdb018          STR      r11,[sp,#0x18]
;;;255        cr = GETJSAMPLE(*inptr2++);
000080  f8ddb014          LDR      r11,[sp,#0x14]
000084  f81b5b01          LDRB     r5,[r11],#1
000088  f8cdb014          STR      r11,[sp,#0x14]
;;;256        cred = Crrtab[cr];
00008c  f8ddb00c          LDR      r11,[sp,#0xc]
000090  f85b8025          LDR      r8,[r11,r5,LSL #2]
;;;257        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
000094  f8ddb000          LDR      r11,[sp,#0]
000098  f85be023          LDR      lr,[r11,r3,LSL #2]
00009c  f8ddb004          LDR      r11,[sp,#4]
0000a0  f85bb025          LDR      r11,[r11,r5,LSL #2]
0000a4  44f3              ADD      r11,r11,lr
0000a6  ea4f492b          ASR      r9,r11,#16
;;;258        cblue = Cbbtab[cb];
0000aa  f8ddb008          LDR      r11,[sp,#8]
0000ae  f85ba023          LDR      r10,[r11,r3,LSL #2]
;;;259        /* Fetch 2 Y values and emit 2 pixels */
;;;260        y  = GETJSAMPLE(*inptr0++);
0000b2  f8161b01          LDRB     r1,[r6],#1
;;;261        outptr[RGB_RED] =   range_limit[y + cred];
0000b6  eb010b08          ADD      r11,r1,r8
0000ba  f812b00b          LDRB     r11,[r2,r11]
0000be  f880b000          STRB     r11,[r0,#0]
;;;262        outptr[RGB_GREEN] = range_limit[y + cgreen];
0000c2  eb010b09          ADD      r11,r1,r9
0000c6  f812b00b          LDRB     r11,[r2,r11]
0000ca  f880b001          STRB     r11,[r0,#1]
;;;263        outptr[RGB_BLUE] =  range_limit[y + cblue];
0000ce  eb010b0a          ADD      r11,r1,r10
0000d2  f812b00b          LDRB     r11,[r2,r11]
0000d6  f880b002          STRB     r11,[r0,#2]
;;;264        outptr += RGB_PIXELSIZE;
0000da  1cc0              ADDS     r0,r0,#3
;;;265        y  = GETJSAMPLE(*inptr0++);
0000dc  f8161b01          LDRB     r1,[r6],#1
;;;266        outptr[RGB_RED] =   range_limit[y + cred];
0000e0  eb010b08          ADD      r11,r1,r8
0000e4  f812b00b          LDRB     r11,[r2,r11]
0000e8  f880b000          STRB     r11,[r0,#0]
;;;267        outptr[RGB_GREEN] = range_limit[y + cgreen];
0000ec  eb010b09          ADD      r11,r1,r9
0000f0  f812b00b          LDRB     r11,[r2,r11]
0000f4  f880b001          STRB     r11,[r0,#1]
;;;268        outptr[RGB_BLUE] =  range_limit[y + cblue];
0000f8  eb010b0a          ADD      r11,r1,r10
0000fc  f812b00b          LDRB     r11,[r2,r11]
000100  f880b002          STRB     r11,[r0,#2]
;;;269        outptr += RGB_PIXELSIZE;
000104  1cc0              ADDS     r0,r0,#3
000106  f8ddb010          LDR      r11,[sp,#0x10]        ;252
00010a  f1ab0b01          SUB      r11,r11,#1            ;252
00010e  f8cdb010          STR      r11,[sp,#0x10]        ;252
                  |L2.274|
000112  f8ddb010          LDR      r11,[sp,#0x10]        ;252
000116  f1bb0f00          CMP      r11,#0                ;252
00011a  d1ab              BNE      |L2.116|
;;;270      }
;;;271      /* If image width is odd, do the last output column separately */
;;;272      if (cinfo->output_width & 1) {
00011c  f894b070          LDRB     r11,[r4,#0x70]
000120  f01b0f01          TST      r11,#1
000124  d02d              BEQ      |L2.386|
;;;273        cb = GETJSAMPLE(*inptr1);
000126  f8ddb018          LDR      r11,[sp,#0x18]
00012a  f89b3000          LDRB     r3,[r11,#0]
;;;274        cr = GETJSAMPLE(*inptr2);
00012e  f8ddb014          LDR      r11,[sp,#0x14]
000132  f89b5000          LDRB     r5,[r11,#0]
;;;275        cred = Crrtab[cr];
000136  f8ddb00c          LDR      r11,[sp,#0xc]
00013a  f85b8025          LDR      r8,[r11,r5,LSL #2]
;;;276        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
00013e  f8ddb000          LDR      r11,[sp,#0]
000142  f85be023          LDR      lr,[r11,r3,LSL #2]
000146  f8ddb004          LDR      r11,[sp,#4]
00014a  f85bb025          LDR      r11,[r11,r5,LSL #2]
00014e  44f3              ADD      r11,r11,lr
000150  ea4f492b          ASR      r9,r11,#16
;;;277        cblue = Cbbtab[cb];
000154  f8ddb008          LDR      r11,[sp,#8]
000158  f85ba023          LDR      r10,[r11,r3,LSL #2]
;;;278        y  = GETJSAMPLE(*inptr0);
00015c  7831              LDRB     r1,[r6,#0]
;;;279        outptr[RGB_RED] =   range_limit[y + cred];
00015e  eb010b08          ADD      r11,r1,r8
000162  f812b00b          LDRB     r11,[r2,r11]
000166  f880b000          STRB     r11,[r0,#0]
;;;280        outptr[RGB_GREEN] = range_limit[y + cgreen];
00016a  eb010b09          ADD      r11,r1,r9
00016e  f812b00b          LDRB     r11,[r2,r11]
000172  f880b001          STRB     r11,[r0,#1]
;;;281        outptr[RGB_BLUE] =  range_limit[y + cblue];
000176  eb010b0a          ADD      r11,r1,r10
00017a  f812b00b          LDRB     r11,[r2,r11]
00017e  f880b002          STRB     r11,[r0,#2]
                  |L2.386|
;;;282      }
;;;283    }
000182  b00b              ADD      sp,sp,#0x2c
000184  e8bd8ff0          POP      {r4-r11,pc}
;;;284    
                          ENDP


                          AREA ||i.h2v2_merged_upsample||, CODE, READONLY, ALIGN=1

                  h2v2_merged_upsample PROC
;;;290    METHODDEF(void)
;;;291    h2v2_merged_upsample (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;292    		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
;;;293    		      JSAMPARRAY output_buf)
;;;294    {
000004  b088              SUB      sp,sp,#0x20
000006  4617              MOV      r7,r2
;;;295      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
000008  f8ddb020          LDR      r11,[sp,#0x20]
00000c  f8dbb1c4          LDR      r11,[r11,#0x1c4]
000010  f8cdb01c          STR      r11,[sp,#0x1c]
;;;296      register int y, cred, cgreen, cblue;
;;;297      int cb, cr;
;;;298      register JSAMPROW outptr0, outptr1;
;;;299      JSAMPROW inptr00, inptr01, inptr1, inptr2;
;;;300      JDIMENSION col;
;;;301      /* copy these pointers into registers if possible */
;;;302      register JSAMPLE * range_limit = cinfo->sample_range_limit;
000014  f8ddb020          LDR      r11,[sp,#0x20]
000018  f8db1144          LDR      r1,[r11,#0x144]
;;;303      int * Crrtab = upsample->Cr_r_tab;
00001c  f8ddb01c          LDR      r11,[sp,#0x1c]
000020  f8dbb010          LDR      r11,[r11,#0x10]
000024  f8cdb00c          STR      r11,[sp,#0xc]
;;;304      int * Cbbtab = upsample->Cb_b_tab;
000028  f8ddb01c          LDR      r11,[sp,#0x1c]
00002c  f8dbb014          LDR      r11,[r11,#0x14]
000030  f8cdb008          STR      r11,[sp,#8]
;;;305      INT32 * Crgtab = upsample->Cr_g_tab;
000034  f8ddb01c          LDR      r11,[sp,#0x1c]
000038  f8dbb018          LDR      r11,[r11,#0x18]
00003c  f8cdb004          STR      r11,[sp,#4]
;;;306      INT32 * Cbgtab = upsample->Cb_g_tab;
000040  f8ddb01c          LDR      r11,[sp,#0x1c]
000044  f8dbb01c          LDR      r11,[r11,#0x1c]
000048  f8cdb000          STR      r11,[sp,#0]
;;;307      SHIFT_TEMPS
;;;308    
;;;309      inptr00 = input_buf[0][in_row_group_ctr*2];
00004c  f8ddb024          LDR      r11,[sp,#0x24]
000050  f8dbb000          LDR      r11,[r11,#0]
000054  ea4f0e47          LSL      lr,r7,#1
000058  f85b902e          LDR      r9,[r11,lr,LSL #2]
;;;310      inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
00005c  f8ddb024          LDR      r11,[sp,#0x24]
000060  f8dbb000          LDR      r11,[r11,#0]
000064  f04f0e01          MOV      lr,#1
000068  eb0e0e47          ADD      lr,lr,r7,LSL #1
00006c  f85ba02e          LDR      r10,[r11,lr,LSL #2]
;;;311      inptr1 = input_buf[1][in_row_group_ctr];
000070  f8ddb024          LDR      r11,[sp,#0x24]
000074  f8dbb004          LDR      r11,[r11,#4]
000078  f85bb027          LDR      r11,[r11,r7,LSL #2]
00007c  f8cdb018          STR      r11,[sp,#0x18]
;;;312      inptr2 = input_buf[2][in_row_group_ctr];
000080  f8ddb024          LDR      r11,[sp,#0x24]
000084  f8dbb008          LDR      r11,[r11,#8]
000088  f85bb027          LDR      r11,[r11,r7,LSL #2]
00008c  f8cdb014          STR      r11,[sp,#0x14]
;;;313      outptr0 = output_buf[0];
000090  f8ddb02c          LDR      r11,[sp,#0x2c]
000094  f8db2000          LDR      r2,[r11,#0]
;;;314      outptr1 = output_buf[1];
000098  f8ddb02c          LDR      r11,[sp,#0x2c]
00009c  f8db3004          LDR      r3,[r11,#4]
;;;315      /* Loop for each group of output pixels */
;;;316      for (col = cinfo->output_width >> 1; col > 0; col--) {
0000a0  f8ddb020          LDR      r11,[sp,#0x20]
0000a4  f8dbb070          LDR      r11,[r11,#0x70]
0000a8  ea4f0b5b          LSR      r11,r11,#1
0000ac  f8cdb010          STR      r11,[sp,#0x10]
0000b0  e078              B        |L3.420|
                  |L3.178|
;;;317        /* Do the chroma part of the calculation */
;;;318        cb = GETJSAMPLE(*inptr1++);
0000b2  f8ddb018          LDR      r11,[sp,#0x18]
0000b6  f81bcb01          LDRB     r12,[r11],#1
0000ba  f8cdb018          STR      r11,[sp,#0x18]
;;;319        cr = GETJSAMPLE(*inptr2++);
0000be  f8ddb014          LDR      r11,[sp,#0x14]
0000c2  f81b8b01          LDRB     r8,[r11],#1
0000c6  f8cdb014          STR      r11,[sp,#0x14]
;;;320        cred = Crrtab[cr];
0000ca  f8ddb00c          LDR      r11,[sp,#0xc]
0000ce  f85b4028          LDR      r4,[r11,r8,LSL #2]
;;;321        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
0000d2  f8ddb000          LDR      r11,[sp,#0]
0000d6  f85be02c          LDR      lr,[r11,r12,LSL #2]
0000da  f8ddb004          LDR      r11,[sp,#4]
0000de  f85bb028          LDR      r11,[r11,r8,LSL #2]
0000e2  44f3              ADD      r11,r11,lr
0000e4  ea4f452b          ASR      r5,r11,#16
;;;322        cblue = Cbbtab[cb];
0000e8  f8ddb008          LDR      r11,[sp,#8]
0000ec  f85b602c          LDR      r6,[r11,r12,LSL #2]
;;;323        /* Fetch 4 Y values and emit 4 pixels */
;;;324        y  = GETJSAMPLE(*inptr00++);
0000f0  f8190b01          LDRB     r0,[r9],#1
;;;325        outptr0[RGB_RED] =   range_limit[y + cred];
0000f4  eb000b04          ADD      r11,r0,r4
0000f8  f811b00b          LDRB     r11,[r1,r11]
0000fc  f882b000          STRB     r11,[r2,#0]
;;;326        outptr0[RGB_GREEN] = range_limit[y + cgreen];
000100  eb000b05          ADD      r11,r0,r5
000104  f811b00b          LDRB     r11,[r1,r11]
000108  f882b001          STRB     r11,[r2,#1]
;;;327        outptr0[RGB_BLUE] =  range_limit[y + cblue];
00010c  eb000b06          ADD      r11,r0,r6
000110  f811b00b          LDRB     r11,[r1,r11]
000114  f882b002          STRB     r11,[r2,#2]
;;;328        outptr0 += RGB_PIXELSIZE;
000118  1cd2              ADDS     r2,r2,#3
;;;329        y  = GETJSAMPLE(*inptr00++);
00011a  f8190b01          LDRB     r0,[r9],#1
;;;330        outptr0[RGB_RED] =   range_limit[y + cred];
00011e  eb000b04          ADD      r11,r0,r4
000122  f811b00b          LDRB     r11,[r1,r11]
000126  f882b000          STRB     r11,[r2,#0]
;;;331        outptr0[RGB_GREEN] = range_limit[y + cgreen];
00012a  eb000b05          ADD      r11,r0,r5
00012e  f811b00b          LDRB     r11,[r1,r11]
000132  f882b001          STRB     r11,[r2,#1]
;;;332        outptr0[RGB_BLUE] =  range_limit[y + cblue];
000136  eb000b06          ADD      r11,r0,r6
00013a  f811b00b          LDRB     r11,[r1,r11]
00013e  f882b002          STRB     r11,[r2,#2]
;;;333        outptr0 += RGB_PIXELSIZE;
000142  1cd2              ADDS     r2,r2,#3
;;;334        y  = GETJSAMPLE(*inptr01++);
000144  f81a0b01          LDRB     r0,[r10],#1
;;;335        outptr1[RGB_RED] =   range_limit[y + cred];
000148  eb000b04          ADD      r11,r0,r4
00014c  f811b00b          LDRB     r11,[r1,r11]
000150  f883b000          STRB     r11,[r3,#0]
;;;336        outptr1[RGB_GREEN] = range_limit[y + cgreen];
000154  eb000b05          ADD      r11,r0,r5
000158  f811b00b          LDRB     r11,[r1,r11]
00015c  f883b001          STRB     r11,[r3,#1]
;;;337        outptr1[RGB_BLUE] =  range_limit[y + cblue];
000160  eb000b06          ADD      r11,r0,r6
000164  f811b00b          LDRB     r11,[r1,r11]
000168  f883b002          STRB     r11,[r3,#2]
;;;338        outptr1 += RGB_PIXELSIZE;
00016c  1cdb              ADDS     r3,r3,#3
;;;339        y  = GETJSAMPLE(*inptr01++);
00016e  f81a0b01          LDRB     r0,[r10],#1
;;;340        outptr1[RGB_RED] =   range_limit[y + cred];
000172  eb000b04          ADD      r11,r0,r4
000176  f811b00b          LDRB     r11,[r1,r11]
00017a  f883b000          STRB     r11,[r3,#0]
;;;341        outptr1[RGB_GREEN] = range_limit[y + cgreen];
00017e  eb000b05          ADD      r11,r0,r5
000182  f811b00b          LDRB     r11,[r1,r11]
000186  f883b001          STRB     r11,[r3,#1]
;;;342        outptr1[RGB_BLUE] =  range_limit[y + cblue];
00018a  eb000b06          ADD      r11,r0,r6
00018e  f811b00b          LDRB     r11,[r1,r11]
000192  f883b002          STRB     r11,[r3,#2]
;;;343        outptr1 += RGB_PIXELSIZE;
000196  1cdb              ADDS     r3,r3,#3
000198  f8ddb010          LDR      r11,[sp,#0x10]        ;316
00019c  f1ab0b01          SUB      r11,r11,#1            ;316
0001a0  f8cdb010          STR      r11,[sp,#0x10]        ;316
                  |L3.420|
0001a4  f8ddb010          LDR      r11,[sp,#0x10]        ;316
0001a8  f1bb0f00          CMP      r11,#0                ;316
0001ac  d181              BNE      |L3.178|
;;;344      }
;;;345      /* If image width is odd, do the last output column separately */
;;;346      if (cinfo->output_width & 1) {
0001ae  f8ddb020          LDR      r11,[sp,#0x20]
0001b2  f89bb070          LDRB     r11,[r11,#0x70]
0001b6  f01b0f01          TST      r11,#1
0001ba  d042              BEQ      |L3.578|
;;;347        cb = GETJSAMPLE(*inptr1);
0001bc  f8ddb018          LDR      r11,[sp,#0x18]
0001c0  f89bc000          LDRB     r12,[r11,#0]
;;;348        cr = GETJSAMPLE(*inptr2);
0001c4  f8ddb014          LDR      r11,[sp,#0x14]
0001c8  f89b8000          LDRB     r8,[r11,#0]
;;;349        cred = Crrtab[cr];
0001cc  f8ddb00c          LDR      r11,[sp,#0xc]
0001d0  f85b4028          LDR      r4,[r11,r8,LSL #2]
;;;350        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
0001d4  f8ddb000          LDR      r11,[sp,#0]
0001d8  f85be02c          LDR      lr,[r11,r12,LSL #2]
0001dc  f8ddb004          LDR      r11,[sp,#4]
0001e0  f85bb028          LDR      r11,[r11,r8,LSL #2]
0001e4  44f3              ADD      r11,r11,lr
0001e6  ea4f452b          ASR      r5,r11,#16
;;;351        cblue = Cbbtab[cb];
0001ea  f8ddb008          LDR      r11,[sp,#8]
0001ee  f85b602c          LDR      r6,[r11,r12,LSL #2]
;;;352        y  = GETJSAMPLE(*inptr00);
0001f2  f8990000          LDRB     r0,[r9,#0]
;;;353        outptr0[RGB_RED] =   range_limit[y + cred];
0001f6  eb000b04          ADD      r11,r0,r4
0001fa  f811b00b          LDRB     r11,[r1,r11]
0001fe  f882b000          STRB     r11,[r2,#0]
;;;354        outptr0[RGB_GREEN] = range_limit[y + cgreen];
000202  eb000b05          ADD      r11,r0,r5
000206  f811b00b          LDRB     r11,[r1,r11]
00020a  f882b001          STRB     r11,[r2,#1]
;;;355        outptr0[RGB_BLUE] =  range_limit[y + cblue];
00020e  eb000b06          ADD      r11,r0,r6
000212  f811b00b          LDRB     r11,[r1,r11]
000216  f882b002          STRB     r11,[r2,#2]
;;;356        y  = GETJSAMPLE(*inptr01);
00021a  f89a0000          LDRB     r0,[r10,#0]
;;;357        outptr1[RGB_RED] =   range_limit[y + cred];
00021e  eb000b04          ADD      r11,r0,r4
000222  f811b00b          LDRB     r11,[r1,r11]
000226  f883b000          STRB     r11,[r3,#0]
;;;358        outptr1[RGB_GREEN] = range_limit[y + cgreen];
00022a  eb000b05          ADD      r11,r0,r5
00022e  f811b00b          LDRB     r11,[r1,r11]
000232  f883b001          STRB     r11,[r3,#1]
;;;359        outptr1[RGB_BLUE] =  range_limit[y + cblue];
000236  eb000b06          ADD      r11,r0,r6
00023a  f811b00b          LDRB     r11,[r1,r11]
00023e  f883b002          STRB     r11,[r3,#2]
                  |L3.578|
;;;360      }
;;;361    }
000242  b00c              ADD      sp,sp,#0x30
000244  e8bd8ff0          POP      {r4-r11,pc}
;;;362    
                          ENDP


                          AREA ||i.jinit_merged_upsampler||, CODE, READONLY, ALIGN=2

                  jinit_merged_upsampler PROC
;;;372    GLOBAL(void)
;;;373    jinit_merged_upsampler (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4605              MOV      r5,r0
;;;375      my_upsample_ptr upsample;
;;;376    
;;;377      upsample = (my_upsample_ptr)
000004  6868              LDR      r0,[r5,#4]
000006  2230              MOVS     r2,#0x30
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4628              MOV      r0,r5
00000e  4798              BLX      r3
000010  4604              MOV      r4,r0
;;;378        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;379    				SIZEOF(my_upsampler));
;;;380      cinfo->upsample = (struct jpeg_upsampler *) upsample;
000012  f8c541c4          STR      r4,[r5,#0x1c4]
;;;381      upsample->pub.start_pass = start_pass_merged_upsample;
000016  4811              LDR      r0,|L4.92|
000018  6020              STR      r0,[r4,#0]
;;;382      upsample->pub.need_context_rows = FALSE;
00001a  2000              MOVS     r0,#0
00001c  60a0              STR      r0,[r4,#8]
;;;383    
;;;384      upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
00001e  6fa9              LDR      r1,[r5,#0x78]
000020  6f28              LDR      r0,[r5,#0x70]
000022  4348              MULS     r0,r1,r0
000024  62a0              STR      r0,[r4,#0x28]
;;;385    
;;;386      if (cinfo->max_v_samp_factor == 2) {
000026  f8d50138          LDR      r0,[r5,#0x138]
00002a  2802              CMP      r0,#2
00002c  d10b              BNE      |L4.70|
;;;387        upsample->pub.upsample = merged_2v_upsample;
00002e  480c              LDR      r0,|L4.96|
000030  6060              STR      r0,[r4,#4]
;;;388        upsample->upmethod = h2v2_merged_upsample;
000032  480c              LDR      r0,|L4.100|
000034  60e0              STR      r0,[r4,#0xc]
;;;389        /* Allocate a spare row buffer */
;;;390        upsample->spare_row = (JSAMPROW)
000036  6aa2              LDR      r2,[r4,#0x28]
000038  6868              LDR      r0,[r5,#4]
00003a  2101              MOVS     r1,#1
00003c  6843              LDR      r3,[r0,#4]
00003e  4628              MOV      r0,r5
000040  4798              BLX      r3
000042  6220              STR      r0,[r4,#0x20]
000044  e005              B        |L4.82|
                  |L4.70|
;;;391          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;392    		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
;;;393      } else {
;;;394        upsample->pub.upsample = merged_1v_upsample;
000046  4808              LDR      r0,|L4.104|
000048  6060              STR      r0,[r4,#4]
;;;395        upsample->upmethod = h2v1_merged_upsample;
00004a  4808              LDR      r0,|L4.108|
00004c  60e0              STR      r0,[r4,#0xc]
;;;396        /* No spare row needed */
;;;397        upsample->spare_row = NULL;
00004e  2000              MOVS     r0,#0
000050  6220              STR      r0,[r4,#0x20]
                  |L4.82|
;;;398      }
;;;399    
;;;400      build_ycc_rgb_table(cinfo);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       build_ycc_rgb_table
;;;401    }
000058  bd70              POP      {r4-r6,pc}
;;;402    
                          ENDP

00005a  0000              DCW      0x0000
                  |L4.92|
                          DCD      start_pass_merged_upsample
                  |L4.96|
                          DCD      merged_2v_upsample
                  |L4.100|
                          DCD      h2v2_merged_upsample
                  |L4.104|
                          DCD      merged_1v_upsample
                  |L4.108|
                          DCD      h2v1_merged_upsample

                          AREA ||i.merged_1v_upsample||, CODE, READONLY, ALIGN=1

                  merged_1v_upsample PROC
;;;193    METHODDEF(void)
;;;194    merged_1v_upsample (j_decompress_ptr cinfo,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;195    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;196    		    JDIMENSION in_row_groups_avail,
;;;197    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;198    		    JDIMENSION out_rows_avail)
;;;199    /* 1:1 vertical sampling case: much easier, never need a spare row. */
;;;200    {
000004  4606              MOV      r6,r0
000006  468b              MOV      r11,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
00000c  e9dd590b          LDRD     r5,r9,[sp,#0x2c]
000010  f8dd8028          LDR      r8,[sp,#0x28]
;;;201      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
000014  f8d6a1c4          LDR      r10,[r6,#0x1c4]
;;;202    
;;;203      GUI_USE_PARA(out_rows_avail);
000018  bf00              NOP      
;;;204      GUI_USE_PARA(in_row_groups_avail);
00001a  bf00              NOP      
;;;205      /* Just do the upsampling. */
;;;206      (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
00001c  6828              LDR      r0,[r5,#0]
00001e  eb080380          ADD      r3,r8,r0,LSL #2
000022  6822              LDR      r2,[r4,#0]
000024  4659              MOV      r1,r11
000026  4630              MOV      r0,r6
000028  f8dac00c          LDR      r12,[r10,#0xc]
00002c  47e0              BLX      r12
;;;207    			 output_buf + *out_row_ctr);
;;;208      /* Adjust counts */
;;;209      (*out_row_ctr)++;
00002e  6828              LDR      r0,[r5,#0]
000030  1c40              ADDS     r0,r0,#1
000032  6028              STR      r0,[r5,#0]
;;;210      (*in_row_group_ctr)++;
000034  6820              LDR      r0,[r4,#0]
000036  1c40              ADDS     r0,r0,#1
000038  6020              STR      r0,[r4,#0]
;;;211    }
00003a  e8bd9ff0          POP      {r4-r12,pc}
;;;212    
                          ENDP


                          AREA ||i.merged_2v_upsample||, CODE, READONLY, ALIGN=1

                  merged_2v_upsample PROC
;;;143    METHODDEF(void)
;;;144    merged_2v_upsample (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;145    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;146    		    JDIMENSION in_row_groups_avail,
;;;147    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;148    		    JDIMENSION out_rows_avail)
;;;149    /* 2:1 vertical sampling case: may need a spare row. */
;;;150    {
000004  b085              SUB      sp,sp,#0x14
000006  4682              MOV      r10,r0
000008  4617              MOV      r7,r2
00000a  469b              MOV      r11,r3
00000c  e9dd6913          LDRD     r6,r9,[sp,#0x4c]
000010  f8dd8048          LDR      r8,[sp,#0x48]
;;;151      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
000014  f8da41c4          LDR      r4,[r10,#0x1c4]
;;;152      JSAMPROW work_ptrs[2];
;;;153      JDIMENSION num_rows;		/* number of rows returned to caller */
;;;154    
;;;155      GUI_USE_PARA(in_row_groups_avail);
000018  bf00              NOP      
;;;156      if (upsample->spare_full) {
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  b180              CBZ      r0,|L6.64|
;;;157        /* If we have a spare row saved from a previous cycle, just return it. */
;;;158        jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
00001e  2101              MOVS     r1,#1
000020  6aa0              LDR      r0,[r4,#0x28]
000022  e9cd1000          STRD     r1,r0,[sp,#0]
000026  6830              LDR      r0,[r6,#0]
000028  eb080280          ADD      r2,r8,r0,LSL #2
00002c  2300              MOVS     r3,#0
00002e  4619              MOV      r1,r3
000030  f1040020          ADD      r0,r4,#0x20
000034  f7fffffe          BL       jcopy_sample_rows
;;;159    		      1, upsample->out_row_width);
;;;160        num_rows = 1;
000038  2501              MOVS     r5,#1
;;;161        upsample->spare_full = FALSE;
00003a  2000              MOVS     r0,#0
00003c  6260              STR      r0,[r4,#0x24]
00003e  e021              B        |L6.132|
                  |L6.64|
;;;162      } else {
;;;163        /* Figure number of rows to return to caller. */
;;;164        num_rows = 2;
000040  2502              MOVS     r5,#2
;;;165        /* Not more than the distance to the end of the image. */
;;;166        if (num_rows > upsample->rows_to_go)
000042  6ae0              LDR      r0,[r4,#0x2c]
000044  42a8              CMP      r0,r5
000046  d200              BCS      |L6.74|
;;;167          num_rows = upsample->rows_to_go;
000048  6ae5              LDR      r5,[r4,#0x2c]
                  |L6.74|
;;;168        /* And not more than what the client can accept: */
;;;169        out_rows_avail -= *out_row_ctr;
00004a  6830              LDR      r0,[r6,#0]
00004c  eba90900          SUB      r9,r9,r0
;;;170        if (num_rows > out_rows_avail)
000050  454d              CMP      r5,r9
000052  d900              BLS      |L6.86|
;;;171          num_rows = out_rows_avail;
000054  464d              MOV      r5,r9
                  |L6.86|
;;;172        /* Create output pointer array for upsampler. */
;;;173        work_ptrs[0] = output_buf[*out_row_ctr];
000056  6830              LDR      r0,[r6,#0]
000058  f8580020          LDR      r0,[r8,r0,LSL #2]
00005c  9003              STR      r0,[sp,#0xc]
;;;174        if (num_rows > 1) {
00005e  2d01              CMP      r5,#1
000060  d905              BLS      |L6.110|
;;;175          work_ptrs[1] = output_buf[*out_row_ctr + 1];
000062  6830              LDR      r0,[r6,#0]
000064  1c40              ADDS     r0,r0,#1
000066  f8580020          LDR      r0,[r8,r0,LSL #2]
00006a  9004              STR      r0,[sp,#0x10]
00006c  e003              B        |L6.118|
                  |L6.110|
;;;176        } else {
;;;177          work_ptrs[1] = upsample->spare_row;
00006e  6a20              LDR      r0,[r4,#0x20]
000070  9004              STR      r0,[sp,#0x10]
;;;178          upsample->spare_full = TRUE;
000072  2001              MOVS     r0,#1
000074  6260              STR      r0,[r4,#0x24]
                  |L6.118|
;;;179        }
;;;180        /* Now do the upsampling. */
;;;181        (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
000076  683a              LDR      r2,[r7,#0]
000078  ab03              ADD      r3,sp,#0xc
00007a  f8d4c00c          LDR      r12,[r4,#0xc]
00007e  4650              MOV      r0,r10
000080  9906              LDR      r1,[sp,#0x18]
000082  47e0              BLX      r12
                  |L6.132|
;;;182      }
;;;183    
;;;184      /* Adjust counts */
;;;185      *out_row_ctr += num_rows;
000084  6830              LDR      r0,[r6,#0]
000086  4428              ADD      r0,r0,r5
000088  6030              STR      r0,[r6,#0]
;;;186      upsample->rows_to_go -= num_rows;
00008a  6ae0              LDR      r0,[r4,#0x2c]
00008c  1b40              SUBS     r0,r0,r5
00008e  62e0              STR      r0,[r4,#0x2c]
;;;187      /* When the buffer is emptied, declare this input row group consumed */
;;;188      if (! upsample->spare_full)
000090  6a60              LDR      r0,[r4,#0x24]
000092  b910              CBNZ     r0,|L6.154|
;;;189        (*in_row_group_ctr)++;
000094  6838              LDR      r0,[r7,#0]
000096  1c40              ADDS     r0,r0,#1
000098  6038              STR      r0,[r7,#0]
                  |L6.154|
;;;190    }
00009a  b009              ADD      sp,sp,#0x24
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;191    
                          ENDP


                          AREA ||i.start_pass_merged_upsample||, CODE, READONLY, ALIGN=1

                  start_pass_merged_upsample PROC
;;;125    METHODDEF(void)
;;;126    start_pass_merged_upsample (j_decompress_ptr cinfo)
000000  f8d011c4          LDR      r1,[r0,#0x1c4]
;;;127    {
;;;128      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
;;;129    
;;;130      /* Mark the spare buffer empty */
;;;131      upsample->spare_full = FALSE;
000004  2200              MOVS     r2,#0
000006  624a              STR      r2,[r1,#0x24]
;;;132      /* Initialize total-height counter for detecting bottom of image */
;;;133      upsample->rows_to_go = cinfo->output_height;
000008  6f42              LDR      r2,[r0,#0x74]
00000a  62ca              STR      r2,[r1,#0x2c]
;;;134    }
00000c  4770              BX       lr
;;;135    
                          ENDP

