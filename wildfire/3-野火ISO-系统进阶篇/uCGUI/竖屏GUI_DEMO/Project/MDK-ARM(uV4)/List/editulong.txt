; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\editulong.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\editulong.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\Widget\EDITUlong.c]
                          THUMB

                          AREA ||i.EDIT_SetUlongMode||, CODE, READONLY, ALIGN=2

                  EDIT_SetUlongMode PROC
;;;223    */
;;;224    void EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;225      EDIT_Obj* pObj;
;;;226      WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;227      if (hEdit) {
000010  f1b80f00          CMP      r8,#0
000014  d01c              BEQ      |L1.80|
;;;228        pObj = EDIT_H2P(hEdit);
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4604              MOV      r4,r0
;;;229        if (Value > Max) {
00001e  42bd              CMP      r5,r7
000020  d901              BLS      |L1.38|
;;;230          Value = Max;
000022  463d              MOV      r5,r7
000024  e002              B        |L1.44|
                  |L1.38|
;;;231        } else if (Value < Min) {
000026  42b5              CMP      r5,r6
000028  d200              BCS      |L1.44|
;;;232          Value = Min;
00002a  4635              MOV      r5,r6
                  |L1.44|
;;;233        }
;;;234        pObj->pfAddKeyEx    = _AddKey;
00002c  480a              LDR      r0,|L1.88|
00002e  64e0              STR      r0,[r4,#0x4c]
;;;235        pObj->pfUpdateBuffer= _UpdateBuffer;
000030  480a              LDR      r0,|L1.92|
000032  6520              STR      r0,[r4,#0x50]
;;;236        pObj->CurrentValue  = Value;
000034  63e5              STR      r5,[r4,#0x3c]
;;;237        pObj->CursorPos     = 0;
000036  2000              MOVS     r0,#0
000038  6420              STR      r0,[r4,#0x40]
;;;238        pObj->Min           = Min;
00003a  6326              STR      r6,[r4,#0x30]
;;;239        pObj->Max           = Max;
00003c  6367              STR      r7,[r4,#0x34]
;;;240        pObj->EditMode      = GUI_EDIT_MODE_OVERWRITE;
00003e  2001              MOVS     r0,#1
000040  f8840048          STRB     r0,[r4,#0x48]
;;;241        _UpdateBuffer(hEdit);
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       _UpdateBuffer
;;;242        WM_Invalidate(hEdit);
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       WM_InvalidateWindow
                  |L1.80|
;;;243      }
;;;244      WM_UNLOCK();
000050  f7fffffe          BL       GUI_Unlock
;;;245    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;246    
                          ENDP

                  |L1.88|
                          DCD      _AddKey
                  |L1.92|
                          DCD      _UpdateBuffer

                          AREA ||i._AddKey||, CODE, READONLY, ALIGN=1

                  _AddKey PROC
;;;182    */
;;;183    static void _AddKey(EDIT_Handle hObj, int Key) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;184      EDIT_Obj * pObj;
;;;185      pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;186      if (pObj) {
000010  b37c              CBZ      r4,|L2.114|
;;;187        switch (Key) {
000012  2e10              CMP      r6,#0x10
000014  d017              BEQ      |L2.70|
000016  2e11              CMP      r6,#0x11
000018  d004              BEQ      |L2.36|
00001a  2e12              CMP      r6,#0x12
00001c  d00f              BEQ      |L2.62|
00001e  2e13              CMP      r6,#0x13
000020  d117              BNE      |L2.82|
000022  e005              B        |L2.48|
                  |L2.36|
;;;188        case GUI_KEY_UP:
;;;189          _AddPosition(pObj, hObj, 1);
000024  2201              MOVS     r2,#1
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _AddPosition
;;;190          break;
00002e  e01f              B        |L2.112|
                  |L2.48|
;;;191        case GUI_KEY_DOWN:
;;;192          _AddPosition(pObj, hObj, -1);
000030  f04f32ff          MOV      r2,#0xffffffff
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       _AddPosition
;;;193          break;
00003c  e018              B        |L2.112|
                  |L2.62|
;;;194        case GUI_KEY_RIGHT:
;;;195          _IncrementCursor(pObj);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       _IncrementCursor
;;;196          break;
000044  e014              B        |L2.112|
                  |L2.70|
;;;197        case GUI_KEY_LEFT:
;;;198          EDIT__SetCursorPos(pObj, pObj->CursorPos - 1);
000046  6c20              LDR      r0,[r4,#0x40]
000048  1e41              SUBS     r1,r0,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       EDIT__SetCursorPos
;;;199          break;
000050  e00e              B        |L2.112|
                  |L2.82|
;;;200        default:
;;;201          {
;;;202            int Digit = _DecChar2Int(Key);
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       _DecChar2Int
000058  4607              MOV      r7,r0
;;;203            if (Digit >= 0) {
00005a  2f00              CMP      r7,#0
00005c  db07              BLT      |L2.110|
;;;204              _EditULong(Digit, pObj, hObj);
00005e  462a              MOV      r2,r5
000060  4621              MOV      r1,r4
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       _EditULong
;;;205              _IncrementCursor(pObj);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       _IncrementCursor
                  |L2.110|
;;;206            }
;;;207          }
;;;208          break;
00006e  bf00              NOP      
                  |L2.112|
000070  bf00              NOP                            ;190
                  |L2.114|
;;;209        }
;;;210      }
;;;211      _UpdateBuffer(hObj);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       _UpdateBuffer
;;;212    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP


                          AREA ||i._AddPosition||, CODE, READONLY, ALIGN=1

                  _AddPosition PROC
;;;149    */
;;;150    static void _AddPosition(EDIT_Obj* pObj, EDIT_Handle hObj, int Sign) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;151      int Pos;
;;;152      I32 v, NewValue;
;;;153      v = Sign;
00000a  4645              MOV      r5,r8
;;;154      Pos = pObj->MaxLen - pObj->CursorPos-1;
00000c  f9b4002a          LDRSH    r0,[r4,#0x2a]
000010  6c21              LDR      r1,[r4,#0x40]
000012  1a40              SUBS     r0,r0,r1
000014  1e46              SUBS     r6,r0,#1
;;;155      if (pObj->NumDecs && (Pos > pObj->NumDecs)) {
000016  f8940038          LDRB     r0,[r4,#0x38]
00001a  b120              CBZ      r0,|L3.38|
00001c  f8940038          LDRB     r0,[r4,#0x38]
000020  42b0              CMP      r0,r6
000022  da00              BGE      |L3.38|
;;;156        Pos--;
000024  1e76              SUBS     r6,r6,#1
                  |L3.38|
;;;157      }
;;;158      while (Pos--) {
000026  e002              B        |L3.46|
                  |L3.40|
;;;159        v *= 10;
000028  eb050085          ADD      r0,r5,r5,LSL #2
00002c  0045              LSLS     r5,r0,#1
                  |L3.46|
00002e  0030              MOVS     r0,r6                 ;158
000030  f1a60601          SUB      r6,r6,#1              ;158
000034  d1f8              BNE      |L3.40|
;;;160      }
;;;161      NewValue = pObj->CurrentValue + v;
000036  6be0              LDR      r0,[r4,#0x3c]
000038  eb000905          ADD      r9,r0,r5
;;;162      /*
;;;163       * Check if overflow occurs
;;;164       */
;;;165      if (v > 0) {
00003c  2d00              CMP      r5,#0
00003e  dd07              BLE      |L3.80|
;;;166        /* If result of addition is less than previous value he have an overflow */
;;;167        if (((U32)pObj->CurrentValue + v) < (U32)pObj->CurrentValue) {
000040  6be0              LDR      r0,[r4,#0x3c]
000042  4428              ADD      r0,r0,r5
000044  6be1              LDR      r1,[r4,#0x3c]
000046  4288              CMP      r0,r1
000048  d20b              BCS      |L3.98|
;;;168          NewValue = pObj->Max; /* Set maximum value */
00004a  f8d49034          LDR      r9,[r4,#0x34]
00004e  e008              B        |L3.98|
                  |L3.80|
;;;169        }
;;;170      } else if (v < 0) {
000050  2d00              CMP      r5,#0
000052  da06              BGE      |L3.98|
;;;171        /* If result of addition is more than previous value he have an overflow */
;;;172        if (((U32)pObj->CurrentValue + v) > (U32)pObj->CurrentValue) {
000054  6be0              LDR      r0,[r4,#0x3c]
000056  4428              ADD      r0,r0,r5
000058  6be1              LDR      r1,[r4,#0x3c]
00005a  4288              CMP      r0,r1
00005c  d901              BLS      |L3.98|
;;;173          NewValue = pObj->Min; /* Set minimum value */
00005e  f8d49030          LDR      r9,[r4,#0x30]
                  |L3.98|
;;;174        }
;;;175      }
;;;176      EDIT__SetValueUnsigned(hObj, NewValue);
000062  4649              MOV      r1,r9
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       EDIT__SetValueUnsigned
;;;177    }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;178    
                          ENDP


                          AREA ||i._DecChar2Int||, CODE, READONLY, ALIGN=1

                  _DecChar2Int PROC
;;;44     */
;;;45     static int _DecChar2Int(int Char) {
000000  4601              MOV      r1,r0
;;;46       if ((Char >= '0') && (Char <= '9')) {
000002  2930              CMP      r1,#0x30
000004  db04              BLT      |L4.16|
000006  2939              CMP      r1,#0x39
000008  dc02              BGT      |L4.16|
;;;47         return Char - '0';
00000a  f1a10030          SUB      r0,r1,#0x30
                  |L4.14|
;;;48       }
;;;49       return -1;
;;;50     }
00000e  4770              BX       lr
                  |L4.16|
000010  f04f30ff          MOV      r0,#0xffffffff        ;49
000014  e7fb              B        |L4.14|
;;;51     
                          ENDP


                          AREA ||i._EditULong||, CODE, READONLY, ALIGN=2

                  _EditULong PROC
;;;85     */
;;;86     static void _EditULong(int Digit, EDIT_Obj* pObj, EDIT_Handle hObj) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b084              SUB      sp,sp,#0x10
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;87       U32 Result = 0;
00000a  2500              MOVS     r5,#0
;;;88       int i, j, Pos = 0;
00000c  2600              MOVS     r6,#0
;;;89       char * s = (char*) GUI_ALLOC_h2p(pObj->hpText);
00000e  f9b40028          LDRSH    r0,[r4,#0x28]
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  9002              STR      r0,[sp,#8]
;;;90       for (i = 0; i < pObj->MaxLen; i++) {
000018  46a8              MOV      r8,r5
00001a  e04e              B        |L5.186|
                  |L5.28|
;;;91         int Index = pObj->MaxLen - i - 1;
00001c  f9b4002a          LDRSH    r0,[r4,#0x2a]
000020  eba00008          SUB      r0,r0,r8
000024  f1a00901          SUB      r9,r0,#1
;;;92         if (Index == pObj->CursorPos) {
000028  6c20              LDR      r0,[r4,#0x40]
00002a  4548              CMP      r0,r9
00002c  d12b              BNE      |L5.134|
;;;93           /* In this case we need to check if an overflow occures */
;;;94           char c;
;;;95           int Value;
;;;96           U32 OldResult;
;;;97           /* Calculate old value (until cursor position) */
;;;98           c         = *(s + Index);
00002e  9802              LDR      r0,[sp,#8]
000030  f8100009          LDRB     r0,[r0,r9]
000034  9001              STR      r0,[sp,#4]
;;;99           Value     = _DecChar2Int(c);
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       _DecChar2Int
00003c  4682              MOV      r10,r0
;;;100          OldResult = Result;
00003e  46ab              MOV      r11,r5
;;;101          if (Value >= 0) {
000040  f1ba0f00          CMP      r10,#0
000044  db04              BLT      |L5.80|
;;;102            OldResult += GUI_Pow10[Pos] * Value;
000046  4823              LDR      r0,|L5.212|
000048  f8500026          LDR      r0,[r0,r6,LSL #2]
00004c  fb00bb0a          MLA      r11,r0,r10,r11
                  |L5.80|
;;;103          }
;;;104          /* Calculate new value (until cursor position).
;;;105           * A multiplication like Result += GUI_Pow10[Pos++] * Digit
;;;106           * does not work, because in this case we have no chance to
;;;107           * notice an overflow.
;;;108           */
;;;109          for (j = 0; j < Digit; j++) {
000050  2000              MOVS     r0,#0
000052  9003              STR      r0,[sp,#0xc]
000054  e00b              B        |L5.110|
                  |L5.86|
;;;110            U32 NewResult;
;;;111            NewResult = Result + GUI_Pow10[Pos];
000056  491f              LDR      r1,|L5.212|
000058  f8511026          LDR      r1,[r1,r6,LSL #2]
00005c  1948              ADDS     r0,r1,r5
;;;112            /* Check if we have an overflow */
;;;113            if (NewResult < Result) {
00005e  42a8              CMP      r0,r5
000060  d201              BCS      |L5.102|
;;;114              Result = pObj->Max;
000062  6b65              LDR      r5,[r4,#0x34]
;;;115              break;
000064  e006              B        |L5.116|
                  |L5.102|
;;;116            }
;;;117            Result = NewResult;
000066  4605              MOV      r5,r0
000068  9803              LDR      r0,[sp,#0xc]          ;109
00006a  1c40              ADDS     r0,r0,#1              ;109
00006c  9003              STR      r0,[sp,#0xc]          ;109
                  |L5.110|
00006e  9803              LDR      r0,[sp,#0xc]          ;109
000070  42b8              CMP      r0,r7                 ;109
000072  dbf0              BLT      |L5.86|
                  |L5.116|
000074  bf00              NOP                            ;115
;;;118          }
;;;119          /* Check if we have an overflow */
;;;120          if (Digit > Value) {
000076  4557              CMP      r7,r10
000078  dd03              BLE      |L5.130|
;;;121            if (Result < OldResult) {
00007a  455d              CMP      r5,r11
00007c  d201              BCS      |L5.130|
;;;122              Result = pObj->Max;
00007e  6b65              LDR      r5,[r4,#0x34]
;;;123              break;
000080  e01f              B        |L5.194|
                  |L5.130|
;;;124            }
;;;125          }
;;;126          Pos++;
000082  1c76              ADDS     r6,r6,#1
;;;127        } else {
000084  e017              B        |L5.182|
                  |L5.134|
;;;128          /* If current index is not the cursor position */
;;;129          char c = *(s + Index);
000086  9802              LDR      r0,[sp,#8]
000088  f810b009          LDRB     r11,[r0,r9]
;;;130          int Value = _DecChar2Int(c);
00008c  4658              MOV      r0,r11
00008e  f7fffffe          BL       _DecChar2Int
000092  4682              MOV      r10,r0
;;;131          if (Value >= 0) {
000094  f1ba0f00          CMP      r10,#0
000098  db0c              BLT      |L5.180|
;;;132            U32 OldResult;
;;;133            OldResult = Result;
00009a  4628              MOV      r0,r5
;;;134            Result += GUI_Pow10[Pos++] * Value;
00009c  4631              MOV      r1,r6
00009e  1c76              ADDS     r6,r6,#1
0000a0  4a0c              LDR      r2,|L5.212|
0000a2  f8521021          LDR      r1,[r2,r1,LSL #2]
0000a6  fb01550a          MLA      r5,r1,r10,r5
;;;135            /* Check if we have an overflow */
;;;136            if (Result < OldResult) {
0000aa  4285              CMP      r5,r0
0000ac  d201              BCS      |L5.178|
;;;137              Result = pObj->Max;
0000ae  6b65              LDR      r5,[r4,#0x34]
;;;138              break;
0000b0  e007              B        |L5.194|
                  |L5.178|
;;;139            }
;;;140          }
0000b2  bf00              NOP      
                  |L5.180|
;;;141        }
0000b4  bf00              NOP      
                  |L5.182|
0000b6  f1080801          ADD      r8,r8,#1              ;90
                  |L5.186|
0000ba  f9b4002a          LDRSH    r0,[r4,#0x2a]         ;90
0000be  4540              CMP      r0,r8                 ;90
0000c0  dcac              BGT      |L5.28|
                  |L5.194|
0000c2  bf00              NOP                            ;123
;;;142      }
;;;143      EDIT__SetValueUnsigned(hObj, Result);
0000c4  4629              MOV      r1,r5
0000c6  9806              LDR      r0,[sp,#0x18]
0000c8  f7fffffe          BL       EDIT__SetValueUnsigned
;;;144    }
0000cc  b007              ADD      sp,sp,#0x1c
0000ce  e8bd8ff0          POP      {r4-r11,pc}
;;;145    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L5.212|
                          DCD      GUI_Pow10

                          AREA ||i._IncrementCursor||, CODE, READONLY, ALIGN=1

                  _IncrementCursor PROC
;;;36     */
;;;37     static void _IncrementCursor(EDIT_Obj* pObj) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;38       EDIT__SetCursorPos(pObj, pObj->CursorPos + 1);
000004  6c20              LDR      r0,[r4,#0x40]
000006  1c41              ADDS     r1,r0,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       EDIT__SetCursorPos
;;;39     }
00000e  bd10              POP      {r4,pc}
;;;40     
                          ENDP


                          AREA ||i._UpdateBuffer||, CODE, READONLY, ALIGN=1

                  _UpdateBuffer PROC
;;;55     */
;;;56     static void _UpdateBuffer(EDIT_Handle hObj) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4680              MOV      r8,r0
;;;57       char acValue[10] = {0};
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
00000c  9002              STR      r0,[sp,#8]
;;;58       int NumDigits = 0;
00000e  2400              MOVS     r4,#0
;;;59       U32 Value;
;;;60       char * s;
;;;61       EDIT_Obj * pObj;
;;;62       pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4606              MOV      r6,r0
;;;63       s = (char*) GUI_ALLOC_h2p(pObj->hpText);
000018  f9b60028          LDRSH    r0,[r6,#0x28]
00001c  f7fffffe          BL       GUI_ALLOC_h2p
000020  4607              MOV      r7,r0
;;;64       /* Convert an unsigned long value into text */
;;;65       Value = pObj->CurrentValue;
000022  6bf5              LDR      r5,[r6,#0x3c]
;;;66       /* Fill the buffer with the digits (reverse order) */
;;;67       while (Value) {
000024  e00f              B        |L7.70|
                  |L7.38|
;;;68         U8 c = Value % 10;
000026  210a              MOVS     r1,#0xa
000028  fbb5f2f1          UDIV     r2,r5,r1
00002c  fb015012          MLS      r0,r1,r2,r5
;;;69         acValue[NumDigits++] = '0' + c;
000030  f1000130          ADD      r1,r0,#0x30
000034  b2cb              UXTB     r3,r1
000036  4621              MOV      r1,r4
000038  1c64              ADDS     r4,r4,#1
00003a  f80d3001          STRB     r3,[sp,r1]
;;;70         Value /= 10;
00003e  210a              MOVS     r1,#0xa
000040  fbb5f5f1          UDIV     r5,r5,r1
;;;71       }
000044  bf00              NOP      
                  |L7.70|
000046  2d00              CMP      r5,#0                 ;67
000048  d1ed              BNE      |L7.38|
;;;72       /* Fill with leading spaces */
;;;73       while (NumDigits < pObj->MaxLen) {
00004a  e004              B        |L7.86|
                  |L7.76|
;;;74         acValue[NumDigits++] = '0';
00004c  2230              MOVS     r2,#0x30
00004e  4620              MOV      r0,r4
000050  1c64              ADDS     r4,r4,#1
000052  f80d2000          STRB     r2,[sp,r0]
                  |L7.86|
000056  f9b6002a          LDRSH    r0,[r6,#0x2a]         ;73
00005a  42a0              CMP      r0,r4                 ;73
00005c  dcf6              BGT      |L7.76|
;;;75       }
;;;76       /* Reverse order */
;;;77       while (NumDigits) {
00005e  e005              B        |L7.108|
                  |L7.96|
;;;78         *(s++) = acValue[--NumDigits];
000060  1e60              SUBS     r0,r4,#1
000062  4604              MOV      r4,r0
000064  f81d0000          LDRB     r0,[sp,r0]
000068  f8070b01          STRB     r0,[r7],#1
                  |L7.108|
00006c  2c00              CMP      r4,#0                 ;77
00006e  d1f7              BNE      |L7.96|
;;;79       }
;;;80     }
000070  e8bd83fe          POP      {r1-r9,pc}
;;;81     
                          ENDP

