; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_mbox.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_mbox.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCOS-II\Source\os_mbox.c]
                          THUMB

                          AREA ||i.OSMboxAccept||, CODE, READONLY, ALIGN=1

                  OSMboxAccept PROC
;;;46     #if OS_MBOX_ACCEPT_EN > 0u
;;;47     void  *OSMboxAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         void      *pmsg;
;;;50     #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
;;;51         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;52     #endif
;;;53     
;;;54     
;;;55     
;;;56     #if OS_ARG_CHK_EN > 0u
;;;57         if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
;;;58             return ((void *)0);
;;;59         }
;;;60     #endif
;;;61         if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000006  7820              LDRB     r0,[r4,#0]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L1.16|
;;;62             return ((void *)0);
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;63         }
;;;64         OS_ENTER_CRITICAL();
;;;65         pmsg               = pevent->OSEventPtr;
;;;66         pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
;;;67         OS_EXIT_CRITICAL();
;;;68         return (pmsg);                                        /* Return the message received (or NULL)     */
;;;69     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;64
000016  6865              LDR      r5,[r4,#4]            ;65
000018  2000              MOVS     r0,#0                 ;66
00001a  6060              STR      r0,[r4,#4]            ;66
00001c  4630              MOV      r0,r6                 ;67
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  4628              MOV      r0,r5                 ;68
000024  e7f3              B        |L1.14|
;;;70     #endif
                          ENDP


                          AREA ||i.OSMboxCreate||, CODE, READONLY, ALIGN=2

                  OSMboxCreate PROC
;;;87     
;;;88     OS_EVENT  *OSMboxCreate (void *pmsg)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4605              MOV      r5,r0
;;;90         OS_EVENT  *pevent;
;;;91     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;92         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;93     #endif
;;;94     
;;;95     
;;;96     
;;;97     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;98         if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;99             OS_SAFETY_CRITICAL_EXCEPTION();
;;;100            return ((OS_EVENT *)0);
;;;101        }
;;;102    #endif
;;;103    
;;;104        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000006  4810              LDR      r0,|L2.72|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b108              CBZ      r0,|L2.16|
;;;105            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;106        }
;;;107        OS_ENTER_CRITICAL();
;;;108        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;109        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;110            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;111        }
;;;112        OS_EXIT_CRITICAL();
;;;113        if (pevent != (OS_EVENT *)0) {
;;;114            pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
;;;115            pevent->OSEventCnt     = 0u;
;;;116            pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
;;;117    #if OS_EVENT_NAME_EN > 0u
;;;118            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;119    #endif
;;;120            OS_EventWaitListInit(pevent);
;;;121        }
;;;122        return (pevent);                             /* Return pointer to event control block              */
;;;123    }
00000e  bd70              POP      {r4-r6,pc}
                  |L2.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;107
000016  480d              LDR      r0,|L2.76|
000018  6804              LDR      r4,[r0,#0]            ;108  ; OSEventFreeList
00001a  6800              LDR      r0,[r0,#0]            ;109  ; OSEventFreeList
00001c  b120              CBZ      r0,|L2.40|
00001e  480b              LDR      r0,|L2.76|
000020  6800              LDR      r0,[r0,#0]            ;110  ; OSEventFreeList
000022  6840              LDR      r0,[r0,#4]            ;110
000024  4909              LDR      r1,|L2.76|
000026  6008              STR      r0,[r1,#0]            ;110  ; OSEventFreeList
                  |L2.40|
000028  4630              MOV      r0,r6                 ;112
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  b14c              CBZ      r4,|L2.68|
000030  2001              MOVS     r0,#1                 ;114
000032  7020              STRB     r0,[r4,#0]            ;114
000034  2000              MOVS     r0,#0                 ;115
000036  8120              STRH     r0,[r4,#8]            ;115
000038  6065              STR      r5,[r4,#4]            ;116
00003a  a005              ADR      r0,|L2.80|
00003c  6120              STR      r0,[r4,#0x10]         ;118
00003e  4620              MOV      r0,r4                 ;120
000040  f7fffffe          BL       OS_EventWaitListInit
                  |L2.68|
000044  4620              MOV      r0,r4                 ;122
000046  e7e2              B        |L2.14|
;;;124    /*$PAGE*/
                          ENDP

                  |L2.72|
                          DCD      OSIntNesting
                  |L2.76|
                          DCD      OSEventFreeList
                  |L2.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.OSMboxDel||, CODE, READONLY, ALIGN=2

                  OSMboxDel PROC
;;;161    #if OS_MBOX_DEL_EN > 0u
;;;162    OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;163                          INT8U      opt,
;;;164                          INT8U     *perr)
;;;165    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;166        BOOLEAN    tasks_waiting;
;;;167        OS_EVENT  *pevent_return;
;;;168    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;169        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;170    #endif
;;;171    
;;;172    
;;;173    
;;;174    #ifdef OS_SAFETY_CRITICAL
;;;175        if (perr == (INT8U *)0) {
;;;176            OS_SAFETY_CRITICAL_EXCEPTION();
;;;177            return ((OS_EVENT *)0);
;;;178        }
;;;179    #endif
;;;180    
;;;181    #if OS_ARG_CHK_EN > 0u
;;;182        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;183            *perr = OS_ERR_PEVENT_NULL;
;;;184            return (pevent);
;;;185        }
;;;186    #endif
;;;187        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L3.30|
;;;188            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;189            return (pevent);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;190        }
;;;191        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;192            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;193            return (pevent);
;;;194        }
;;;195        OS_ENTER_CRITICAL();
;;;196        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
;;;197            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;198        } else {
;;;199            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;200        }
;;;201        switch (opt) {
;;;202            case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
;;;203                 if (tasks_waiting == OS_FALSE) {
;;;204    #if OS_EVENT_NAME_EN > 0u
;;;205                     pevent->OSEventName = (INT8U *)(void *)"?";
;;;206    #endif
;;;207                     pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;208                     pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
;;;209                     pevent->OSEventCnt  = 0u;
;;;210                     OSEventFreeList     = pevent;             /* Get next free event control block        */
;;;211                     OS_EXIT_CRITICAL();
;;;212                     *perr               = OS_ERR_NONE;
;;;213                     pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
;;;214                 } else {
;;;215                     OS_EXIT_CRITICAL();
;;;216                     *perr               = OS_ERR_TASK_WAITING;
;;;217                     pevent_return       = pevent;
;;;218                 }
;;;219                 break;
;;;220    
;;;221            case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
;;;222                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
;;;223                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;224                 }
;;;225    #if OS_EVENT_NAME_EN > 0u
;;;226                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;227    #endif
;;;228                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;229                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;230                 pevent->OSEventCnt     = 0u;
;;;231                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;232                 OS_EXIT_CRITICAL();
;;;233                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;234                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;235                 }
;;;236                 *perr         = OS_ERR_NONE;
;;;237                 pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
;;;238                 break;
;;;239    
;;;240            default:
;;;241                 OS_EXIT_CRITICAL();
;;;242                 *perr         = OS_ERR_INVALID_OPT;
;;;243                 pevent_return = pevent;
;;;244                 break;
;;;245        }
;;;246        return (pevent_return);
;;;247    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  482d              LDR      r0,|L3.212|
000020  7800              LDRB     r0,[r0,#0]            ;191  ; OSIntNesting
000022  b118              CBZ      r0,|L3.44|
000024  200f              MOVS     r0,#0xf               ;192
000026  7028              STRB     r0,[r5,#0]            ;192
000028  4620              MOV      r0,r4                 ;193
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4681              MOV      r9,r0                 ;195
000032  7aa0              LDRB     r0,[r4,#0xa]          ;196
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;197
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;199
                  |L3.60|
00003c  f1b80f00          CMP      r8,#0                 ;201
000040  d003              BEQ      |L3.74|
000042  f1b80f01          CMP      r8,#1                 ;201
000046  d13a              BNE      |L3.190|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a022              ADR      r0,|L3.216|
00004e  6120              STR      r0,[r4,#0x10]         ;205
000050  2000              MOVS     r0,#0                 ;207
000052  7020              STRB     r0,[r4,#0]            ;207
000054  4821              LDR      r0,|L3.220|
000056  6800              LDR      r0,[r0,#0]            ;208  ; OSEventFreeList
000058  6060              STR      r0,[r4,#4]            ;208
00005a  2000              MOVS     r0,#0                 ;209
00005c  8120              STRH     r0,[r4,#8]            ;209
00005e  481f              LDR      r0,|L3.220|
000060  6004              STR      r4,[r0,#0]            ;210  ; OSEventFreeList
000062  4648              MOV      r0,r9                 ;211
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;212
00006a  7028              STRB     r0,[r5,#0]            ;212
00006c  2600              MOVS     r6,#0                 ;213
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4648              MOV      r0,r9                 ;215
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;216
000078  7028              STRB     r0,[r5,#0]            ;216
00007a  4626              MOV      r6,r4                 ;217
                  |L3.124|
00007c  e026              B        |L3.204|
                  |L3.126|
00007e  e005              B        |L3.140|
                  |L3.128|
000080  2300              MOVS     r3,#0                 ;223
000082  2202              MOVS     r2,#2                 ;223
000084  4619              MOV      r1,r3                 ;223
000086  4620              MOV      r0,r4                 ;223
000088  f7fffffe          BL       OS_EventTaskRdy
                  |L3.140|
00008c  7aa0              LDRB     r0,[r4,#0xa]          ;222
00008e  2800              CMP      r0,#0                 ;222
000090  d1f6              BNE      |L3.128|
000092  a011              ADR      r0,|L3.216|
000094  6120              STR      r0,[r4,#0x10]         ;226
000096  2000              MOVS     r0,#0                 ;228
000098  7020              STRB     r0,[r4,#0]            ;228
00009a  4810              LDR      r0,|L3.220|
00009c  6800              LDR      r0,[r0,#0]            ;229  ; OSEventFreeList
00009e  6060              STR      r0,[r4,#4]            ;229
0000a0  2000              MOVS     r0,#0                 ;230
0000a2  8120              STRH     r0,[r4,#8]            ;230
0000a4  480d              LDR      r0,|L3.220|
0000a6  6004              STR      r4,[r0,#0]            ;231  ; OSEventFreeList
0000a8  4648              MOV      r0,r9                 ;232
0000aa  f7fffffe          BL       OS_CPU_SR_Restore
0000ae  2f01              CMP      r7,#1                 ;233
0000b0  d101              BNE      |L3.182|
0000b2  f7fffffe          BL       OS_Sched
                  |L3.182|
0000b6  2000              MOVS     r0,#0                 ;236
0000b8  7028              STRB     r0,[r5,#0]            ;236
0000ba  2600              MOVS     r6,#0                 ;237
0000bc  e006              B        |L3.204|
                  |L3.190|
0000be  4648              MOV      r0,r9                 ;241
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  2007              MOVS     r0,#7                 ;242
0000c6  7028              STRB     r0,[r5,#0]            ;242
0000c8  4626              MOV      r6,r4                 ;243
0000ca  bf00              NOP                            ;244
                  |L3.204|
0000cc  bf00              NOP                            ;219
0000ce  4630              MOV      r0,r6                 ;246
0000d0  e7a3              B        |L3.26|
;;;248    #endif
                          ENDP

0000d2  0000              DCW      0x0000
                  |L3.212|
                          DCD      OSIntNesting
                  |L3.216|
0000d8  3f00              DCB      "?",0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L3.220|
                          DCD      OSEventFreeList

                          AREA ||i.OSMboxPend||, CODE, READONLY, ALIGN=2

                  OSMboxPend PROC
;;;283    /*$PAGE*/
;;;284    void  *OSMboxPend (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;285                       INT32U     timeout,
;;;286                       INT8U     *perr)
;;;287    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;288        void      *pmsg;
;;;289    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;290        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;291    #endif
;;;292    
;;;293    
;;;294    
;;;295    #ifdef OS_SAFETY_CRITICAL
;;;296        if (perr == (INT8U *)0) {
;;;297            OS_SAFETY_CRITICAL_EXCEPTION();
;;;298            return ((void *)0);
;;;299        }
;;;300    #endif
;;;301    
;;;302    #if OS_ARG_CHK_EN > 0u
;;;303        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;304            *perr = OS_ERR_PEVENT_NULL;
;;;305            return ((void *)0);
;;;306        }
;;;307    #endif
;;;308        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000e  7828              LDRB     r0,[r5,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L4.30|
;;;309            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;310            return ((void *)0);
000018  2000              MOVS     r0,#0
                  |L4.26|
;;;311        }
;;;312        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;313            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;314            return ((void *)0);
;;;315        }
;;;316        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;317            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;318            return ((void *)0);
;;;319        }
;;;320        OS_ENTER_CRITICAL();
;;;321        pmsg = pevent->OSEventPtr;
;;;322        if (pmsg != (void *)0) {                          /* See if there is already a message             */
;;;323            pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
;;;324            OS_EXIT_CRITICAL();
;;;325            *perr = OS_ERR_NONE;
;;;326            return (pmsg);                                /* Return the message received (or NULL)         */
;;;327        }
;;;328        OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
;;;329        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;330        OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
;;;331        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;332        OS_EXIT_CRITICAL();
;;;333        OS_Sched();                                       /* Find next highest priority task ready to run  */
;;;334        OS_ENTER_CRITICAL();
;;;335        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;336            case OS_STAT_PEND_OK:
;;;337                 pmsg =  OSTCBCur->OSTCBMsg;
;;;338                *perr =  OS_ERR_NONE;
;;;339                 break;
;;;340    
;;;341            case OS_STAT_PEND_ABORT:
;;;342                 pmsg = (void *)0;
;;;343                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;344                 break;
;;;345    
;;;346            case OS_STAT_PEND_TO:
;;;347            default:
;;;348                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;349                 pmsg = (void *)0;
;;;350                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;351                 break;
;;;352        }
;;;353        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;354        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;355        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;356    #if (OS_EVENT_MULTI_EN > 0u)
;;;357        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;358    #endif
;;;359        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;360        OS_EXIT_CRITICAL();
;;;361        return (pmsg);                                    /* Return received message                       */
;;;362    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.30|
00001e  4837              LDR      r0,|L4.252|
000020  7800              LDRB     r0,[r0,#0]            ;312  ; OSIntNesting
000022  b118              CBZ      r0,|L4.44|
000024  2002              MOVS     r0,#2                 ;313
000026  7020              STRB     r0,[r4,#0]            ;313
000028  2000              MOVS     r0,#0                 ;314
00002a  e7f6              B        |L4.26|
                  |L4.44|
00002c  4834              LDR      r0,|L4.256|
00002e  7800              LDRB     r0,[r0,#0]            ;316  ; OSLockNesting
000030  b118              CBZ      r0,|L4.58|
000032  200d              MOVS     r0,#0xd               ;317
000034  7020              STRB     r0,[r4,#0]            ;317
000036  2000              MOVS     r0,#0                 ;318
000038  e7ef              B        |L4.26|
                  |L4.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4680              MOV      r8,r0                 ;320
000040  686e              LDR      r6,[r5,#4]            ;321
000042  b146              CBZ      r6,|L4.86|
000044  2000              MOVS     r0,#0                 ;323
000046  6068              STR      r0,[r5,#4]            ;323
000048  4640              MOV      r0,r8                 ;324
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;325
000050  7020              STRB     r0,[r4,#0]            ;325
000052  4630              MOV      r0,r6                 ;326
000054  e7e1              B        |L4.26|
                  |L4.86|
000056  482b              LDR      r0,|L4.260|
000058  6800              LDR      r0,[r0,#0]            ;328  ; OSTCBCur
00005a  f8900034          LDRB     r0,[r0,#0x34]         ;328
00005e  f0400002          ORR      r0,r0,#2              ;328
000062  4928              LDR      r1,|L4.260|
000064  6809              LDR      r1,[r1,#0]            ;328  ; OSTCBCur
000066  f8810034          STRB     r0,[r1,#0x34]         ;328
00006a  2000              MOVS     r0,#0                 ;329
00006c  4925              LDR      r1,|L4.260|
00006e  6809              LDR      r1,[r1,#0]            ;329  ; OSTCBCur
000070  f8810035          STRB     r0,[r1,#0x35]         ;329
000074  4823              LDR      r0,|L4.260|
000076  6800              LDR      r0,[r0,#0]            ;330  ; OSTCBCur
000078  6307              STR      r7,[r0,#0x30]         ;330
00007a  4628              MOV      r0,r5                 ;331
00007c  f7fffffe          BL       OS_EventTaskWait
000080  4640              MOV      r0,r8                 ;332
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  f7fffffe          BL       OS_Sched
00008a  f7fffffe          BL       OS_CPU_SR_Save
00008e  4680              MOV      r8,r0                 ;334
000090  481c              LDR      r0,|L4.260|
000092  6800              LDR      r0,[r0,#0]            ;335  ; OSTCBCur
000094  f8900035          LDRB     r0,[r0,#0x35]         ;335
000098  b120              CBZ      r0,|L4.164|
00009a  2801              CMP      r0,#1                 ;335
00009c  d00d              BEQ      |L4.186|
00009e  2802              CMP      r0,#2                 ;335
0000a0  d10a              BNE      |L4.184|
0000a2  e005              B        |L4.176|
                  |L4.164|
0000a4  4817              LDR      r0,|L4.260|
0000a6  6800              LDR      r0,[r0,#0]            ;337  ; OSTCBCur
0000a8  6a46              LDR      r6,[r0,#0x24]         ;337
0000aa  2000              MOVS     r0,#0                 ;338
0000ac  7020              STRB     r0,[r4,#0]            ;338
0000ae  e00d              B        |L4.204|
                  |L4.176|
0000b0  2600              MOVS     r6,#0                 ;342
0000b2  200e              MOVS     r0,#0xe               ;343
0000b4  7020              STRB     r0,[r4,#0]            ;343
0000b6  e009              B        |L4.204|
                  |L4.184|
0000b8  bf00              NOP                            ;346
                  |L4.186|
0000ba  4629              MOV      r1,r5                 ;348
0000bc  4811              LDR      r0,|L4.260|
0000be  6800              LDR      r0,[r0,#0]            ;348  ; OSTCBCur
0000c0  f7fffffe          BL       OS_EventTaskRemove
0000c4  2600              MOVS     r6,#0                 ;349
0000c6  200a              MOVS     r0,#0xa               ;350
0000c8  7020              STRB     r0,[r4,#0]            ;350
0000ca  bf00              NOP                            ;351
                  |L4.204|
0000cc  bf00              NOP                            ;339
0000ce  2000              MOVS     r0,#0                 ;353
0000d0  490c              LDR      r1,|L4.260|
0000d2  6809              LDR      r1,[r1,#0]            ;353  ; OSTCBCur
0000d4  f8810034          STRB     r0,[r1,#0x34]         ;353
0000d8  490a              LDR      r1,|L4.260|
0000da  6809              LDR      r1,[r1,#0]            ;354  ; OSTCBCur
0000dc  f8810035          STRB     r0,[r1,#0x35]         ;354
0000e0  4908              LDR      r1,|L4.260|
0000e2  6809              LDR      r1,[r1,#0]            ;355  ; OSTCBCur
0000e4  61c8              STR      r0,[r1,#0x1c]         ;355
0000e6  4907              LDR      r1,|L4.260|
0000e8  6809              LDR      r1,[r1,#0]            ;357  ; OSTCBCur
0000ea  6208              STR      r0,[r1,#0x20]         ;357
0000ec  4905              LDR      r1,|L4.260|
0000ee  6809              LDR      r1,[r1,#0]            ;359  ; OSTCBCur
0000f0  6248              STR      r0,[r1,#0x24]         ;359
0000f2  4640              MOV      r0,r8                 ;360
0000f4  f7fffffe          BL       OS_CPU_SR_Restore
0000f8  4630              MOV      r0,r6                 ;361
0000fa  e78e              B        |L4.26|
;;;363    /*$PAGE*/
                          ENDP

                  |L4.252|
                          DCD      OSIntNesting
                  |L4.256|
                          DCD      OSLockNesting
                  |L4.260|
                          DCD      OSTCBCur

                          AREA ||i.OSMboxPendAbort||, CODE, READONLY, ALIGN=1

                  OSMboxPendAbort PROC
;;;396    #if OS_MBOX_PEND_ABORT_EN > 0u
;;;397    INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;398                            INT8U      opt,
;;;399                            INT8U     *perr)
;;;400    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;401        INT8U      nbr_tasks;
;;;402    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;403        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;404    #endif
;;;405    
;;;406    
;;;407    
;;;408    #ifdef OS_SAFETY_CRITICAL
;;;409        if (perr == (INT8U *)0) {
;;;410            OS_SAFETY_CRITICAL_EXCEPTION();
;;;411            return (0u);
;;;412        }
;;;413    #endif
;;;414    
;;;415    #if OS_ARG_CHK_EN > 0u
;;;416        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;417            *perr = OS_ERR_PEVENT_NULL;
;;;418            return (0u);
;;;419        }
;;;420    #endif
;;;421        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L5.30|
;;;422            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;423            return (0u);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;424        }
;;;425        OS_ENTER_CRITICAL();
;;;426        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
;;;427            nbr_tasks = 0u;
;;;428            switch (opt) {
;;;429                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;430                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
;;;431                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;432                         nbr_tasks++;
;;;433                     }
;;;434                     break;
;;;435    
;;;436                case OS_PEND_OPT_NONE:
;;;437                default:                                       /* No,  ready HPT       waiting on mailbox  */
;;;438                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;439                     nbr_tasks++;
;;;440                     break;
;;;441            }
;;;442            OS_EXIT_CRITICAL();
;;;443            OS_Sched();                                        /* Find HPT ready to run                    */
;;;444            *perr = OS_ERR_PEND_ABORT;
;;;445            return (nbr_tasks);
;;;446        }
;;;447        OS_EXIT_CRITICAL();
;;;448        *perr = OS_ERR_NONE;
;;;449        return (0u);                                           /* No tasks waiting on mailbox              */
;;;450    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;425
000024  7aa0              LDRB     r0,[r4,#0xa]          ;426
000026  b320              CBZ      r0,|L5.114|
000028  2600              MOVS     r6,#0                 ;427
00002a  b17f              CBZ      r7,|L5.76|
00002c  2f01              CMP      r7,#1                 ;428
00002e  d10c              BNE      |L5.74|
000030  e007              B        |L5.66|
                  |L5.50|
000032  2302              MOVS     r3,#2                 ;431
000034  461a              MOV      r2,r3                 ;431
000036  2100              MOVS     r1,#0                 ;431
000038  4620              MOV      r0,r4                 ;431
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;432
000040  b2c6              UXTB     r6,r0                 ;432
                  |L5.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;430
000044  2800              CMP      r0,#0                 ;430
000046  d1f4              BNE      |L5.50|
000048  e009              B        |L5.94|
                  |L5.74|
00004a  bf00              NOP                            ;436
                  |L5.76|
00004c  2302              MOVS     r3,#2                 ;438
00004e  461a              MOV      r2,r3                 ;438
000050  2100              MOVS     r1,#0                 ;438
000052  4620              MOV      r0,r4                 ;438
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;439
00005a  b2c6              UXTB     r6,r0                 ;439
00005c  bf00              NOP                            ;440
                  |L5.94|
00005e  bf00              NOP                            ;434
000060  4640              MOV      r0,r8                 ;442
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;444
00006c  7028              STRB     r0,[r5,#0]            ;444
00006e  4630              MOV      r0,r6                 ;445
000070  e7d3              B        |L5.26|
                  |L5.114|
000072  4640              MOV      r0,r8                 ;447
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;448
00007a  7028              STRB     r0,[r5,#0]            ;448
00007c  bf00              NOP                            ;449
00007e  e7cc              B        |L5.26|
;;;451    #endif
                          ENDP


                          AREA ||i.OSMboxPost||, CODE, READONLY, ALIGN=1

                  OSMboxPost PROC
;;;476    #if OS_MBOX_POST_EN > 0u
;;;477    INT8U  OSMboxPost (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;478                       void      *pmsg)
;;;479    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;480    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;481        OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;482    #endif
;;;483    
;;;484    
;;;485    
;;;486    #if OS_ARG_CHK_EN > 0u
;;;487        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;488            return (OS_ERR_PEVENT_NULL);
;;;489        }
;;;490        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;491            return (OS_ERR_POST_NULL_PTR);
;;;492        }
;;;493    #endif
;;;494        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000008  7820              LDRB     r0,[r4,#0]
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L6.18|
;;;495            return (OS_ERR_EVENT_TYPE);
00000e  2001              MOVS     r0,#1
                  |L6.16|
;;;496        }
;;;497        OS_ENTER_CRITICAL();
;;;498        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;499                                                          /* Ready HPT waiting on event                    */
;;;500            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;501            OS_EXIT_CRITICAL();
;;;502            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;503            return (OS_ERR_NONE);
;;;504        }
;;;505        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;506            OS_EXIT_CRITICAL();
;;;507            return (OS_ERR_MBOX_FULL);
;;;508        }
;;;509        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;510        OS_EXIT_CRITICAL();
;;;511        return (OS_ERR_NONE);
;;;512    }
000010  bd70              POP      {r4-r6,pc}
                  |L6.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;497
000018  7aa0              LDRB     r0,[r4,#0xa]          ;498
00001a  b160              CBZ      r0,|L6.54|
00001c  2300              MOVS     r3,#0                 ;500
00001e  2202              MOVS     r2,#2                 ;500
000020  4629              MOV      r1,r5                 ;500
000022  4620              MOV      r0,r4                 ;500
000024  f7fffffe          BL       OS_EventTaskRdy
000028  4630              MOV      r0,r6                 ;501
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  f7fffffe          BL       OS_Sched
000032  2000              MOVS     r0,#0                 ;503
000034  e7ec              B        |L6.16|
                  |L6.54|
000036  6860              LDR      r0,[r4,#4]            ;505
000038  b120              CBZ      r0,|L6.68|
00003a  4630              MOV      r0,r6                 ;506
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  2014              MOVS     r0,#0x14              ;507
000042  e7e5              B        |L6.16|
                  |L6.68|
000044  6065              STR      r5,[r4,#4]            ;509
000046  4630              MOV      r0,r6                 ;510
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2000              MOVS     r0,#0                 ;511
00004e  e7df              B        |L6.16|
;;;513    #endif
                          ENDP


                          AREA ||i.OSMboxPostOpt||, CODE, READONLY, ALIGN=1

                  OSMboxPostOpt PROC
;;;548    #if OS_MBOX_POST_OPT_EN > 0u
;;;549    INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;550                          void      *pmsg,
;;;551                          INT8U      opt)
;;;552    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;553    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;554        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;555    #endif
;;;556    
;;;557    
;;;558    
;;;559    #if OS_ARG_CHK_EN > 0u
;;;560        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;561            return (OS_ERR_PEVENT_NULL);
;;;562        }
;;;563        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;564            return (OS_ERR_POST_NULL_PTR);
;;;565        }
;;;566    #endif
;;;567        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L7.24|
;;;568            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L7.20|
;;;569        }
;;;570        OS_ENTER_CRITICAL();
;;;571        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;572            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;573                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
;;;574                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;575                }
;;;576            } else {                                      /* No,  Post to HPT waiting on mbox              */
;;;577                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;578            }
;;;579            OS_EXIT_CRITICAL();
;;;580            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
;;;581                OS_Sched();                               /* Find HPT ready to run                         */
;;;582            }
;;;583            return (OS_ERR_NONE);
;;;584        }
;;;585        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;586            OS_EXIT_CRITICAL();
;;;587            return (OS_ERR_MBOX_FULL);
;;;588        }
;;;589        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;590        OS_EXIT_CRITICAL();
;;;591        return (OS_ERR_NONE);
;;;592    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L7.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4607              MOV      r7,r0                 ;570
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;571
000020  b1e8              CBZ      r0,|L7.94|
000022  f0150f01          TST      r5,#1                 ;572
000026  d00a              BEQ      |L7.62|
000028  e005              B        |L7.54|
                  |L7.42|
00002a  2300              MOVS     r3,#0                 ;574
00002c  2202              MOVS     r2,#2                 ;574
00002e  4631              MOV      r1,r6                 ;574
000030  4620              MOV      r0,r4                 ;574
000032  f7fffffe          BL       OS_EventTaskRdy
                  |L7.54|
000036  7aa0              LDRB     r0,[r4,#0xa]          ;573
000038  2800              CMP      r0,#0                 ;573
00003a  d1f6              BNE      |L7.42|
00003c  e005              B        |L7.74|
                  |L7.62|
00003e  2300              MOVS     r3,#0                 ;577
000040  2202              MOVS     r2,#2                 ;577
000042  4631              MOV      r1,r6                 ;577
000044  4620              MOV      r0,r4                 ;577
000046  f7fffffe          BL       OS_EventTaskRdy
                  |L7.74|
00004a  4638              MOV      r0,r7                 ;579
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  f0150f04          TST      r5,#4                 ;580
000054  d101              BNE      |L7.90|
000056  f7fffffe          BL       OS_Sched
                  |L7.90|
00005a  2000              MOVS     r0,#0                 ;583
00005c  e7da              B        |L7.20|
                  |L7.94|
00005e  6860              LDR      r0,[r4,#4]            ;585
000060  b120              CBZ      r0,|L7.108|
000062  4638              MOV      r0,r7                 ;586
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2014              MOVS     r0,#0x14              ;587
00006a  e7d3              B        |L7.20|
                  |L7.108|
00006c  6066              STR      r6,[r4,#4]            ;589
00006e  4638              MOV      r0,r7                 ;590
000070  f7fffffe          BL       OS_CPU_SR_Restore
000074  2000              MOVS     r0,#0                 ;591
000076  e7cd              B        |L7.20|
;;;593    #endif
                          ENDP


                          AREA ||i.OSMboxQuery||, CODE, READONLY, ALIGN=1

                  OSMboxQuery PROC
;;;614    #if OS_MBOX_QUERY_EN > 0u
;;;615    INT8U  OSMboxQuery (OS_EVENT      *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;616                        OS_MBOX_DATA  *p_mbox_data)
;;;617    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;618        INT8U       i;
;;;619        OS_PRIO    *psrc;
;;;620        OS_PRIO    *pdest;
;;;621    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;622        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;623    #endif
;;;624    
;;;625    
;;;626    
;;;627    #if OS_ARG_CHK_EN > 0u
;;;628        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;629            return (OS_ERR_PEVENT_NULL);
;;;630        }
;;;631        if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
;;;632            return (OS_ERR_PDATA_NULL);
;;;633        }
;;;634    #endif
;;;635        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L8.24|
;;;636            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L8.20|
;;;637        }
;;;638        OS_ENTER_CRITICAL();
;;;639        p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
;;;640        psrc                    = &pevent->OSEventTbl[0];
;;;641        pdest                   = &p_mbox_data->OSEventTbl[0];
;;;642        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;643            *pdest++ = *psrc++;
;;;644        }
;;;645        p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
;;;646        OS_EXIT_CRITICAL();
;;;647        return (OS_ERR_NONE);
;;;648    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L8.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;638
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;639
000020  7228              STRB     r0,[r5,#8]            ;639
000022  f104070b          ADD      r7,r4,#0xb            ;640
000026  f1050804          ADD      r8,r5,#4              ;641
00002a  2600              MOVS     r6,#0                 ;642
00002c  e005              B        |L8.58|
                  |L8.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;643
000032  f8080b01          STRB     r0,[r8],#1            ;643
000036  1c70              ADDS     r0,r6,#1              ;642
000038  b2c6              UXTB     r6,r0                 ;642
                  |L8.58|
00003a  2e04              CMP      r6,#4                 ;642
00003c  d3f7              BCC      |L8.46|
00003e  6860              LDR      r0,[r4,#4]            ;645
000040  6028              STR      r0,[r5,#0]            ;645
000042  4648              MOV      r0,r9                 ;646
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;647
00004a  e7e3              B        |L8.20|
;;;649    #endif                                                     /* OS_MBOX_QUERY_EN                         */
                          ENDP

