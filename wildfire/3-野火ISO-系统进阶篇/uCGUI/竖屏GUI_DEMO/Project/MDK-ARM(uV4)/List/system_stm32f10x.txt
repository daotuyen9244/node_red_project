; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_stm32f10x.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\User\bsp\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;302    */  
;;;303    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;304    {
;;;305    #ifdef SYSCLK_FREQ_HSE
;;;306      SetSysClockToHSE();
;;;307    #elif defined SYSCLK_FREQ_24MHz
;;;308      SetSysClockTo24();
;;;309    #elif defined SYSCLK_FREQ_36MHz
;;;310      SetSysClockTo36();
;;;311    #elif defined SYSCLK_FREQ_48MHz
;;;312      SetSysClockTo48();
;;;313    #elif defined SYSCLK_FREQ_56MHz
;;;314      SetSysClockTo56();  
;;;315    #elif defined SYSCLK_FREQ_72MHz
;;;316      SetSysClockTo72();
000002  f7fffffe          BL       SetSysClockTo72
;;;317    #endif
;;;318     
;;;319      /* 如果上面的define均没有选择，那么HSI用于系统时钟源（复位后的缺省值） */
;;;320    }
000006  bd10              POP      {r4,pc}
;;;321    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;860    */   
;;;861    static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;862    {
;;;863      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;864      
;;;865      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;866      /* Enable HSE */    
;;;867      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  4832              LDR      r0,|L2.212|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4403080          ORR      r0,r0,#0x10000
000010  4930              LDR      r1,|L2.212|
000012  6008              STR      r0,[r1,#0]
;;;868     
;;;869      /* Wait till HSE is ready and if Time out is reached exit */
;;;870      do
000014  bf00              NOP      
                  |L2.22|
;;;871      {
;;;872        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000016  482f              LDR      r0,|L2.212|
000018  6800              LDR      r0,[r0,#0]
00001a  f4003000          AND      r0,r0,#0x20000
00001e  9000              STR      r0,[sp,#0]
;;;873        StartUpCounter++;  
000020  9801              LDR      r0,[sp,#4]
000022  1c40              ADDS     r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;874      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000026  9800              LDR      r0,[sp,#0]
000028  b918              CBNZ     r0,|L2.50|
00002a  9801              LDR      r0,[sp,#4]
00002c  f5b06fa0          CMP      r0,#0x500
000030  d1f1              BNE      |L2.22|
                  |L2.50|
;;;875    
;;;876      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000032  4828              LDR      r0,|L2.212|
000034  6800              LDR      r0,[r0,#0]
000036  f4103f00          TST      r0,#0x20000
00003a  d002              BEQ      |L2.66|
;;;877      {
;;;878        HSEStatus = (uint32_t)0x01;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L2.70|
                  |L2.66|
;;;879      }
;;;880      else
;;;881      {
;;;882        HSEStatus = (uint32_t)0x00;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L2.70|
;;;883      }  
;;;884    
;;;885      if (HSEStatus == (uint32_t)0x01)
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  d142              BNE      |L2.210|
;;;886      {
;;;887        /* Enable Prefetch Buffer */
;;;888        FLASH->ACR |= FLASH_ACR_PRFTBE;
00004c  4822              LDR      r0,|L2.216|
00004e  6800              LDR      r0,[r0,#0]
000050  f0400010          ORR      r0,r0,#0x10
000054  4920              LDR      r1,|L2.216|
000056  6008              STR      r0,[r1,#0]
;;;889    
;;;890        /* Flash 2 wait state */
;;;891        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200003          BIC      r0,r0,#3
000060  6008              STR      r0,[r1,#0]
;;;892        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f0400002          ORR      r0,r0,#2
00006a  6008              STR      r0,[r1,#0]
;;;893    
;;;894     
;;;895        /* HCLK = SYSCLK */
;;;896        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00006c  4819              LDR      r0,|L2.212|
00006e  6840              LDR      r0,[r0,#4]
000070  4918              LDR      r1,|L2.212|
000072  6048              STR      r0,[r1,#4]
;;;897          
;;;898        /* PCLK2 = HCLK */
;;;899        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]
000078  6048              STR      r0,[r1,#4]
;;;900        
;;;901        /* PCLK1 = HCLK */
;;;902        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00007a  4608              MOV      r0,r1
00007c  6840              LDR      r0,[r0,#4]
00007e  f4406080          ORR      r0,r0,#0x400
000082  6048              STR      r0,[r1,#4]
;;;903    
;;;904    #ifdef STM32F10X_CL
;;;905        /* Configure PLLs ------------------------------------------------------*/
;;;906        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;907        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;908            
;;;909        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;910                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;911        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;912                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;913      
;;;914        /* Enable PLL2 */
;;;915        RCC->CR |= RCC_CR_PLL2ON;
;;;916        /* Wait till PLL2 is ready */
;;;917        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;918        {
;;;919        }
;;;920        
;;;921       
;;;922        /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;923        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;924        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;925                                RCC_CFGR_PLLMULL9); 
;;;926    #else    
;;;927        /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;928        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000084  4608              MOV      r0,r1
000086  6840              LDR      r0,[r0,#4]
000088  f420107c          BIC      r0,r0,#0x3f0000
00008c  6048              STR      r0,[r1,#4]
;;;929                                            RCC_CFGR_PLLMULL));
;;;930        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00008e  4608              MOV      r0,r1
000090  6840              LDR      r0,[r0,#4]
000092  f44010e8          ORR      r0,r0,#0x1d0000
000096  6048              STR      r0,[r1,#4]
;;;931    #endif /* STM32F10X_CL */
;;;932    
;;;933        /* Enable PLL */
;;;934        RCC->CR |= RCC_CR_PLLON;
000098  4608              MOV      r0,r1
00009a  6800              LDR      r0,[r0,#0]
00009c  f0407080          ORR      r0,r0,#0x1000000
0000a0  6008              STR      r0,[r1,#0]
;;;935    
;;;936        /* Wait till PLL is ready */
;;;937        while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000a2  bf00              NOP      
                  |L2.164|
0000a4  480b              LDR      r0,|L2.212|
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f0107f00          TST      r0,#0x2000000
0000ac  d0fa              BEQ      |L2.164|
;;;938        {
;;;939        }
;;;940        
;;;941        /* Select PLL as system clock source */
;;;942        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000ae  4809              LDR      r0,|L2.212|
0000b0  6840              LDR      r0,[r0,#4]
0000b2  f0200003          BIC      r0,r0,#3
0000b6  4907              LDR      r1,|L2.212|
0000b8  6048              STR      r0,[r1,#4]
;;;943        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000ba  4608              MOV      r0,r1
0000bc  6840              LDR      r0,[r0,#4]
0000be  f0400002          ORR      r0,r0,#2
0000c2  6048              STR      r0,[r1,#4]
;;;944    
;;;945        /* Wait till PLL is used as system clock source */
;;;946        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000c4  bf00              NOP      
                  |L2.198|
0000c6  4803              LDR      r0,|L2.212|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f000000c          AND      r0,r0,#0xc
0000ce  2808              CMP      r0,#8
0000d0  d1f9              BNE      |L2.198|
                  |L2.210|
;;;947        {
;;;948        }
;;;949      }
;;;950      else
;;;951      { /* If HSE fails to start-up, the application will have wrong clock 
;;;952             configuration. User can add here some code to deal with this error */
;;;953      }
;;;954    }
0000d2  bd0c              POP      {r2,r3,pc}
;;;955    #endif
                          ENDP

                  |L2.212|
                          DCD      0x40021000
                  |L2.216|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;186    */
;;;187    void SystemCoreClockUpdate (void)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000002  2100              MOVS     r1,#0
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
;;;190    
;;;191    #ifdef  STM32F10X_CL
;;;192      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;193    #endif /* STM32F10X_CL */
;;;194    
;;;195    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;196      uint32_t prediv1factor = 0;
;;;197    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;198        
;;;199      /* 读取SYSCLK时钟源 */
;;;200      tmp = RCC->CFGR & RCC_CFGR_SWS;
000008  4b21              LDR      r3,|L3.144|
00000a  685b              LDR      r3,[r3,#4]
00000c  f003010c          AND      r1,r3,#0xc
;;;201      
;;;202      switch (tmp)
000010  b121              CBZ      r1,|L3.28|
000012  2904              CMP      r1,#4
000014  d006              BEQ      |L3.36|
000016  2908              CMP      r1,#8
000018  d128              BNE      |L3.108|
00001a  e007              B        |L3.44|
                  |L3.28|
;;;203      {
;;;204        case 0x00:  /* HSI 用于系统时钟 */
;;;205          SystemCoreClock = HSI_VALUE;
00001c  4b1d              LDR      r3,|L3.148|
00001e  4c1e              LDR      r4,|L3.152|
000020  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;206          break;
000022  e027              B        |L3.116|
                  |L3.36|
;;;207        case 0x04:  /* HSE 用于系统时钟 */
;;;208          SystemCoreClock = HSE_VALUE;
000024  4b1b              LDR      r3,|L3.148|
000026  4c1c              LDR      r4,|L3.152|
000028  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;209          break;
00002a  e023              B        |L3.116|
                  |L3.44|
;;;210        case 0x08:  /* PLL 用于系统时钟 */
;;;211    
;;;212          /* 读取PLL时钟源和倍频因子 */
;;;213          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00002c  4b18              LDR      r3,|L3.144|
00002e  685b              LDR      r3,[r3,#4]
000030  f4031070          AND      r0,r3,#0x3c0000
;;;214          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000034  4b16              LDR      r3,|L3.144|
000036  685b              LDR      r3,[r3,#4]
000038  f4033280          AND      r2,r3,#0x10000
;;;215          
;;;216    #ifndef STM32F10X_CL      
;;;217          pllmull = ( pllmull >> 18) + 2;
00003c  2302              MOVS     r3,#2
00003e  eb034090          ADD      r0,r3,r0,LSR #18
;;;218          
;;;219          if (pllsource == 0x00)
000042  b922              CBNZ     r2,|L3.78|
;;;220          {
;;;221            /* HSI振荡器时钟除以2用于PLL时钟入口 */
;;;222            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
000044  4b15              LDR      r3,|L3.156|
000046  4343              MULS     r3,r0,r3
000048  4c13              LDR      r4,|L3.152|
00004a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00004c  e00d              B        |L3.106|
                  |L3.78|
;;;223          }
;;;224          else
;;;225          {
;;;226     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;227           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;228           /* HSE振荡器时钟用于PREDIV1时钟入口 */
;;;229           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;230     #else
;;;231            /* HSE用于PLL时钟入口 */
;;;232            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
00004e  4b10              LDR      r3,|L3.144|
000050  685b              LDR      r3,[r3,#4]
000052  f4133f00          TST      r3,#0x20000
000056  d004              BEQ      |L3.98|
;;;233            {/* HSE振荡器时钟除以2 */
;;;234              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
000058  4b10              LDR      r3,|L3.156|
00005a  4343              MULS     r3,r0,r3
00005c  4c0e              LDR      r4,|L3.152|
00005e  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000060  e003              B        |L3.106|
                  |L3.98|
;;;235            }
;;;236            else
;;;237            {
;;;238              SystemCoreClock = HSE_VALUE * pllmull;
000062  4b0c              LDR      r3,|L3.148|
000064  4343              MULS     r3,r0,r3
000066  4c0c              LDR      r4,|L3.152|
000068  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L3.106|
;;;239            }
;;;240     #endif
;;;241          }
;;;242    #else
;;;243          pllmull = pllmull >> 18;
;;;244          
;;;245          if (pllmull != 0x0D)
;;;246          {
;;;247             pllmull += 2;
;;;248          }
;;;249          else
;;;250          { /* PLL倍频因子 = PLL PLL multiplication factor = PLL input clock * 6.5 */
;;;251            pllmull = 13 / 2; 
;;;252          }
;;;253                
;;;254          if (pllsource == 0x00)
;;;255          {
;;;256            /* HSI 振荡器时钟除以2用于PLL时钟入口 */
;;;257            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;258          }
;;;259          else
;;;260          {/* PREDIV1用于PLL时钟入口 */
;;;261            
;;;262            /* 读取PREDIV1时钟源和分频因子 */
;;;263            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;264            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;265            
;;;266            if (prediv1source == 0)
;;;267            { 
;;;268              /* HSE振荡器时钟用于PREDIV1时钟入口 */
;;;269              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;270            }
;;;271            else
;;;272            {/* PLL2时钟用于PREDIV1时钟入口 */
;;;273              
;;;274              /* 读取PREDIV2分频因子和PLL2倍频因子 */
;;;275              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;276              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;277              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;278            }
;;;279          }
;;;280    #endif /* STM32F10X_CL */ 
;;;281          break;
00006a  e003              B        |L3.116|
                  |L3.108|
;;;282    
;;;283        default:
;;;284          SystemCoreClock = HSI_VALUE;
00006c  4b09              LDR      r3,|L3.148|
00006e  4c0a              LDR      r4,|L3.152|
000070  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;285          break;
000072  bf00              NOP      
                  |L3.116|
000074  bf00              NOP                            ;206
;;;286      }
;;;287      
;;;288      /* 计算HCLK时钟频率 */
;;;289      /* 读取HCLK预分频器 */
;;;290      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000076  4b06              LDR      r3,|L3.144|
000078  685b              LDR      r3,[r3,#4]
00007a  f3c31303          UBFX     r3,r3,#4,#4
00007e  4c08              LDR      r4,|L3.160|
000080  5ce1              LDRB     r1,[r4,r3]
;;;291      /* HCLK时钟频率 */
;;;292      SystemCoreClock >>= tmp;  
000082  4b05              LDR      r3,|L3.152|
000084  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
000086  40cb              LSRS     r3,r3,r1
000088  4c03              LDR      r4,|L3.152|
00008a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;293    }
00008c  bd10              POP      {r4,pc}
;;;294    
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      0x40021000
                  |L3.148|
                          DCD      0x007a1200
                  |L3.152|
                          DCD      SystemCoreClock
                  |L3.156|
                          DCD      0x003d0900
                  |L3.160|
                          DCD      AHBPrescTable

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;120    */  
;;;121    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123      /* 复位RCC时钟配置到缺省状态(用于调试)，设置HSION位 */
;;;124      RCC->CR |= (uint32_t)0x00000001;
000002  4813              LDR      r0,|L4.80|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  4911              LDR      r1,|L4.80|
00000c  6008              STR      r0,[r1,#0]
;;;125    
;;;126      /* 复位SW、HPRE、PPRE1、PPRE2, ADCPRE和MCO位 */
;;;127    #ifndef STM32F10X_CL
;;;128      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  4910              LDR      r1,|L4.84|
000014  4008              ANDS     r0,r0,r1
000016  490e              LDR      r1,|L4.80|
000018  6048              STR      r0,[r1,#4]
;;;129    #else
;;;130      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;131    #endif /* STM32F10X_CL */   
;;;132      
;;;133      /* 复位HSEON、CSSON和PLLON位 */
;;;134      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  490e              LDR      r1,|L4.88|
000020  4008              ANDS     r0,r0,r1
000022  490b              LDR      r1,|L4.80|
000024  6008              STR      r0,[r1,#0]
;;;135    
;;;136      /* 复位HSEBYP位 */
;;;137      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;138    
;;;139      /* 复位PLLSRC、PLLXTPRE、PLLMUL和USBPRE/OTGFSPRE位 */
;;;140      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000030  4608              MOV      r0,r1
000032  6840              LDR      r0,[r0,#4]
000034  f42000fe          BIC      r0,r0,#0x7f0000
000038  6048              STR      r0,[r1,#4]
;;;141    
;;;142    #ifdef STM32F10X_CL
;;;143      /* 复位PLL2ON和PLL3ON位 */
;;;144      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;145    
;;;146      /* 禁止所有的中断，清除中断标志 */
;;;147      RCC->CIR = 0x00FF0000;
;;;148    
;;;149      /* 复位CFGR2寄存器 */
;;;150      RCC->CFGR2 = 0x00000000;
;;;151    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;152      /* 禁止所有的中断并清除中断标志 */
;;;153      RCC->CIR = 0x009F0000;
;;;154    
;;;155      /* 复位CFGR2寄存器 */
;;;156      RCC->CFGR2 = 0x00000000;      
;;;157    #else
;;;158      /* 禁止所有的中断并清除中断标志 */
;;;159      RCC->CIR = 0x009F0000;
00003a  f44f001f          MOV      r0,#0x9f0000
00003e  6088              STR      r0,[r1,#8]
;;;160    #endif /* STM32F10X_CL */
;;;161        
;;;162    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;163      #ifdef DATA_IN_ExtSRAM
;;;164        SystemInit_ExtMemCtl(); 
;;;165      #endif /* DATA_IN_ExtSRAM */
;;;166    #endif 
;;;167    
;;;168      /* 配置系统时钟频率，HCLK、PCLK2和PCLK1预分频器 */
;;;169      /* 配置Flash锁存周期，使能预取缓冲 */
;;;170      SetSysClock();
000040  f7fffffe          BL       SetSysClock
;;;171    
;;;172    #ifdef VECT_TAB_SRAM
;;;173      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET;	/* 向量表定位在内部SRAM */
;;;174    #else
;;;175      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* 向量表定位在内部Flash */
000044  f04f6000          MOV      r0,#0x8000000
000048  4904              LDR      r1,|L4.92|
00004a  6008              STR      r0,[r1,#0]
;;;176    #endif 
;;;177    }
00004c  bd10              POP      {r4,pc}
;;;178    
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      0x40021000
                  |L4.84|
                          DCD      0xf8ff0000
                  |L4.88|
                          DCD      0xfef6ffff
                  |L4.92|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
