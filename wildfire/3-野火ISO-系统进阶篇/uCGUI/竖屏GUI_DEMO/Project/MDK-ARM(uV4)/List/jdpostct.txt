; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdpostct.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdpostct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jdpostct.c]
                          THUMB

                          AREA ||i.jinit_d_post_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_post_controller PROC
;;;254    GLOBAL(void)
;;;255    jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;256    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;257      my_post_ptr post;
;;;258    
;;;259      post = (my_post_ptr)
000008  6860              LDR      r0,[r4,#4]
00000a  221c              MOVS     r2,#0x1c
00000c  2101              MOVS     r1,#1
00000e  6803              LDR      r3,[r0,#0]
000010  4620              MOV      r0,r4
000012  4798              BLX      r3
000014  4605              MOV      r5,r0
;;;260        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				SIZEOF(my_post_controller));
;;;262      cinfo->post = (struct jpeg_d_post_controller *) post;
000016  f8c451b0          STR      r5,[r4,#0x1b0]
;;;263      post->pub.start_pass = start_pass_dpost;
00001a  4816              LDR      r0,|L1.116|
00001c  6028              STR      r0,[r5,#0]
;;;264      post->whole_image = NULL;	/* flag for no virtual arrays */
00001e  2000              MOVS     r0,#0
000020  60a8              STR      r0,[r5,#8]
;;;265      post->buffer = NULL;		/* flag for no strip buffer */
000022  60e8              STR      r0,[r5,#0xc]
;;;266    
;;;267      /* Create the quantization buffer, if needed */
;;;268      if (cinfo->quantize_colors) {
000024  6d60              LDR      r0,[r4,#0x54]
000026  b318              CBZ      r0,|L1.112|
;;;269        /* The buffer strip height is max_v_samp_factor, which is typically
;;;270         * an efficient number of rows for upsampling to return.
;;;271         * (In the presence of output rescaling, we might want to be smarter?)
;;;272         */
;;;273        post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
000028  f8d40138          LDR      r0,[r4,#0x138]
00002c  6128              STR      r0,[r5,#0x10]
;;;274        if (need_full_buffer) {
00002e  b1a6              CBZ      r6,|L1.90|
;;;275          /* Two-pass color quantization: need full-image storage. */
;;;276          /* We round up the number of rows to a multiple of the strip height. */
;;;277    #ifdef QUANT_2PASS_SUPPORTED
;;;278          post->whole_image = (*cinfo->mem->request_virt_sarray)
000030  6929              LDR      r1,[r5,#0x10]
000032  6f60              LDR      r0,[r4,#0x74]
000034  f7fffffe          BL       jround_up
000038  4607              MOV      r7,r0
00003a  6928              LDR      r0,[r5,#0x10]
00003c  e9cd7000          STRD     r7,r0,[sp,#0]
000040  6fa1              LDR      r1,[r4,#0x78]
000042  6f20              LDR      r0,[r4,#0x70]
000044  fb00f301          MUL      r3,r0,r1
000048  6860              LDR      r0,[r4,#4]
00004a  2200              MOVS     r2,#0
00004c  2101              MOVS     r1,#1
00004e  f8d0c010          LDR      r12,[r0,#0x10]
000052  4620              MOV      r0,r4
000054  47e0              BLX      r12
000056  60a8              STR      r0,[r5,#8]
000058  e00a              B        |L1.112|
                  |L1.90|
;;;279    	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
;;;280    	 cinfo->output_width * cinfo->out_color_components,
;;;281    	 (JDIMENSION) jround_up((long) cinfo->output_height,
;;;282    				(long) post->strip_height),
;;;283    	 post->strip_height);
;;;284    #else
;;;285          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
;;;286    #endif /* QUANT_2PASS_SUPPORTED */
;;;287        } else {
;;;288          /* One-pass color quantization: just make a strip buffer. */
;;;289          post->buffer = (*cinfo->mem->alloc_sarray)
00005a  6fa1              LDR      r1,[r4,#0x78]
00005c  6f20              LDR      r0,[r4,#0x70]
00005e  fb00f201          MUL      r2,r0,r1
000062  692b              LDR      r3,[r5,#0x10]
000064  6860              LDR      r0,[r4,#4]
000066  2101              MOVS     r1,#1
000068  6887              LDR      r7,[r0,#8]
00006a  4620              MOV      r0,r4
00006c  47b8              BLX      r7
00006e  60e8              STR      r0,[r5,#0xc]
                  |L1.112|
;;;290    	((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;291    	 cinfo->output_width * cinfo->out_color_components,
;;;292    	 post->strip_height);
;;;293        }
;;;294      }
;;;295    }
000070  e8bd81fc          POP      {r2-r8,pc}
                          ENDP

                  |L1.116|
                          DCD      start_pass_dpost

                          AREA ||i.post_process_1pass||, CODE, READONLY, ALIGN=1

                  post_process_1pass PROC
;;;125    METHODDEF(void)
;;;126    post_process_1pass (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;127    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;128    		    JDIMENSION in_row_groups_avail,
;;;129    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;130    		    JDIMENSION out_rows_avail)
;;;131    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4693              MOV      r11,r2
00000c  e9dd5a13          LDRD     r5,r10,[sp,#0x4c]
000010  f8dd9048          LDR      r9,[sp,#0x48]
;;;132      my_post_ptr post = (my_post_ptr) cinfo->post;
000014  f8d461b0          LDR      r6,[r4,#0x1b0]
;;;133      JDIMENSION num_rows, max_rows;
;;;134    
;;;135      /* Fill the buffer, but not more than what we can dump out in one go. */
;;;136      /* Note we rely on the upsampler to detect bottom of image. */
;;;137      max_rows = out_rows_avail - *out_row_ctr;
000018  6828              LDR      r0,[r5,#0]
00001a  ebaa0700          SUB      r7,r10,r0
;;;138      if (max_rows > post->strip_height)
00001e  6930              LDR      r0,[r6,#0x10]
000020  42b8              CMP      r0,r7
000022  d200              BCS      |L2.38|
;;;139        max_rows = post->strip_height;
000024  6937              LDR      r7,[r6,#0x10]
                  |L2.38|
;;;140      num_rows = 0;
000026  2000              MOVS     r0,#0
000028  9004              STR      r0,[sp,#0x10]
;;;141      (*cinfo->upsample->upsample) (cinfo,
00002a  a904              ADD      r1,sp,#0x10
00002c  68f0              LDR      r0,[r6,#0xc]
00002e  e88d0083          STM      sp,{r0,r1,r7}
000032  f8d401c4          LDR      r0,[r4,#0x1c4]
000036  f8d0c004          LDR      r12,[r0,#4]
00003a  465a              MOV      r2,r11
00003c  4641              MOV      r1,r8
00003e  4620              MOV      r0,r4
000040  9b08              LDR      r3,[sp,#0x20]
000042  47e0              BLX      r12
;;;142    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;143    		post->buffer, &num_rows, max_rows);
;;;144      /* Quantize and emit data. */
;;;145      (*cinfo->cquantize->color_quantize) (cinfo,
000044  6828              LDR      r0,[r5,#0]
000046  eb090280          ADD      r2,r9,r0,LSL #2
00004a  68f1              LDR      r1,[r6,#0xc]
00004c  f8d401cc          LDR      r0,[r4,#0x1cc]
000050  f8d0c004          LDR      r12,[r0,#4]
000054  4620              MOV      r0,r4
000056  9b04              LDR      r3,[sp,#0x10]
000058  47e0              BLX      r12
;;;146    		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
;;;147      *out_row_ctr += num_rows;
00005a  6828              LDR      r0,[r5,#0]
00005c  9904              LDR      r1,[sp,#0x10]
00005e  4408              ADD      r0,r0,r1
000060  6028              STR      r0,[r5,#0]
;;;148    }
000062  b009              ADD      sp,sp,#0x24
000064  e8bd8ff0          POP      {r4-r11,pc}
;;;149    
                          ENDP


                          AREA ||i.post_process_2pass||, CODE, READONLY, ALIGN=1

                  post_process_2pass PROC
;;;203    METHODDEF(void)
;;;204    post_process_2pass (j_decompress_ptr cinfo,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;205    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;206    		    JDIMENSION in_row_groups_avail,
;;;207    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;208    		    JDIMENSION out_rows_avail)
;;;209    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
00000c  f8dd802c          LDR      r8,[sp,#0x2c]
;;;210      my_post_ptr post = (my_post_ptr) cinfo->post;
000010  f8d641b0          LDR      r4,[r6,#0x1b0]
;;;211      JDIMENSION num_rows, max_rows;
;;;212    
;;;213      GUI_USE_PARA(in_row_groups_avail);
000014  bf00              NOP      
;;;214      GUI_USE_PARA(in_row_group_ctr);
000016  bf00              NOP      
;;;215      GUI_USE_PARA(input_buf);
000018  bf00              NOP      
;;;216      /* Reposition virtual buffer if at start of strip. */
;;;217      if (post->next_row == 0) {
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  b950              CBNZ     r0,|L3.52|
;;;218        post->buffer = (*cinfo->mem->access_virt_sarray)
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  e9d43204          LDRD     r3,r2,[r4,#0x10]
000026  68a1              LDR      r1,[r4,#8]
000028  6870              LDR      r0,[r6,#4]
00002a  f8d0c01c          LDR      r12,[r0,#0x1c]
00002e  4630              MOV      r0,r6
000030  47e0              BLX      r12
000032  60e0              STR      r0,[r4,#0xc]
                  |L3.52|
;;;219    	((j_common_ptr) cinfo, post->whole_image,
;;;220    	 post->starting_row, post->strip_height, FALSE);
;;;221      }
;;;222    
;;;223      /* Determine number of rows to emit. */
;;;224      num_rows = post->strip_height - post->next_row; /* available in strip */
000034  69a1              LDR      r1,[r4,#0x18]
000036  6920              LDR      r0,[r4,#0x10]
000038  1a45              SUBS     r5,r0,r1
;;;225      max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
00003a  f8d81000          LDR      r1,[r8,#0]
00003e  980c              LDR      r0,[sp,#0x30]
000040  1a47              SUBS     r7,r0,r1
;;;226      if (num_rows > max_rows)
000042  42bd              CMP      r5,r7
000044  d900              BLS      |L3.72|
;;;227        num_rows = max_rows;
000046  463d              MOV      r5,r7
                  |L3.72|
;;;228      /* We have to check bottom of image here, can't depend on upsampler. */
;;;229      max_rows = cinfo->output_height - post->starting_row;
000048  6f70              LDR      r0,[r6,#0x74]
00004a  6961              LDR      r1,[r4,#0x14]
00004c  1a47              SUBS     r7,r0,r1
;;;230      if (num_rows > max_rows)
00004e  42bd              CMP      r5,r7
000050  d900              BLS      |L3.84|
;;;231        num_rows = max_rows;
000052  463d              MOV      r5,r7
                  |L3.84|
;;;232    
;;;233      /* Quantize and emit data. */
;;;234      (*cinfo->cquantize->color_quantize) (cinfo,
000054  69a3              LDR      r3,[r4,#0x18]
000056  68e0              LDR      r0,[r4,#0xc]
000058  eb000183          ADD      r1,r0,r3,LSL #2
00005c  f8d83000          LDR      r3,[r8,#0]
000060  980a              LDR      r0,[sp,#0x28]
000062  eb000283          ADD      r2,r0,r3,LSL #2
000066  f8d601cc          LDR      r0,[r6,#0x1cc]
00006a  462b              MOV      r3,r5
00006c  f8d0c004          LDR      r12,[r0,#4]
000070  4630              MOV      r0,r6
000072  47e0              BLX      r12
;;;235    		post->buffer + post->next_row, output_buf + *out_row_ctr,
;;;236    		(int) num_rows);
;;;237      *out_row_ctr += num_rows;
000074  f8d80000          LDR      r0,[r8,#0]
000078  4428              ADD      r0,r0,r5
00007a  f8c80000          STR      r0,[r8,#0]
;;;238    
;;;239      /* Advance if we filled the strip. */
;;;240      post->next_row += num_rows;
00007e  69a0              LDR      r0,[r4,#0x18]
000080  4428              ADD      r0,r0,r5
000082  61a0              STR      r0,[r4,#0x18]
;;;241      if (post->next_row >= post->strip_height) {
000084  6921              LDR      r1,[r4,#0x10]
000086  69a0              LDR      r0,[r4,#0x18]
000088  4288              CMP      r0,r1
00008a  d305              BCC      |L3.152|
;;;242        post->starting_row += post->strip_height;
00008c  e9d41004          LDRD     r1,r0,[r4,#0x10]
000090  4408              ADD      r0,r0,r1
000092  6160              STR      r0,[r4,#0x14]
;;;243        post->next_row = 0;
000094  2000              MOVS     r0,#0
000096  61a0              STR      r0,[r4,#0x18]
                  |L3.152|
;;;244      }
;;;245    }
000098  e8bd8ff8          POP      {r3-r11,pc}
;;;246    
                          ENDP


                          AREA ||i.post_process_prepass||, CODE, READONLY, ALIGN=1

                  post_process_prepass PROC
;;;157    METHODDEF(void)
;;;158    post_process_prepass (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;159    		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;160    		      JDIMENSION in_row_groups_avail,
;;;161    		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;162    		      JDIMENSION out_rows_avail)
;;;163    {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  468b              MOV      r11,r1
00000a  e9dd8a11          LDRD     r8,r10,[sp,#0x44]
00000e  f8dd9040          LDR      r9,[sp,#0x40]
;;;164      my_post_ptr post = (my_post_ptr) cinfo->post;
000012  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;165      JDIMENSION old_next_row, num_rows;
;;;166    
;;;167      GUI_USE_PARA(out_rows_avail);
000016  bf00              NOP      
;;;168      GUI_USE_PARA(output_buf);
000018  bf00              NOP      
;;;169      /* Reposition virtual buffer if at start of strip. */
;;;170      if (post->next_row == 0) {
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  b950              CBNZ     r0,|L4.52|
;;;171        post->buffer = (*cinfo->mem->access_virt_sarray)
00001e  2001              MOVS     r0,#1
000020  9000              STR      r0,[sp,#0]
000022  e9d43204          LDRD     r3,r2,[r4,#0x10]
000026  68a1              LDR      r1,[r4,#8]
000028  6868              LDR      r0,[r5,#4]
00002a  f8d0c01c          LDR      r12,[r0,#0x1c]
00002e  4628              MOV      r0,r5
000030  47e0              BLX      r12
000032  60e0              STR      r0,[r4,#0xc]
                  |L4.52|
;;;172    	((j_common_ptr) cinfo, post->whole_image,
;;;173    	 post->starting_row, post->strip_height, TRUE);
;;;174      }
;;;175    
;;;176      /* Upsample some data (up to a strip height's worth). */
;;;177      old_next_row = post->next_row;
000034  69a6              LDR      r6,[r4,#0x18]
;;;178      (*cinfo->upsample->upsample) (cinfo,
000036  f1040118          ADD      r1,r4,#0x18
00003a  e9d42003          LDRD     r2,r0,[r4,#0xc]
00003e  e9cd2100          STRD     r2,r1,[sp,#0]
000042  9002              STR      r0,[sp,#8]
000044  f8d501c4          LDR      r0,[r5,#0x1c4]
000048  f8d0c004          LDR      r12,[r0,#4]
00004c  4659              MOV      r1,r11
00004e  4628              MOV      r0,r5
000050  e9dd2305          LDRD     r2,r3,[sp,#0x14]
000054  47e0              BLX      r12
;;;179    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;180    		post->buffer, &post->next_row, post->strip_height);
;;;181    
;;;182      /* Allow quantizer to scan new data.  No data is emitted, */
;;;183      /* but we advance out_row_ctr so outer loop can tell when we're done. */
;;;184      if (post->next_row > old_next_row) {
000056  69a0              LDR      r0,[r4,#0x18]
000058  42b0              CMP      r0,r6
00005a  d911              BLS      |L4.128|
;;;185        num_rows = post->next_row - old_next_row;
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  1b87              SUBS     r7,r0,r6
;;;186        (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
000060  68e0              LDR      r0,[r4,#0xc]
000062  eb000186          ADD      r1,r0,r6,LSL #2
000066  f8d501cc          LDR      r0,[r5,#0x1cc]
00006a  463b              MOV      r3,r7
00006c  2200              MOVS     r2,#0
00006e  f8d0c004          LDR      r12,[r0,#4]
000072  4628              MOV      r0,r5
000074  47e0              BLX      r12
;;;187    					 (JSAMPARRAY) NULL, (int) num_rows);
;;;188        *out_row_ctr += num_rows;
000076  f8d80000          LDR      r0,[r8,#0]
00007a  4438              ADD      r0,r0,r7
00007c  f8c80000          STR      r0,[r8,#0]
                  |L4.128|
;;;189      }
;;;190    
;;;191      /* Advance if we filled the strip. */
;;;192      if (post->next_row >= post->strip_height) {
000080  6921              LDR      r1,[r4,#0x10]
000082  69a0              LDR      r0,[r4,#0x18]
000084  4288              CMP      r0,r1
000086  d305              BCC      |L4.148|
;;;193        post->starting_row += post->strip_height;
000088  e9d41004          LDRD     r1,r0,[r4,#0x10]
00008c  4408              ADD      r0,r0,r1
00008e  6160              STR      r0,[r4,#0x14]
;;;194        post->next_row = 0;
000090  2000              MOVS     r0,#0
000092  61a0              STR      r0,[r4,#0x18]
                  |L4.148|
;;;195      }
;;;196    }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd8ff0          POP      {r4-r11,pc}
;;;197    
                          ENDP


                          AREA ||i.start_pass_dpost||, CODE, READONLY, ALIGN=2

                  start_pass_dpost PROC
;;;72     METHODDEF(void)
;;;73     start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
000000  b5f8              PUSH     {r3-r7,lr}
;;;74     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;75       my_post_ptr post = (my_post_ptr) cinfo->post;
000006  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;76     
;;;77       switch (pass_mode) {
00000a  b126              CBZ      r6,|L5.22|
00000c  2e02              CMP      r6,#2
00000e  d024              BEQ      |L5.90|
000010  2e03              CMP      r6,#3
000012  d12e              BNE      |L5.114|
000014  e015              B        |L5.66|
                  |L5.22|
;;;78       case JBUF_PASS_THRU:
;;;79         if (cinfo->quantize_colors) {
000016  6d68              LDR      r0,[r5,#0x54]
000018  b170              CBZ      r0,|L5.56|
;;;80           /* Single-pass processing with color quantization. */
;;;81           post->pub.post_process_data = post_process_1pass;
00001a  481c              LDR      r0,|L5.140|
00001c  6060              STR      r0,[r4,#4]
;;;82           /* We could be doing buffered-image output before starting a 2-pass
;;;83            * color quantization; in that case, jinit_d_post_controller did not
;;;84            * allocate a strip buffer.  Use the virtual-array buffer as workspace.
;;;85            */
;;;86           if (post->buffer == NULL) {
00001e  68e0              LDR      r0,[r4,#0xc]
000020  b970              CBNZ     r0,|L5.64|
;;;87     	post->buffer = (*cinfo->mem->access_virt_sarray)
000022  2001              MOVS     r0,#1
000024  9000              STR      r0,[sp,#0]
000026  6923              LDR      r3,[r4,#0x10]
000028  68a1              LDR      r1,[r4,#8]
00002a  6868              LDR      r0,[r5,#4]
00002c  2200              MOVS     r2,#0
00002e  69c7              LDR      r7,[r0,#0x1c]
000030  4628              MOV      r0,r5
000032  47b8              BLX      r7
000034  60e0              STR      r0,[r4,#0xc]
000036  e003              B        |L5.64|
                  |L5.56|
;;;88     	  ((j_common_ptr) cinfo, post->whole_image,
;;;89     	   (JDIMENSION) 0, post->strip_height, TRUE);
;;;90           }
;;;91         } else {
;;;92           /* For single-pass processing without color quantization,
;;;93            * I have no work to do; just call the upsampler directly.
;;;94            */
;;;95           post->pub.post_process_data = cinfo->upsample->upsample;
000038  f8d501c4          LDR      r0,[r5,#0x1c4]
00003c  6840              LDR      r0,[r0,#4]
00003e  6060              STR      r0,[r4,#4]
                  |L5.64|
;;;96         }
;;;97         break;
000040  e01f              B        |L5.130|
                  |L5.66|
;;;98     #ifdef QUANT_2PASS_SUPPORTED
;;;99       case JBUF_SAVE_AND_PASS:
;;;100        /* First pass of 2-pass quantization */
;;;101        if (post->whole_image == NULL)
000042  68a0              LDR      r0,[r4,#8]
000044  b930              CBNZ     r0,|L5.84|
;;;102          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000046  2004              MOVS     r0,#4
000048  6829              LDR      r1,[r5,#0]
00004a  6148              STR      r0,[r1,#0x14]
00004c  6828              LDR      r0,[r5,#0]
00004e  6801              LDR      r1,[r0,#0]
000050  4628              MOV      r0,r5
000052  4788              BLX      r1
                  |L5.84|
;;;103        post->pub.post_process_data = post_process_prepass;
000054  480e              LDR      r0,|L5.144|
000056  6060              STR      r0,[r4,#4]
;;;104        break;
000058  e013              B        |L5.130|
                  |L5.90|
;;;105      case JBUF_CRANK_DEST:
;;;106        /* Second pass of 2-pass quantization */
;;;107        if (post->whole_image == NULL)
00005a  68a0              LDR      r0,[r4,#8]
00005c  b930              CBNZ     r0,|L5.108|
;;;108          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
00005e  2004              MOVS     r0,#4
000060  6829              LDR      r1,[r5,#0]
000062  6148              STR      r0,[r1,#0x14]
000064  6828              LDR      r0,[r5,#0]
000066  6801              LDR      r1,[r0,#0]
000068  4628              MOV      r0,r5
00006a  4788              BLX      r1
                  |L5.108|
;;;109        post->pub.post_process_data = post_process_2pass;
00006c  4809              LDR      r0,|L5.148|
00006e  6060              STR      r0,[r4,#4]
;;;110        break;
000070  e007              B        |L5.130|
                  |L5.114|
;;;111    #endif /* QUANT_2PASS_SUPPORTED */
;;;112      default:
;;;113        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000072  2004              MOVS     r0,#4
000074  6829              LDR      r1,[r5,#0]
000076  6148              STR      r0,[r1,#0x14]
000078  6828              LDR      r0,[r5,#0]
00007a  6801              LDR      r1,[r0,#0]
00007c  4628              MOV      r0,r5
00007e  4788              BLX      r1
;;;114        break;
000080  bf00              NOP      
                  |L5.130|
000082  bf00              NOP                            ;97
;;;115      }
;;;116      post->starting_row = post->next_row = 0;
000084  2000              MOVS     r0,#0
000086  61a0              STR      r0,[r4,#0x18]
000088  6160              STR      r0,[r4,#0x14]
;;;117    }
00008a  bdf8              POP      {r3-r7,pc}
;;;118    
                          ENDP

                  |L5.140|
                          DCD      post_process_1pass
                  |L5.144|
                          DCD      post_process_prepass
                  |L5.148|
                          DCD      post_process_2pass
