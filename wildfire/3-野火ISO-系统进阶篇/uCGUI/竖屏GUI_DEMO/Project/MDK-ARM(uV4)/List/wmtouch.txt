; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\wmtouch.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\WM\WMTouch.c]
                          THUMB

                          AREA ||i.WM_HandlePID||, CODE, READONLY, ALIGN=2

                  WM_HandlePID PROC
;;;157    */
;;;158    int WM_HandlePID(void) {
000000  b570              PUSH     {r4-r6,lr}
000002  b092              SUB      sp,sp,#0x48
;;;159      int r = 0;
000004  2600              MOVS     r6,#0
;;;160      WM_MESSAGE Msg;
;;;161      WM_CRITICAL_HANDLE CHWin;
;;;162      GUI_PID_STATE State = {0}, StateNew;
000006  2000              MOVS     r0,#0
000008  900a              STR      r0,[sp,#0x28]
00000a  900b              STR      r0,[sp,#0x2c]
00000c  900c              STR      r0,[sp,#0x30]
;;;163      GUI_PID_GetState(&StateNew);
00000e  a807              ADD      r0,sp,#0x1c
000010  f7fffffe          BL       GUI_PID_GetState
;;;164      WM_LOCK();
000014  f7fffffe          BL       GUI_Lock
;;;165      StateNew.x += GUI_OrgX;
000018  496c              LDR      r1,|L1.460|
00001a  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgX
00001e  9807              LDR      r0,[sp,#0x1c]
000020  4408              ADD      r0,r0,r1
000022  9007              STR      r0,[sp,#0x1c]
;;;166      StateNew.y += GUI_OrgY;
000024  496a              LDR      r1,|L1.464|
000026  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgY
00002a  9808              LDR      r0,[sp,#0x20]
00002c  4408              ADD      r0,r0,r1
00002e  9008              STR      r0,[sp,#0x20]
;;;167      WM__AddCriticalHandle(&CHWin);
000030  a80d              ADD      r0,sp,#0x34
000032  f7fffffe          BL       WM__AddCriticalHandle
;;;168      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
000036  4867              LDR      r0,|L1.468|
000038  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
00003a  9907              LDR      r1,[sp,#0x1c]
00003c  4288              CMP      r0,r1
00003e  d10a              BNE      |L1.86|
000040  4864              LDR      r0,|L1.468|
000042  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
000044  9908              LDR      r1,[sp,#0x20]
000046  4288              CMP      r0,r1
000048  d105              BNE      |L1.86|
00004a  4862              LDR      r0,|L1.468|
00004c  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
00004e  f89d1024          LDRB     r1,[sp,#0x24]
000052  4288              CMP      r0,r1
000054  d071              BEQ      |L1.314|
                  |L1.86|
;;;169        #if GUI_SUPPORT_CURSOR
;;;170          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
000056  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
00005a  f7fffffe          BL       GUI_CURSOR_SetPosition
;;;171        #endif
;;;172        CHWin.hWin = _Screen2Win(&StateNew);
00005e  a807              ADD      r0,sp,#0x1c
000060  f7fffffe          BL       _Screen2Win
000064  f8ad0038          STRH     r0,[sp,#0x38]
;;;173        #if GUI_SUPPORT_MOUSE
;;;174        /* Send WM_MOUSEOVER_END Message */
;;;175        if (WM__CHWinMouseOver.hWin && (WM__CHWinMouseOver.hWin != CHWin.hWin)) {
;;;176          if (WM__IsInModalArea(WM__CHWinMouseOver.hWin)) {
;;;177            /* Do not send messages to disabled windows */
;;;178            if (WM__IsEnabled(WM__CHWinMouseOver.hWin)) {
;;;179              State      = StateNew;
;;;180              Msg.MsgId  = WM_MOUSEOVER_END;
;;;181              Msg.Data.p = (void*)&State;
;;;182              WM__SendTouchMessage(WM__CHWinMouseOver.hWin, &Msg);
;;;183              WM__CHWinMouseOver.hWin = 0;
;;;184            }
;;;185          }
;;;186        }
;;;187        #endif
;;;188        if (WM__IsInModalArea(CHWin.hWin)) {
000068  f9bd0038          LDRSH    r0,[sp,#0x38]
00006c  f7fffffe          BL       WM__IsInModalArea
000070  2800              CMP      r0,#0
000072  d07c              BEQ      |L1.366|
;;;189          #if GUI_SUPPORT_MOUSE
;;;190            WM__CHWinMouseOver.hWin = CHWin.hWin;
;;;191          #endif
;;;192          /*
;;;193           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;194           */
;;;195          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
000074  4857              LDR      r0,|L1.468|
000076  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000078  f89d1024          LDRB     r1,[sp,#0x24]
00007c  4288              CMP      r0,r1
00007e  d043              BEQ      |L1.264|
000080  f8bd0038          LDRH     r0,[sp,#0x38]
000084  2800              CMP      r0,#0
000086  d03f              BEQ      |L1.264|
;;;196            GUI_PID_STATE PID_StateOld;
;;;197            WM_HWIN hWinOld;
;;;198            WM_PID_STATE_CHANGED_INFO Info;
;;;199            WM_Obj* pWin;
;;;200            pWin = WM_H2P(CHWin.hWin);
000088  f9bd0038          LDRSH    r0,[sp,#0x38]
00008c  f7fffffe          BL       GUI_ALLOC_h2p
000090  4605              MOV      r5,r0
;;;201            Info.State     = StateNew.Pressed;
000092  f89d0024          LDRB     r0,[sp,#0x24]
000096  f88d000c          STRB     r0,[sp,#0xc]
;;;202            Info.StatePrev = WM_PID__StateLast.Pressed;
00009a  484e              LDR      r0,|L1.468|
00009c  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
00009e  f88d000d          STRB     r0,[sp,#0xd]
;;;203            Info.x         = StateNew.x - pWin->Rect.x0;
0000a2  f9b51000          LDRSH    r1,[r5,#0]
0000a6  9807              LDR      r0,[sp,#0x1c]
0000a8  1a40              SUBS     r0,r0,r1
0000aa  9001              STR      r0,[sp,#4]
;;;204            Info.y         = StateNew.y - pWin->Rect.y0;
0000ac  f9b51002          LDRSH    r1,[r5,#2]
0000b0  9808              LDR      r0,[sp,#0x20]
0000b2  1a40              SUBS     r0,r0,r1
0000b4  9002              STR      r0,[sp,#8]
;;;205            Msg.Data.p = &Info;
0000b6  a801              ADD      r0,sp,#4
0000b8  9011              STR      r0,[sp,#0x44]
;;;206            Msg.MsgId  = WM_PID_STATE_CHANGED;
0000ba  2011              MOVS     r0,#0x11
0000bc  900f              STR      r0,[sp,#0x3c]
;;;207            /* Make sure that this routine does not react a second time on the same press event.
;;;208             * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
;;;209             */
;;;210            PID_StateOld = WM_PID__StateLast;
0000be  4a45              LDR      r2,|L1.468|
0000c0  ca07              LDM      r2,{r0-r2}
0000c2  ab04              ADD      r3,sp,#0x10
0000c4  c307              STM      r3!,{r0-r2}
;;;211            /* Make sure that in case of creating a new window over the current PID position
;;;212             * during the WM_PID_STATE_CHANGED message processing the old window
;;;213             * will be informed that it is no longer pressed.
;;;214             */
;;;215            WM_PID__StateLast.Pressed = StateNew.Pressed;
0000c6  f89d0024          LDRB     r0,[sp,#0x24]
0000ca  4942              LDR      r1,|L1.468|
0000cc  7208              STRB     r0,[r1,#8]
;;;216            if (State.Pressed) {
0000ce  f89d0030          LDRB     r0,[sp,#0x30]
0000d2  b138              CBZ      r0,|L1.228|
;;;217              hWinOld            = WM__CHWinLast.hWin;
0000d4  4840              LDR      r0,|L1.472|
0000d6  f9b04004          LDRSH    r4,[r0,#4]  ; WM__CHWinLast
;;;218              WM__CHWinLast.hWin = CHWin.hWin;
0000da  f8bd0038          LDRH     r0,[sp,#0x38]
0000de  493e              LDR      r1,|L1.472|
0000e0  8088              STRH     r0,[r1,#4]
0000e2  e000              B        |L1.230|
                  |L1.228|
;;;219            } else {
;;;220              hWinOld            = 0;
0000e4  2400              MOVS     r4,#0
                  |L1.230|
;;;221            }
;;;222            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
0000e6  f9bd0038          LDRSH    r0,[sp,#0x38]
0000ea  a90f              ADD      r1,sp,#0x3c
0000ec  f7fffffe          BL       WM__SendMessageIfEnabled
;;;223            /* Restore state for further processing */
;;;224            WM_PID__StateLast = PID_StateOld;
0000f0  4838              LDR      r0,|L1.468|
0000f2  a904              ADD      r1,sp,#0x10
0000f4  c90e              LDM      r1,{r1-r3}
0000f6  c00e              STM      r0!,{r1-r3}
;;;225            if (hWinOld) {
0000f8  b12c              CBZ      r4,|L1.262|
;;;226              /* hWinOld could be deleted during message processing. So check if it is a Window
;;;227               * before using it.
;;;228               */
;;;229              if (WM_IsWindow(hWinOld)) {
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       WM_IsWindow
000100  b108              CBZ      r0,|L1.262|
;;;230                WM__CHWinLast.hWin        = hWinOld;
000102  4835              LDR      r0,|L1.472|
000104  8084              STRH     r4,[r0,#4]
                  |L1.262|
;;;231              }
;;;232            }
;;;233          }
000106  bf00              NOP      
                  |L1.264|
;;;234          /*
;;;235           * Send WM_TOUCH message(s)
;;;236           * Note that we may have to send 2 touch messages.
;;;237           */
;;;238          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
000108  4832              LDR      r0,|L1.468|
00010a  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
00010c  f89d1024          LDRB     r1,[sp,#0x24]
000110  4308              ORRS     r0,r0,r1
000112  d04b              BEQ      |L1.428|
;;;239            Msg.MsgId = WM_TOUCH;
000114  200c              MOVS     r0,#0xc
000116  900f              STR      r0,[sp,#0x3c]
;;;240            r = 1;
000118  2601              MOVS     r6,#1
;;;241            /*
;;;242             * Tell window if it is no longer pressed
;;;243             * This happens for 2 possible reasons:
;;;244             * a) PID is released
;;;245             * b) PID is moved out
;;;246             */
;;;247            if (WM__CHWinLast.hWin != CHWin.hWin) {
00011a  482f              LDR      r0,|L1.472|
00011c  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinLast
000120  f9bd1038          LDRSH    r1,[sp,#0x38]
000124  4288              CMP      r0,r1
000126  d01d              BEQ      |L1.356|
;;;248              if (WM__CHWinLast.hWin != 0) {
000128  482b              LDR      r0,|L1.472|
00012a  8880              LDRH     r0,[r0,#4]  ; WM__CHWinLast
00012c  b1d0              CBZ      r0,|L1.356|
;;;249                if (StateNew.Pressed) {
00012e  f89d0024          LDRB     r0,[sp,#0x24]
000132  b118              CBZ      r0,|L1.316|
;;;250                  /* Moved out -> no longer in this window
;;;251                   * Send a NULL pointer as data
;;;252                   */
;;;253                  Msg.Data.p = NULL;
000134  2000              MOVS     r0,#0
000136  9011              STR      r0,[sp,#0x44]
000138  e00b              B        |L1.338|
                  |L1.314|
00013a  e03e              B        |L1.442|
                  |L1.316|
;;;254                } else {
;;;255                  /* Last window needs to know that it has been "Released"
;;;256                   * Send last coordinates 
;;;257                   */
;;;258                  State.x       = WM_PID__StateLast.x;
00013c  4825              LDR      r0,|L1.468|
00013e  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
000140  900a              STR      r0,[sp,#0x28]
;;;259                  State.y       = WM_PID__StateLast.y;
000142  4824              LDR      r0,|L1.468|
000144  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
000146  900b              STR      r0,[sp,#0x2c]
;;;260                  State.Pressed = 0;
000148  2000              MOVS     r0,#0
00014a  f88d0030          STRB     r0,[sp,#0x30]
;;;261                  Msg.Data.p = (void*)&State;
00014e  a80a              ADD      r0,sp,#0x28
000150  9011              STR      r0,[sp,#0x44]
                  |L1.338|
;;;262                }
;;;263                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;264                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
000152  4921              LDR      r1,|L1.472|
000154  f9b10004          LDRSH    r0,[r1,#4]  ; WM__CHWinLast
000158  a90f              ADD      r1,sp,#0x3c
00015a  f7fffffe          BL       WM__SendTouchMessage
;;;265                WM__CHWinLast.hWin = 0;
00015e  2000              MOVS     r0,#0
000160  491d              LDR      r1,|L1.472|
000162  8088              STRH     r0,[r1,#4]
                  |L1.356|
;;;266              }
;;;267            }
;;;268            /* Make sure that this routine does not react a second time on the same event.
;;;269             * This could happen if for example a dialog is executed during the WM_TOUCH message processing
;;;270             */
;;;271            WM_PID__StateLast.Pressed = StateNew.Pressed;
000164  f89d0024          LDRB     r0,[sp,#0x24]
000168  491a              LDR      r1,|L1.468|
00016a  7208              STRB     r0,[r1,#8]
;;;272            /* Sending WM_Touch to current window */
;;;273            if (CHWin.hWin) {
00016c  e000              B        |L1.368|
                  |L1.366|
00016e  e01d              B        |L1.428|
                  |L1.368|
000170  f8bd0038          LDRH     r0,[sp,#0x38]
000174  b1d0              CBZ      r0,|L1.428|
;;;274              /* convert screen into window coordinates */
;;;275              State = StateNew;
000176  a807              ADD      r0,sp,#0x1c
000178  c807              LDM      r0,{r0-r2}
00017a  ab0a              ADD      r3,sp,#0x28
00017c  c307              STM      r3!,{r0-r2}
;;;276              /* Remember window */
;;;277              if (State.Pressed) {
00017e  f89d0030          LDRB     r0,[sp,#0x30]
000182  b120              CBZ      r0,|L1.398|
;;;278                WM__CHWinLast.hWin = CHWin.hWin;
000184  f8bd0038          LDRH     r0,[sp,#0x38]
000188  4913              LDR      r1,|L1.472|
00018a  8088              STRH     r0,[r1,#4]
00018c  e007              B        |L1.414|
                  |L1.398|
;;;279              } else {
;;;280                /* Handle automatic capture release */
;;;281                if (WM__CaptureReleaseAuto) {
00018e  4813              LDR      r0,|L1.476|
000190  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
000192  b108              CBZ      r0,|L1.408|
;;;282                  WM_ReleaseCapture();
000194  f7fffffe          BL       WM_ReleaseCapture
                  |L1.408|
;;;283                }
;;;284                WM__CHWinLast.hWin = 0;
000198  2000              MOVS     r0,#0
00019a  490f              LDR      r1,|L1.472|
00019c  8088              STRH     r0,[r1,#4]
                  |L1.414|
;;;285              }
;;;286              Msg.Data.p = (void*)&State;
00019e  a80a              ADD      r0,sp,#0x28
0001a0  9011              STR      r0,[sp,#0x44]
;;;287              WM__SendTouchMessage(CHWin.hWin, &Msg);
0001a2  f9bd0038          LDRSH    r0,[sp,#0x38]
0001a6  a90f              ADD      r1,sp,#0x3c
0001a8  f7fffffe          BL       WM__SendTouchMessage
                  |L1.428|
;;;288            }
;;;289          }
;;;290          /*
;;;291           * Send WM_MOUSEOVER message
;;;292           */
;;;293          #if GUI_SUPPORT_MOUSE
;;;294          else {
;;;295            /* Send WM_MOUSEOVER Message */
;;;296            if (CHWin.hWin) {
;;;297              /* Do not send messages to disabled windows */
;;;298              if (WM__IsEnabled(CHWin.hWin)) {
;;;299                State      = StateNew;
;;;300                Msg.MsgId  = WM_MOUSEOVER;
;;;301                Msg.Data.p = (void*)&State;
;;;302                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;303              }
;;;304            }
;;;305          }
;;;306          #endif
;;;307        }
;;;308        /* Store the new state */
;;;309        WM_PID__StateLast = StateNew;
0001ac  4809              LDR      r0,|L1.468|
0001ae  a907              ADD      r1,sp,#0x1c
0001b0  c90e              LDM      r1,{r1-r3}
0001b2  c00e              STM      r0!,{r1-r3}
;;;310        WM_PID__SetPrevState(&StateNew);
0001b4  a807              ADD      r0,sp,#0x1c
0001b6  f7fffffe          BL       WM_PID__SetPrevState
                  |L1.442|
;;;311      }
;;;312      WM__RemoveCriticalHandle(&CHWin);
0001ba  a80d              ADD      r0,sp,#0x34
0001bc  f7fffffe          BL       WM__RemoveCriticalHandle
;;;313      WM_UNLOCK();
0001c0  f7fffffe          BL       GUI_Unlock
;;;314      return r;
0001c4  4630              MOV      r0,r6
;;;315    }
0001c6  b012              ADD      sp,sp,#0x48
0001c8  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

0001ca  0000              DCW      0x0000
                  |L1.460|
                          DCD      GUI_OrgX
                  |L1.464|
                          DCD      GUI_OrgY
                  |L1.468|
                          DCD      WM_PID__StateLast
                  |L1.472|
                          DCD      WM__CHWinLast
                  |L1.476|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||i.WM__IsInModalArea||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;48     */
;;;49     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;50       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000004  4809              LDR      r0,|L2.44|
000006  8880              LDRH     r0,[r0,#4]  ; WM__CHWinModal
000008  b158              CBZ      r0,|L2.34|
00000a  4808              LDR      r0,|L2.44|
00000c  f9b01004          LDRSH    r1,[r0,#4]  ; WM__CHWinModal
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       WM__IsAncestor
000016  b920              CBNZ     r0,|L2.34|
000018  4804              LDR      r0,|L2.44|
00001a  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinModal
00001e  42a0              CMP      r0,r4
000020  d101              BNE      |L2.38|
                  |L2.34|
;;;51         return 1;
000022  2001              MOVS     r0,#1
                  |L2.36|
;;;52       }
;;;53       return 0;
;;;54     }
000024  bd10              POP      {r4,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;53
000028  e7fc              B        |L2.36|
;;;55     
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      WM__CHWinModal

                          AREA ||i.WM__SendPIDMessage||, CODE, READONLY, ALIGN=1

                  WM__SendPIDMessage PROC
;;;65     */
;;;66     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;67       #if 1
;;;68       WM_HWIN iWin;
;;;69       WM_MESSAGE Msg;
;;;70       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
000006  e8950007          LDM      r5,{r0-r2}
00000a  e88d0007          STM      sp,{r0-r2}
;;;71       /* Send notification to all ancestors.
;;;72          We need to check if the window which has received the last message still exists,
;;;73          since it may have deleted itself and its parent as result of the message.
;;;74       */
;;;75       Msg.hWinSrc = hWin;
00000e  f8ad4006          STRH     r4,[sp,#6]
;;;76       Msg.MsgId   = WM_TOUCH_CHILD;
000012  200d              MOVS     r0,#0xd
000014  9000              STR      r0,[sp,#0]
;;;77       iWin = hWin;
000016  4626              MOV      r6,r4
;;;78       while (WM_IsWindow(iWin)) {
000018  e009              B        |L3.46|
                  |L3.26|
;;;79         iWin = WM_GetParent(iWin);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       WM_GetParent
000020  4606              MOV      r6,r0
;;;80         if (iWin) {
000022  b126              CBZ      r6,|L3.46|
;;;81           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
000024  9502              STR      r5,[sp,#8]
;;;82           WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
000026  4669              MOV      r1,sp
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L3.46|
00002e  4630              MOV      r0,r6                 ;78
000030  f7fffffe          BL       WM_IsWindow
000034  2800              CMP      r0,#0                 ;78
000036  d1f0              BNE      |L3.26|
;;;83         }
;;;84       }
;;;85       /* Send message to the affected window */
;;;86       WM__SendMessageIfEnabled(hWin, pMsg);
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       WM__SendMessageIfEnabled
;;;87       #else
;;;88       WM_MESSAGE Msg;
;;;89       /* Send message to the affected window */
;;;90       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;91       WM__SendMessageIfEnabled(hWin, &Msg);
;;;92       /* Send notification to all ancestors.
;;;93          We need to check if the window which has received the last message still exists,
;;;94          since it may have deleted itself and its parent as result of the message.
;;;95       */
;;;96       Msg.hWinSrc = hWin;
;;;97       Msg.MsgId   = WM_TOUCH_CHILD;
;;;98       while (WM_IsWindow(hWin)) {
;;;99         hWin = WM_GetParent(hWin);
;;;100        if (hWin) {
;;;101          Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;102          WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
;;;103        }
;;;104      }
;;;105      #endif
;;;106    }
000040  bdfe              POP      {r1-r7,pc}
;;;107    
                          ENDP


                          AREA ||i.WM__SendTouchMessage||, CODE, READONLY, ALIGN=1

                  WM__SendTouchMessage PROC
;;;111    */
;;;112    void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;113      GUI_PID_STATE* pState;
;;;114      pState     = (GUI_PID_STATE*)pMsg->Data.p;
000008  68ac              LDR      r4,[r5,#8]
;;;115      if (pState) {
00000a  b174              CBZ      r4,|L4.42|
;;;116        WM_Obj* pWin;
;;;117        pWin       = WM_H2P(hWin);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;118        pState->x -= pWin->Rect.x0;
000014  f9b61000          LDRSH    r1,[r6,#0]
000018  6820              LDR      r0,[r4,#0]
00001a  1a40              SUBS     r0,r0,r1
00001c  6020              STR      r0,[r4,#0]
;;;119        pState->y -= pWin->Rect.y0;
00001e  f9b61002          LDRSH    r1,[r6,#2]
000022  6860              LDR      r0,[r4,#4]
000024  1a40              SUBS     r0,r0,r1
000026  6060              STR      r0,[r4,#4]
;;;120      }
000028  bf00              NOP      
                  |L4.42|
;;;121      WM__SendPIDMessage(hWin, pMsg);
00002a  4629              MOV      r1,r5
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       WM__SendPIDMessage
;;;122    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP


                          AREA ||i._Screen2Win||, CODE, READONLY, ALIGN=2

                  _Screen2Win PROC
;;;133    */
;;;134    static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;135      if (WM__hCapture == 0) {
000004  4805              LDR      r0,|L5.28|
000006  8800              LDRH     r0,[r0,#0]  ; WM__hCapture
000008  b920              CBNZ     r0,|L5.20|
;;;136        return WM_Screen2hWin(pState->x, pState->y);
00000a  e9d40100          LDRD     r0,r1,[r4,#0]
00000e  f7fffffe          BL       WM_Screen2hWin
                  |L5.18|
;;;137      } 
;;;138      return WM__hCapture;
;;;139    }
000012  bd10              POP      {r4,pc}
                  |L5.20|
000014  4801              LDR      r0,|L5.28|
000016  f9b00000          LDRSH    r0,[r0,#0]            ;138  ; WM__hCapture
00001a  e7fa              B        |L5.18|
;;;140    
                          ENDP

                  |L5.28|
                          DCD      WM__hCapture

                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
