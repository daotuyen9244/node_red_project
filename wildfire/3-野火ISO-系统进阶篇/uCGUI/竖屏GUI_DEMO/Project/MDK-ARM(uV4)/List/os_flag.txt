; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_flag.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCOS-II\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagAccept||, CODE, READONLY, ALIGN=1

                  OSFlagAccept PROC
;;;91     #if OS_FLAG_ACCEPT_EN > 0u
;;;92     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;93                             OS_FLAGS      flags,
;;;94                             INT8U         wait_type,
;;;95                             INT8U        *perr)
;;;96     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;97         OS_FLAGS      flags_rdy;
;;;98         INT8U         result;
;;;99         BOOLEAN       consume;
;;;100    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;101        OS_CPU_SR     cpu_sr = 0u;
00000c  f04f0b00          MOV      r11,#0
;;;102    #endif
;;;103    
;;;104    
;;;105    
;;;106    #ifdef OS_SAFETY_CRITICAL
;;;107        if (perr == (INT8U *)0) {
;;;108            OS_SAFETY_CRITICAL_EXCEPTION();
;;;109            return ((OS_FLAGS)0);
;;;110        }
;;;111    #endif
;;;112    
;;;113    #if OS_ARG_CHK_EN > 0u
;;;114        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;115            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;116            return ((OS_FLAGS)0);
;;;117        }
;;;118    #endif
;;;119        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L1.32|
;;;120            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;121            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L1.28|
;;;122        }
;;;123        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;124        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;125            wait_type &= ~OS_FLAG_CONSUME;
;;;126            consume    = OS_TRUE;
;;;127        } else {
;;;128            consume    = OS_FALSE;
;;;129        }
;;;130    /*$PAGE*/
;;;131        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;132        OS_ENTER_CRITICAL();
;;;133        switch (wait_type) {
;;;134            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;135                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;136                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;137                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;138                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
;;;139                     }
;;;140                 } else {
;;;141                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;142                 }
;;;143                 OS_EXIT_CRITICAL();
;;;144                 break;
;;;145    
;;;146            case OS_FLAG_WAIT_SET_ANY:
;;;147                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;148                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;149                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;150                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
;;;151                     }
;;;152                 } else {
;;;153                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;154                 }
;;;155                 OS_EXIT_CRITICAL();
;;;156                 break;
;;;157    
;;;158    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;159            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;160                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;161                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;162                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;163                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;164                     }
;;;165                 } else {
;;;166                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;167                 }
;;;168                 OS_EXIT_CRITICAL();
;;;169                 break;
;;;170    
;;;171            case OS_FLAG_WAIT_CLR_ANY:
;;;172                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;173                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;174                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;175                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;176                     }
;;;177                 } else {
;;;178                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;179                 }
;;;180                 OS_EXIT_CRITICAL();
;;;181                 break;
;;;182    #endif
;;;183    
;;;184            default:
;;;185                 OS_EXIT_CRITICAL();
;;;186                 flags_rdy = (OS_FLAGS)0;
;;;187                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;188                 break;
;;;189        }
;;;190        return (flags_rdy);
;;;191    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.32|
000020  f0090a80          AND      r10,r9,#0x80          ;123
000024  f1ba0f00          CMP      r10,#0                ;124
000028  d004              BEQ      |L1.52|
00002a  f0290980          BIC      r9,r9,#0x80           ;125
00002e  f04f0801          MOV      r8,#1                 ;126
000032  e001              B        |L1.56|
                  |L1.52|
000034  f04f0800          MOV      r8,#0                 ;128
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;131
00003a  7030              STRB     r0,[r6,#0]            ;131
00003c  f7fffffe          BL       OS_CPU_SR_Save
000040  4683              MOV      r11,r0                ;132
000042  f1b90f00          CMP      r9,#0                 ;133
000046  d02c              BEQ      |L1.162|
000048  f1b90f01          CMP      r9,#1                 ;133
00004c  d03b              BEQ      |L1.198|
00004e  f1b90f02          CMP      r9,#2                 ;133
000052  d003              BEQ      |L1.92|
000054  f1b90f03          CMP      r9,#3                 ;133
000058  d146              BNE      |L1.232|
00005a  e011              B        |L1.128|
                  |L1.92|
00005c  8920              LDRH     r0,[r4,#8]            ;135
00005e  ea000507          AND      r5,r0,r7              ;135
000062  42bd              CMP      r5,r7                 ;136
000064  d106              BNE      |L1.116|
000066  f1b80f01          CMP      r8,#1                 ;137
00006a  d105              BNE      |L1.120|
00006c  8920              LDRH     r0,[r4,#8]            ;138
00006e  43a8              BICS     r0,r0,r5              ;138
000070  8120              STRH     r0,[r4,#8]            ;138
000072  e001              B        |L1.120|
                  |L1.116|
000074  2070              MOVS     r0,#0x70              ;141
000076  7030              STRB     r0,[r6,#0]            ;141
                  |L1.120|
000078  4658              MOV      r0,r11                ;143
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  e03a              B        |L1.246|
                  |L1.128|
000080  8920              LDRH     r0,[r4,#8]            ;147
000082  ea000507          AND      r5,r0,r7              ;147
000086  b135              CBZ      r5,|L1.150|
000088  f1b80f01          CMP      r8,#1                 ;149
00008c  d105              BNE      |L1.154|
00008e  8920              LDRH     r0,[r4,#8]            ;150
000090  43a8              BICS     r0,r0,r5              ;150
000092  8120              STRH     r0,[r4,#8]            ;150
000094  e001              B        |L1.154|
                  |L1.150|
000096  2070              MOVS     r0,#0x70              ;153
000098  7030              STRB     r0,[r6,#0]            ;153
                  |L1.154|
00009a  4658              MOV      r0,r11                ;155
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  e029              B        |L1.246|
                  |L1.162|
0000a2  8920              LDRH     r0,[r4,#8]            ;160
0000a4  ea270500          BIC      r5,r7,r0              ;160
0000a8  42bd              CMP      r5,r7                 ;161
0000aa  d106              BNE      |L1.186|
0000ac  f1b80f01          CMP      r8,#1                 ;162
0000b0  d105              BNE      |L1.190|
0000b2  8920              LDRH     r0,[r4,#8]            ;163
0000b4  4328              ORRS     r0,r0,r5              ;163
0000b6  8120              STRH     r0,[r4,#8]            ;163
0000b8  e001              B        |L1.190|
                  |L1.186|
0000ba  2070              MOVS     r0,#0x70              ;166
0000bc  7030              STRB     r0,[r6,#0]            ;166
                  |L1.190|
0000be  4658              MOV      r0,r11                ;168
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  e017              B        |L1.246|
                  |L1.198|
0000c6  8920              LDRH     r0,[r4,#8]            ;172
0000c8  ea270500          BIC      r5,r7,r0              ;172
0000cc  b135              CBZ      r5,|L1.220|
0000ce  f1b80f01          CMP      r8,#1                 ;174
0000d2  d105              BNE      |L1.224|
0000d4  8920              LDRH     r0,[r4,#8]            ;175
0000d6  4328              ORRS     r0,r0,r5              ;175
0000d8  8120              STRH     r0,[r4,#8]            ;175
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2070              MOVS     r0,#0x70              ;178
0000de  7030              STRB     r0,[r6,#0]            ;178
                  |L1.224|
0000e0  4658              MOV      r0,r11                ;180
0000e2  f7fffffe          BL       OS_CPU_SR_Restore
0000e6  e006              B        |L1.246|
                  |L1.232|
0000e8  4658              MOV      r0,r11                ;185
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2500              MOVS     r5,#0                 ;186
0000f0  206f              MOVS     r0,#0x6f              ;187
0000f2  7030              STRB     r0,[r6,#0]            ;187
0000f4  bf00              NOP                            ;188
                  |L1.246|
0000f6  bf00              NOP                            ;144
0000f8  4628              MOV      r0,r5                 ;190
0000fa  e78f              B        |L1.28|
;;;192    #endif
                          ENDP


                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;214    
;;;215    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216                                INT8U    *perr)
;;;217    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;218        OS_FLAG_GRP *pgrp;
;;;219    #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
;;;220        OS_CPU_SR    cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;221    #endif
;;;222    
;;;223    
;;;224    
;;;225    #ifdef OS_SAFETY_CRITICAL
;;;226        if (perr == (INT8U *)0) {
;;;227            OS_SAFETY_CRITICAL_EXCEPTION();
;;;228            return ((OS_FLAG_GRP *)0);
;;;229        }
;;;230    #endif
;;;231    
;;;232    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;233        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;234            OS_SAFETY_CRITICAL_EXCEPTION();
;;;235            return ((OS_FLAG_GRP *)0);
;;;236        }
;;;237    #endif
;;;238    
;;;239        if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00000a  4813              LDR      r0,|L2.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b120              CBZ      r0,|L2.26|
;;;240            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
000010  2010              MOVS     r0,#0x10
000012  7028              STRB     r0,[r5,#0]
;;;241            return ((OS_FLAG_GRP *)0);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;242        }
;;;243        OS_ENTER_CRITICAL();
;;;244        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;245        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;246                                                        /* Adjust free list                                */
;;;247            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;248            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;249            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;250            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;251    #if OS_FLAG_NAME_EN > 0u
;;;252            pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;253    #endif
;;;254            OS_EXIT_CRITICAL();
;;;255            *perr                = OS_ERR_NONE;
;;;256        } else {
;;;257            OS_EXIT_CRITICAL();
;;;258            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;259        }
;;;260        return (pgrp);                                  /* Return pointer to event flag group              */
;;;261    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;243
000020  480e              LDR      r0,|L2.92|
000022  6804              LDR      r4,[r0,#0]            ;244  ; OSFlagFreeList
000024  b184              CBZ      r4,|L2.72|
000026  6800              LDR      r0,[r0,#0]            ;247  ; OSFlagFreeList
000028  6840              LDR      r0,[r0,#4]            ;247
00002a  490c              LDR      r1,|L2.92|
00002c  6008              STR      r0,[r1,#0]            ;247  ; OSFlagFreeList
00002e  2005              MOVS     r0,#5                 ;248
000030  7020              STRB     r0,[r4,#0]            ;248
000032  8126              STRH     r6,[r4,#8]            ;249
000034  2000              MOVS     r0,#0                 ;250
000036  6060              STR      r0,[r4,#4]            ;250
000038  a009              ADR      r0,|L2.96|
00003a  60e0              STR      r0,[r4,#0xc]          ;252
00003c  4638              MOV      r0,r7                 ;254
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2000              MOVS     r0,#0                 ;255
000044  7028              STRB     r0,[r5,#0]            ;255
000046  e004              B        |L2.82|
                  |L2.72|
000048  4638              MOV      r0,r7                 ;257
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2072              MOVS     r0,#0x72              ;258
000050  7028              STRB     r0,[r5,#0]            ;258
                  |L2.82|
000052  4620              MOV      r0,r4                 ;260
000054  e7df              B        |L2.22|
;;;262    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      OSIntNesting
                  |L2.92|
                          DCD      OSFlagFreeList
                  |L2.96|
000060  3f00              DCB      "?",0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;300    #if OS_FLAG_DEL_EN > 0u
;;;301    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;302                             INT8U         opt,
;;;303                             INT8U        *perr)
;;;304    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;305        BOOLEAN       tasks_waiting;
;;;306        OS_FLAG_NODE *pnode;
;;;307        OS_FLAG_GRP  *pgrp_return;
;;;308    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;309        OS_CPU_SR     cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;310    #endif
;;;311    
;;;312    
;;;313    
;;;314    #ifdef OS_SAFETY_CRITICAL
;;;315        if (perr == (INT8U *)0) {
;;;316            OS_SAFETY_CRITICAL_EXCEPTION();
;;;317            return ((OS_FLAG_GRP *)0);
;;;318        }
;;;319    #endif
;;;320    
;;;321    #if OS_ARG_CHK_EN > 0u
;;;322        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;323            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;324            return (pgrp);
;;;325        }
;;;326    #endif
;;;327        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000e  4832              LDR      r0,|L3.216|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L3.30|
;;;328            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000014  200f              MOVS     r0,#0xf
000016  7028              STRB     r0,[r5,#0]
;;;329            return (pgrp);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;330        }
;;;331        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;332            *perr = OS_ERR_EVENT_TYPE;
;;;333            return (pgrp);
;;;334        }
;;;335        OS_ENTER_CRITICAL();
;;;336        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;337            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;338        } else {
;;;339            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;340        }
;;;341        switch (opt) {
;;;342            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;343                 if (tasks_waiting == OS_FALSE) {
;;;344    #if OS_FLAG_NAME_EN > 0u
;;;345                     pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;346    #endif
;;;347                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;348                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;349                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;350                     OSFlagFreeList       = pgrp;
;;;351                     OS_EXIT_CRITICAL();
;;;352                     *perr                = OS_ERR_NONE;
;;;353                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;354                 } else {
;;;355                     OS_EXIT_CRITICAL();
;;;356                     *perr                = OS_ERR_TASK_WAITING;
;;;357                     pgrp_return          = pgrp;
;;;358                 }
;;;359                 break;
;;;360    
;;;361            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;362                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;363                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;364                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
;;;365                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;366                 }
;;;367    #if OS_FLAG_NAME_EN > 0u
;;;368                 pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;369    #endif
;;;370                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;371                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;372                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;373                 OSFlagFreeList       = pgrp;
;;;374                 OS_EXIT_CRITICAL();
;;;375                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;376                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;377                 }
;;;378                 *perr = OS_ERR_NONE;
;;;379                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;380                 break;
;;;381    
;;;382            default:
;;;383                 OS_EXIT_CRITICAL();
;;;384                 *perr                = OS_ERR_INVALID_OPT;
;;;385                 pgrp_return          = pgrp;
;;;386                 break;
;;;387        }
;;;388        return (pgrp_return);
;;;389    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  7820              LDRB     r0,[r4,#0]            ;331
000020  2805              CMP      r0,#5                 ;331
000022  d003              BEQ      |L3.44|
000024  2001              MOVS     r0,#1                 ;332
000026  7028              STRB     r0,[r5,#0]            ;332
000028  4620              MOV      r0,r4                 ;333
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;335
000032  6860              LDR      r0,[r4,#4]            ;336
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;337
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;339
                  |L3.60|
00003c  f1b90f00          CMP      r9,#0                 ;341
000040  d003              BEQ      |L3.74|
000042  f1b90f01          CMP      r9,#1                 ;341
000046  d13c              BNE      |L3.194|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a023              ADR      r0,|L3.220|
00004e  60e0              STR      r0,[r4,#0xc]          ;345
000050  2000              MOVS     r0,#0                 ;347
000052  7020              STRB     r0,[r4,#0]            ;347
000054  4822              LDR      r0,|L3.224|
000056  6800              LDR      r0,[r0,#0]            ;348  ; OSFlagFreeList
000058  6060              STR      r0,[r4,#4]            ;348
00005a  2000              MOVS     r0,#0                 ;349
00005c  8120              STRH     r0,[r4,#8]            ;349
00005e  4820              LDR      r0,|L3.224|
000060  6004              STR      r4,[r0,#0]            ;350  ; OSFlagFreeList
000062  4650              MOV      r0,r10                ;351
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;352
00006a  7028              STRB     r0,[r5,#0]            ;352
00006c  2600              MOVS     r6,#0                 ;353
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4650              MOV      r0,r10                ;355
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;356
000078  7028              STRB     r0,[r5,#0]            ;356
00007a  4626              MOV      r6,r4                 ;357
                  |L3.124|
00007c  e028              B        |L3.208|
                  |L3.126|
00007e  f8d48004          LDR      r8,[r4,#4]            ;362
000082  e005              B        |L3.144|
                  |L3.132|
000084  2100              MOVS     r1,#0                 ;364
000086  4640              MOV      r0,r8                 ;364
000088  f7fffffe          BL       OS_FlagTaskRdy
00008c  f8d88000          LDR      r8,[r8,#0]            ;365
                  |L3.144|
000090  f1b80f00          CMP      r8,#0                 ;363
000094  d1f6              BNE      |L3.132|
000096  a011              ADR      r0,|L3.220|
000098  60e0              STR      r0,[r4,#0xc]          ;368
00009a  2000              MOVS     r0,#0                 ;370
00009c  7020              STRB     r0,[r4,#0]            ;370
00009e  4810              LDR      r0,|L3.224|
0000a0  6800              LDR      r0,[r0,#0]            ;371  ; OSFlagFreeList
0000a2  6060              STR      r0,[r4,#4]            ;371
0000a4  2000              MOVS     r0,#0                 ;372
0000a6  8120              STRH     r0,[r4,#8]            ;372
0000a8  480d              LDR      r0,|L3.224|
0000aa  6004              STR      r4,[r0,#0]            ;373  ; OSFlagFreeList
0000ac  4650              MOV      r0,r10                ;374
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  2f01              CMP      r7,#1                 ;375
0000b4  d101              BNE      |L3.186|
0000b6  f7fffffe          BL       OS_Sched
                  |L3.186|
0000ba  2000              MOVS     r0,#0                 ;378
0000bc  7028              STRB     r0,[r5,#0]            ;378
0000be  2600              MOVS     r6,#0                 ;379
0000c0  e006              B        |L3.208|
                  |L3.194|
0000c2  4650              MOV      r0,r10                ;383
0000c4  f7fffffe          BL       OS_CPU_SR_Restore
0000c8  2007              MOVS     r0,#7                 ;384
0000ca  7028              STRB     r0,[r5,#0]            ;384
0000cc  4626              MOV      r6,r4                 ;385
0000ce  bf00              NOP                            ;386
                  |L3.208|
0000d0  bf00              NOP                            ;359
0000d2  4630              MOV      r0,r6                 ;388
0000d4  e7a1              B        |L3.26|
;;;390    #endif
                          ENDP

0000d6  0000              DCW      0x0000
                  |L3.216|
                          DCD      OSIntNesting
                  |L3.220|
0000dc  3f00              DCB      "?",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagNameGet||, CODE, READONLY, ALIGN=2

                  OSFlagNameGet PROC
;;;415    #if OS_FLAG_NAME_EN > 0u
;;;416    INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;417                          INT8U        **pname,
;;;418                          INT8U         *perr)
;;;419    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;420        INT8U      len;
;;;421    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;422        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;423    #endif
;;;424    
;;;425    
;;;426    
;;;427    #ifdef OS_SAFETY_CRITICAL
;;;428        if (perr == (INT8U *)0) {
;;;429            OS_SAFETY_CRITICAL_EXCEPTION();
;;;430            return (0u);
;;;431        }
;;;432    #endif
;;;433    
;;;434    #if OS_ARG_CHK_EN > 0u
;;;435        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;436            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;437            return (0u);
;;;438        }
;;;439        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;440            *perr = OS_ERR_PNAME_NULL;
;;;441            return (0u);
;;;442        }
;;;443    #endif
;;;444        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4810              LDR      r0,|L4.80|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L4.28|
;;;445            *perr = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7020              STRB     r0,[r4,#0]
;;;446            return (0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;447        }
;;;448        OS_ENTER_CRITICAL();
;;;449        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;450            OS_EXIT_CRITICAL();
;;;451            *perr = OS_ERR_EVENT_TYPE;
;;;452            return (0u);
;;;453        }
;;;454        *pname = pgrp->OSFlagName;
;;;455        len    = OS_StrLen(*pname);
;;;456        OS_EXIT_CRITICAL();
;;;457        *perr  = OS_ERR_NONE;
;;;458        return (len);
;;;459    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L4.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;448
000022  7828              LDRB     r0,[r5,#0]            ;449
000024  2805              CMP      r0,#5                 ;449
000026  d006              BEQ      |L4.54|
000028  4638              MOV      r0,r7                 ;450
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  2001              MOVS     r0,#1                 ;451
000030  7020              STRB     r0,[r4,#0]            ;451
000032  2000              MOVS     r0,#0                 ;452
000034  e7f0              B        |L4.24|
                  |L4.54|
000036  68e8              LDR      r0,[r5,#0xc]          ;454
000038  6030              STR      r0,[r6,#0]            ;454
00003a  6830              LDR      r0,[r6,#0]            ;455
00003c  f7fffffe          BL       OS_StrLen
000040  4680              MOV      r8,r0                 ;455
000042  4638              MOV      r0,r7                 ;456
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;457
00004a  7020              STRB     r0,[r4,#0]            ;457
00004c  4640              MOV      r0,r8                 ;458
00004e  e7e3              B        |L4.24|
;;;460    #endif
                          ENDP

                  |L4.80|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagNameSet||, CODE, READONLY, ALIGN=2

                  OSFlagNameSet PROC
;;;486    #if OS_FLAG_NAME_EN > 0u
;;;487    void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;488                         INT8U        *pname,
;;;489                         INT8U        *perr)
;;;490    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;491    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;492        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;493    #endif
;;;494    
;;;495    
;;;496    
;;;497    #ifdef OS_SAFETY_CRITICAL
;;;498        if (perr == (INT8U *)0) {
;;;499            OS_SAFETY_CRITICAL_EXCEPTION();
;;;500            return;
;;;501        }
;;;502    #endif
;;;503    
;;;504    #if OS_ARG_CHK_EN > 0u
;;;505        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;506            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;507            return;
;;;508        }
;;;509        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;510            *perr = OS_ERR_PNAME_NULL;
;;;511            return;
;;;512        }
;;;513    #endif
;;;514        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480d              LDR      r0,|L5.68|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L5.26|
;;;515            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L5.22|
;;;516            return;
;;;517        }
;;;518        OS_ENTER_CRITICAL();
;;;519        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;520            OS_EXIT_CRITICAL();
;;;521            *perr = OS_ERR_EVENT_TYPE;
;;;522            return;
;;;523        }
;;;524        pgrp->OSFlagName = pname;
;;;525        OS_EXIT_CRITICAL();
;;;526        *perr            = OS_ERR_NONE;
;;;527        return;
;;;528    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;518
000020  7828              LDRB     r0,[r5,#0]            ;519
000022  2805              CMP      r0,#5                 ;519
000024  d005              BEQ      |L5.50|
000026  4638              MOV      r0,r7                 ;520
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  2001              MOVS     r0,#1                 ;521
00002e  7020              STRB     r0,[r4,#0]            ;521
000030  e7f1              B        |L5.22|
                  |L5.50|
000032  60ee              STR      r6,[r5,#0xc]          ;524
000034  4638              MOV      r0,r7                 ;525
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2000              MOVS     r0,#0                 ;526
00003c  7020              STRB     r0,[r4,#0]            ;526
00003e  bf00              NOP                            ;527
000040  e7e9              B        |L5.22|
;;;529    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;585    
;;;586    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;587                          OS_FLAGS      flags,
;;;588                          INT8U         wait_type,
;;;589                          INT32U        timeout,
;;;590                          INT8U        *perr)
;;;591    {
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9e12              LDR      r6,[sp,#0x48]
;;;592        OS_FLAG_NODE  node;
;;;593        OS_FLAGS      flags_rdy;
;;;594        INT8U         result;
;;;595        INT8U         pend_stat;
;;;596        BOOLEAN       consume;
;;;597    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;598        OS_CPU_SR     cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;599    #endif
;;;600    
;;;601    
;;;602    
;;;603    #ifdef OS_SAFETY_CRITICAL
;;;604        if (perr == (INT8U *)0) {
;;;605            OS_SAFETY_CRITICAL_EXCEPTION();
;;;606            return ((OS_FLAGS)0);
;;;607        }
;;;608    #endif
;;;609    
;;;610    #if OS_ARG_CHK_EN > 0u
;;;611        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;612            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;613            return ((OS_FLAGS)0);
;;;614        }
;;;615    #endif
;;;616        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000014  488c              LDR      r0,|L6.584|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000018  b128              CBZ      r0,|L6.38|
;;;617            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001a  2002              MOVS     r0,#2
00001c  7030              STRB     r0,[r6,#0]
;;;618            return ((OS_FLAGS)0);
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;619        }
;;;620        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;621            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;622            return ((OS_FLAGS)0);
;;;623        }
;;;624        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;625            *perr = OS_ERR_EVENT_TYPE;
;;;626            return ((OS_FLAGS)0);
;;;627        }
;;;628        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;629        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;630            wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
;;;631            consume    = OS_TRUE;
;;;632        } else {
;;;633            consume    = OS_FALSE;
;;;634        }
;;;635    /*$PAGE*/
;;;636        OS_ENTER_CRITICAL();
;;;637        switch (wait_type) {
;;;638            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;639                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;640                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;641                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;642                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
;;;643                     }
;;;644                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;645                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;646                     *perr                   = OS_ERR_NONE;
;;;647                     return (flags_rdy);
;;;648                 } else {                                      /* Block task until events occur or timeout */
;;;649                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;650                     OS_EXIT_CRITICAL();
;;;651                 }
;;;652                 break;
;;;653    
;;;654            case OS_FLAG_WAIT_SET_ANY:
;;;655                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;656                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;657                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;658                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
;;;659                     }
;;;660                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;661                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;662                     *perr                   = OS_ERR_NONE;
;;;663                     return (flags_rdy);
;;;664                 } else {                                      /* Block task until events occur or timeout */
;;;665                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;666                     OS_EXIT_CRITICAL();
;;;667                 }
;;;668                 break;
;;;669    
;;;670    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;671            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;672                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;673                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;674                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;675                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;676                     }
;;;677                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;678                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;679                     *perr                   = OS_ERR_NONE;
;;;680                     return (flags_rdy);
;;;681                 } else {                                      /* Block task until events occur or timeout */
;;;682                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;683                     OS_EXIT_CRITICAL();
;;;684                 }
;;;685                 break;
;;;686    
;;;687            case OS_FLAG_WAIT_CLR_ANY:
;;;688                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;689                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;690                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;691                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;692                     }
;;;693                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;694                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;695                     *perr                   = OS_ERR_NONE;
;;;696                     return (flags_rdy);
;;;697                 } else {                                      /* Block task until events occur or timeout */
;;;698                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;699                     OS_EXIT_CRITICAL();
;;;700                 }
;;;701                 break;
;;;702    #endif
;;;703    
;;;704            default:
;;;705                 OS_EXIT_CRITICAL();
;;;706                 flags_rdy = (OS_FLAGS)0;
;;;707                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;708                 return (flags_rdy);
;;;709        }
;;;710    /*$PAGE*/
;;;711        OS_Sched();                                            /* Find next HPT ready to run               */
;;;712        OS_ENTER_CRITICAL();
;;;713        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;714            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;715            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;716            OS_FlagUnlink(&node);
;;;717            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;718            OS_EXIT_CRITICAL();
;;;719            flags_rdy                = (OS_FLAGS)0;
;;;720            switch (pend_stat) {
;;;721                case OS_STAT_PEND_ABORT:
;;;722                     *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
;;;723                     break;
;;;724    
;;;725                case OS_STAT_PEND_TO:
;;;726                default:
;;;727                     *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
;;;728                     break;
;;;729            }
;;;730            return (flags_rdy);
;;;731        }
;;;732        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;733        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;734            switch (wait_type) {
;;;735                case OS_FLAG_WAIT_SET_ALL:
;;;736                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;737                     pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
;;;738                     break;
;;;739    
;;;740    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;741                case OS_FLAG_WAIT_CLR_ALL:
;;;742                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;743                     pgrp->OSFlagFlags |=  flags_rdy;
;;;744                     break;
;;;745    #endif
;;;746                default:
;;;747                     OS_EXIT_CRITICAL();
;;;748                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;749                     return ((OS_FLAGS)0);
;;;750            }
;;;751        }
;;;752        OS_EXIT_CRITICAL();
;;;753        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;754        return (flags_rdy);
;;;755    }
000020  b009              ADD      sp,sp,#0x24
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.38|
000026  4889              LDR      r0,|L6.588|
000028  7800              LDRB     r0,[r0,#0]            ;620  ; OSLockNesting
00002a  b118              CBZ      r0,|L6.52|
00002c  200d              MOVS     r0,#0xd               ;621
00002e  7030              STRB     r0,[r6,#0]            ;621
000030  2000              MOVS     r0,#0                 ;622
000032  e7f5              B        |L6.32|
                  |L6.52|
000034  7828              LDRB     r0,[r5,#0]            ;624
000036  2805              CMP      r0,#5                 ;624
000038  d003              BEQ      |L6.66|
00003a  2001              MOVS     r0,#1                 ;625
00003c  7030              STRB     r0,[r6,#0]            ;625
00003e  2000              MOVS     r0,#0                 ;626
000040  e7ee              B        |L6.32|
                  |L6.66|
000042  f0090b80          AND      r11,r9,#0x80          ;628
000046  f1bb0f00          CMP      r11,#0                ;629
00004a  d004              BEQ      |L6.86|
00004c  f009097f          AND      r9,r9,#0x7f           ;630
000050  f04f0801          MOV      r8,#1                 ;631
000054  e001              B        |L6.90|
                  |L6.86|
000056  f04f0800          MOV      r8,#0                 ;633
                  |L6.90|
00005a  f7fffffe          BL       OS_CPU_SR_Save
00005e  9002              STR      r0,[sp,#8]            ;636
000060  f1b90f00          CMP      r9,#0                 ;637
000064  d04a              BEQ      |L6.252|
000066  f1b90f01          CMP      r9,#1                 ;637
00006a  d068              BEQ      |L6.318|
00006c  f1b90f02          CMP      r9,#2                 ;637
000070  d003              BEQ      |L6.122|
000072  f1b90f03          CMP      r9,#3                 ;637
000076  d176              BNE      |L6.358|
000078  e020              B        |L6.188|
                  |L6.122|
00007a  8928              LDRH     r0,[r5,#8]            ;639
00007c  ea000407          AND      r4,r0,r7              ;639
000080  42bc              CMP      r4,r7                 ;640
000082  d10f              BNE      |L6.164|
000084  f1b80f01          CMP      r8,#1                 ;641
000088  d102              BNE      |L6.144|
00008a  8928              LDRH     r0,[r5,#8]            ;642
00008c  43a0              BICS     r0,r0,r4              ;642
00008e  8128              STRH     r0,[r5,#8]            ;642
                  |L6.144|
000090  486f              LDR      r0,|L6.592|
000092  6800              LDR      r0,[r0,#0]            ;644  ; OSTCBCur
000094  8584              STRH     r4,[r0,#0x2c]         ;644
000096  9802              LDR      r0,[sp,#8]            ;645
000098  f7fffffe          BL       OS_CPU_SR_Restore
00009c  2000              MOVS     r0,#0                 ;646
00009e  7030              STRB     r0,[r6,#0]            ;646
0000a0  4620              MOV      r0,r4                 ;647
0000a2  e7bd              B        |L6.32|
                  |L6.164|
0000a4  464b              MOV      r3,r9                 ;649
0000a6  463a              MOV      r2,r7                 ;649
0000a8  a904              ADD      r1,sp,#0x10           ;649
0000aa  4628              MOV      r0,r5                 ;649
0000ac  f8cda000          STR      r10,[sp,#0]           ;649
0000b0  f7fffffe          BL       OS_FlagBlock
0000b4  9802              LDR      r0,[sp,#8]            ;650
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  e069              B        |L6.400|
                  |L6.188|
0000bc  8928              LDRH     r0,[r5,#8]            ;655
0000be  ea000407          AND      r4,r0,r7              ;655
0000c2  b17c              CBZ      r4,|L6.228|
0000c4  f1b80f01          CMP      r8,#1                 ;657
0000c8  d102              BNE      |L6.208|
0000ca  8928              LDRH     r0,[r5,#8]            ;658
0000cc  43a0              BICS     r0,r0,r4              ;658
0000ce  8128              STRH     r0,[r5,#8]            ;658
                  |L6.208|
0000d0  485f              LDR      r0,|L6.592|
0000d2  6800              LDR      r0,[r0,#0]            ;660  ; OSTCBCur
0000d4  8584              STRH     r4,[r0,#0x2c]         ;660
0000d6  9802              LDR      r0,[sp,#8]            ;661
0000d8  f7fffffe          BL       OS_CPU_SR_Restore
0000dc  2000              MOVS     r0,#0                 ;662
0000de  7030              STRB     r0,[r6,#0]            ;662
0000e0  4620              MOV      r0,r4                 ;663
0000e2  e79d              B        |L6.32|
                  |L6.228|
0000e4  464b              MOV      r3,r9                 ;665
0000e6  463a              MOV      r2,r7                 ;665
0000e8  a904              ADD      r1,sp,#0x10           ;665
0000ea  4628              MOV      r0,r5                 ;665
0000ec  f8cda000          STR      r10,[sp,#0]           ;665
0000f0  f7fffffe          BL       OS_FlagBlock
0000f4  9802              LDR      r0,[sp,#8]            ;666
0000f6  f7fffffe          BL       OS_CPU_SR_Restore
0000fa  e049              B        |L6.400|
                  |L6.252|
0000fc  8928              LDRH     r0,[r5,#8]            ;672
0000fe  ea270400          BIC      r4,r7,r0              ;672
000102  42bc              CMP      r4,r7                 ;673
000104  d10f              BNE      |L6.294|
000106  f1b80f01          CMP      r8,#1                 ;674
00010a  d102              BNE      |L6.274|
00010c  8928              LDRH     r0,[r5,#8]            ;675
00010e  4320              ORRS     r0,r0,r4              ;675
000110  8128              STRH     r0,[r5,#8]            ;675
                  |L6.274|
000112  484f              LDR      r0,|L6.592|
000114  6800              LDR      r0,[r0,#0]            ;677  ; OSTCBCur
000116  8584              STRH     r4,[r0,#0x2c]         ;677
000118  9802              LDR      r0,[sp,#8]            ;678
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  2000              MOVS     r0,#0                 ;679
000120  7030              STRB     r0,[r6,#0]            ;679
000122  4620              MOV      r0,r4                 ;680
000124  e77c              B        |L6.32|
                  |L6.294|
000126  464b              MOV      r3,r9                 ;682
000128  463a              MOV      r2,r7                 ;682
00012a  a904              ADD      r1,sp,#0x10           ;682
00012c  4628              MOV      r0,r5                 ;682
00012e  f8cda000          STR      r10,[sp,#0]           ;682
000132  f7fffffe          BL       OS_FlagBlock
000136  9802              LDR      r0,[sp,#8]            ;683
000138  f7fffffe          BL       OS_CPU_SR_Restore
00013c  e028              B        |L6.400|
                  |L6.318|
00013e  8928              LDRH     r0,[r5,#8]            ;688
000140  ea270400          BIC      r4,r7,r0              ;688
000144  b184              CBZ      r4,|L6.360|
000146  f1b80f01          CMP      r8,#1                 ;690
00014a  d102              BNE      |L6.338|
00014c  8928              LDRH     r0,[r5,#8]            ;691
00014e  4320              ORRS     r0,r0,r4              ;691
000150  8128              STRH     r0,[r5,#8]            ;691
                  |L6.338|
000152  483f              LDR      r0,|L6.592|
000154  6800              LDR      r0,[r0,#0]            ;693  ; OSTCBCur
000156  8584              STRH     r4,[r0,#0x2c]         ;693
000158  9802              LDR      r0,[sp,#8]            ;694
00015a  f7fffffe          BL       OS_CPU_SR_Restore
00015e  2000              MOVS     r0,#0                 ;695
000160  7030              STRB     r0,[r6,#0]            ;695
000162  4620              MOV      r0,r4                 ;696
000164  e75c              B        |L6.32|
                  |L6.358|
000166  e00b              B        |L6.384|
                  |L6.360|
000168  464b              MOV      r3,r9                 ;698
00016a  463a              MOV      r2,r7                 ;698
00016c  a904              ADD      r1,sp,#0x10           ;698
00016e  4628              MOV      r0,r5                 ;698
000170  f8cda000          STR      r10,[sp,#0]           ;698
000174  f7fffffe          BL       OS_FlagBlock
000178  9802              LDR      r0,[sp,#8]            ;699
00017a  f7fffffe          BL       OS_CPU_SR_Restore
00017e  e007              B        |L6.400|
                  |L6.384|
000180  9802              LDR      r0,[sp,#8]            ;705
000182  f7fffffe          BL       OS_CPU_SR_Restore
000186  2400              MOVS     r4,#0                 ;706
000188  206f              MOVS     r0,#0x6f              ;707
00018a  7030              STRB     r0,[r6,#0]            ;707
00018c  4620              MOV      r0,r4                 ;708
00018e  e747              B        |L6.32|
                  |L6.400|
000190  bf00              NOP                            ;652
000192  f7fffffe          BL       OS_Sched
000196  f7fffffe          BL       OS_CPU_SR_Save
00019a  9002              STR      r0,[sp,#8]            ;712
00019c  482c              LDR      r0,|L6.592|
00019e  6800              LDR      r0,[r0,#0]            ;713  ; OSTCBCur
0001a0  f8900035          LDRB     r0,[r0,#0x35]         ;713
0001a4  b320              CBZ      r0,|L6.496|
0001a6  482a              LDR      r0,|L6.592|
0001a8  6800              LDR      r0,[r0,#0]            ;714  ; OSTCBCur
0001aa  f8900035          LDRB     r0,[r0,#0x35]         ;714
0001ae  9003              STR      r0,[sp,#0xc]          ;714
0001b0  2000              MOVS     r0,#0                 ;715
0001b2  4927              LDR      r1,|L6.592|
0001b4  6809              LDR      r1,[r1,#0]            ;715  ; OSTCBCur
0001b6  f8810035          STRB     r0,[r1,#0x35]         ;715
0001ba  a804              ADD      r0,sp,#0x10           ;716
0001bc  f7fffffe          BL       OS_FlagUnlink
0001c0  2000              MOVS     r0,#0                 ;717
0001c2  4923              LDR      r1,|L6.592|
0001c4  6809              LDR      r1,[r1,#0]            ;717  ; OSTCBCur
0001c6  f8810034          STRB     r0,[r1,#0x34]         ;717
0001ca  9802              LDR      r0,[sp,#8]            ;718
0001cc  f7fffffe          BL       OS_CPU_SR_Restore
0001d0  2400              MOVS     r4,#0                 ;719
0001d2  9803              LDR      r0,[sp,#0xc]          ;720
0001d4  2801              CMP      r0,#1                 ;720
0001d6  d005              BEQ      |L6.484|
0001d8  2802              CMP      r0,#2                 ;720
0001da  d102              BNE      |L6.482|
0001dc  200e              MOVS     r0,#0xe               ;722
0001de  7030              STRB     r0,[r6,#0]            ;722
0001e0  e003              B        |L6.490|
                  |L6.482|
0001e2  bf00              NOP                            ;725
                  |L6.484|
0001e4  200a              MOVS     r0,#0xa               ;727
0001e6  7030              STRB     r0,[r6,#0]            ;727
0001e8  bf00              NOP                            ;728
                  |L6.490|
0001ea  bf00              NOP                            ;723
0001ec  4620              MOV      r0,r4                 ;730
0001ee  e717              B        |L6.32|
                  |L6.496|
0001f0  4817              LDR      r0,|L6.592|
0001f2  6800              LDR      r0,[r0,#0]            ;732  ; OSTCBCur
0001f4  8d84              LDRH     r4,[r0,#0x2c]         ;732
0001f6  f1b80f01          CMP      r8,#1                 ;733
0001fa  d11e              BNE      |L6.570|
0001fc  f1b90f00          CMP      r9,#0                 ;734
000200  d00e              BEQ      |L6.544|
000202  f1b90f01          CMP      r9,#1                 ;734
000206  d00c              BEQ      |L6.546|
000208  f1b90f02          CMP      r9,#2                 ;734
00020c  d003              BEQ      |L6.534|
00020e  f1b90f03          CMP      r9,#3                 ;734
000212  d10a              BNE      |L6.554|
000214  e000              B        |L6.536|
                  |L6.534|
000216  bf00              NOP                            ;736
                  |L6.536|
000218  8928              LDRH     r0,[r5,#8]            ;737
00021a  43a0              BICS     r0,r0,r4              ;737
00021c  8128              STRH     r0,[r5,#8]            ;737
00021e  e00b              B        |L6.568|
                  |L6.544|
000220  bf00              NOP                            ;742
                  |L6.546|
000222  8928              LDRH     r0,[r5,#8]            ;743
000224  4320              ORRS     r0,r0,r4              ;743
000226  8128              STRH     r0,[r5,#8]            ;743
000228  e006              B        |L6.568|
                  |L6.554|
00022a  9802              LDR      r0,[sp,#8]            ;747
00022c  f7fffffe          BL       OS_CPU_SR_Restore
000230  206f              MOVS     r0,#0x6f              ;748
000232  7030              STRB     r0,[r6,#0]            ;748
000234  2000              MOVS     r0,#0                 ;749
000236  e6f3              B        |L6.32|
                  |L6.568|
000238  bf00              NOP                            ;738
                  |L6.570|
00023a  9802              LDR      r0,[sp,#8]            ;752
00023c  f7fffffe          BL       OS_CPU_SR_Restore
000240  2000              MOVS     r0,#0                 ;753
000242  7030              STRB     r0,[r6,#0]            ;753
000244  4620              MOV      r0,r4                 ;754
000246  e6eb              B        |L6.32|
;;;756    /*$PAGE*/
                          ENDP

                  |L6.584|
                          DCD      OSIntNesting
                  |L6.588|
                          DCD      OSLockNesting
                  |L6.592|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;771    
;;;772    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
000000  b570              PUSH     {r4-r6,lr}
;;;773    {
;;;774        OS_FLAGS      flags;
;;;775    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;776        OS_CPU_SR     cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;777    #endif
;;;778    
;;;779    
;;;780    
;;;781        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;782        flags = OSTCBCur->OSTCBFlagsRdy;
00000a  4804              LDR      r0,|L7.28|
00000c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00000e  8d84              LDRH     r4,[r0,#0x2c]
;;;783        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;784        return (flags);
000016  4620              MOV      r0,r4
;;;785    }
000018  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=1

                  OSFlagPost PROC
;;;828    */
;;;829    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;830                          OS_FLAGS      flags,
;;;831                          INT8U         opt,
;;;832                          INT8U        *perr)
;;;833    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;834        OS_FLAG_NODE *pnode;
;;;835        BOOLEAN       sched;
;;;836        OS_FLAGS      flags_cur;
;;;837        OS_FLAGS      flags_rdy;
;;;838        BOOLEAN       rdy;
;;;839    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;840        OS_CPU_SR     cpu_sr = 0u;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;841    #endif
;;;842    
;;;843    
;;;844    
;;;845    #ifdef OS_SAFETY_CRITICAL
;;;846        if (perr == (INT8U *)0) {
;;;847            OS_SAFETY_CRITICAL_EXCEPTION();
;;;848            return ((OS_FLAGS)0);
;;;849        }
;;;850    #endif
;;;851    
;;;852    #if OS_ARG_CHK_EN > 0u
;;;853        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;854            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;855            return ((OS_FLAGS)0);
;;;856        }
;;;857    #endif
;;;858        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L8.32|
;;;859            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;860            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;861        }
;;;862    /*$PAGE*/
;;;863        OS_ENTER_CRITICAL();
;;;864        switch (opt) {
;;;865            case OS_FLAG_CLR:
;;;866                 pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
;;;867                 break;
;;;868    
;;;869            case OS_FLAG_SET:
;;;870                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;871                 break;
;;;872    
;;;873            default:
;;;874                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;875                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;876                 return ((OS_FLAGS)0);
;;;877        }
;;;878        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;879        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;880        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;881            switch (pnode->OSFlagNodeWaitType) {
;;;882                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;883                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;884                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;885                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;886                         if (rdy == OS_TRUE) {
;;;887                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;888                         }
;;;889                     }
;;;890                     break;
;;;891    
;;;892                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;893                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;894                     if (flags_rdy != (OS_FLAGS)0) {
;;;895                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;896                         if (rdy == OS_TRUE) {
;;;897                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;898                         }
;;;899                     }
;;;900                     break;
;;;901    
;;;902    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;903                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;904                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;905                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;906                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;907                         if (rdy == OS_TRUE) {
;;;908                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;909                         }
;;;910                     }
;;;911                     break;
;;;912    
;;;913                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;914                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;915                     if (flags_rdy != (OS_FLAGS)0) {
;;;916                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;917                         if (rdy == OS_TRUE) {
;;;918                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;919                         }
;;;920                     }
;;;921                     break;
;;;922    #endif
;;;923                default:
;;;924                     OS_EXIT_CRITICAL();
;;;925                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;926                     return ((OS_FLAGS)0);
;;;927            }
;;;928            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;929        }
;;;930        OS_EXIT_CRITICAL();
;;;931        if (sched == OS_TRUE) {
;;;932            OS_Sched();
;;;933        }
;;;934        OS_ENTER_CRITICAL();
;;;935        flags_cur = pgrp->OSFlagFlags;
;;;936        OS_EXIT_CRITICAL();
;;;937        *perr     = OS_ERR_NONE;
;;;938        return (flags_cur);
;;;939    }
00001c  e8bd9ffc          POP      {r2-r12,pc}
                  |L8.32|
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  9000              STR      r0,[sp,#0]            ;863
000026  f1ba0f00          CMP      r10,#0                ;864
00002a  d003              BEQ      |L8.52|
00002c  f1ba0f01          CMP      r10,#1                ;864
000030  d10a              BNE      |L8.72|
000032  e004              B        |L8.62|
                  |L8.52|
000034  8920              LDRH     r0,[r4,#8]            ;866
000036  ea200009          BIC      r0,r0,r9              ;866
00003a  8120              STRH     r0,[r4,#8]            ;866
00003c  e00b              B        |L8.86|
                  |L8.62|
00003e  8920              LDRH     r0,[r4,#8]            ;870
000040  ea400009          ORR      r0,r0,r9              ;870
000044  8120              STRH     r0,[r4,#8]            ;870
000046  e006              B        |L8.86|
                  |L8.72|
000048  9800              LDR      r0,[sp,#0]            ;874
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2071              MOVS     r0,#0x71              ;875
000050  7030              STRB     r0,[r6,#0]            ;875
000052  2000              MOVS     r0,#0                 ;876
000054  e7e2              B        |L8.28|
                  |L8.86|
000056  bf00              NOP                            ;867
000058  f04f0b00          MOV      r11,#0                ;878
00005c  6865              LDR      r5,[r4,#4]            ;879
00005e  e055              B        |L8.268|
                  |L8.96|
000060  7ca8              LDRB     r0,[r5,#0x12]         ;881
000062  b340              CBZ      r0,|L8.182|
000064  2801              CMP      r0,#1                 ;881
000066  d038              BEQ      |L8.218|
000068  2802              CMP      r0,#2                 ;881
00006a  d002              BEQ      |L8.114|
00006c  2803              CMP      r0,#3                 ;881
00006e  d144              BNE      |L8.250|
000070  e011              B        |L8.150|
                  |L8.114|
000072  8920              LDRH     r0,[r4,#8]            ;883
000074  8a29              LDRH     r1,[r5,#0x10]         ;883
000076  ea000701          AND      r7,r0,r1              ;883
00007a  8a28              LDRH     r0,[r5,#0x10]         ;884
00007c  42b8              CMP      r0,r7                 ;884
00007e  d109              BNE      |L8.148|
000080  4639              MOV      r1,r7                 ;885
000082  4628              MOV      r0,r5                 ;885
000084  f7fffffe          BL       OS_FlagTaskRdy
000088  4680              MOV      r8,r0                 ;885
00008a  f1b80f01          CMP      r8,#1                 ;886
00008e  d101              BNE      |L8.148|
000090  f04f0b01          MOV      r11,#1                ;887
                  |L8.148|
000094  e038              B        |L8.264|
                  |L8.150|
000096  8920              LDRH     r0,[r4,#8]            ;893
000098  8a29              LDRH     r1,[r5,#0x10]         ;893
00009a  ea000701          AND      r7,r0,r1              ;893
00009e  b14f              CBZ      r7,|L8.180|
0000a0  4639              MOV      r1,r7                 ;895
0000a2  4628              MOV      r0,r5                 ;895
0000a4  f7fffffe          BL       OS_FlagTaskRdy
0000a8  4680              MOV      r8,r0                 ;895
0000aa  f1b80f01          CMP      r8,#1                 ;896
0000ae  d101              BNE      |L8.180|
0000b0  f04f0b01          MOV      r11,#1                ;897
                  |L8.180|
0000b4  e028              B        |L8.264|
                  |L8.182|
0000b6  8a28              LDRH     r0,[r5,#0x10]         ;904
0000b8  8921              LDRH     r1,[r4,#8]            ;904
0000ba  ea200701          BIC      r7,r0,r1              ;904
0000be  8a28              LDRH     r0,[r5,#0x10]         ;905
0000c0  42b8              CMP      r0,r7                 ;905
0000c2  d109              BNE      |L8.216|
0000c4  4639              MOV      r1,r7                 ;906
0000c6  4628              MOV      r0,r5                 ;906
0000c8  f7fffffe          BL       OS_FlagTaskRdy
0000cc  4680              MOV      r8,r0                 ;906
0000ce  f1b80f01          CMP      r8,#1                 ;907
0000d2  d101              BNE      |L8.216|
0000d4  f04f0b01          MOV      r11,#1                ;908
                  |L8.216|
0000d8  e016              B        |L8.264|
                  |L8.218|
0000da  8a28              LDRH     r0,[r5,#0x10]         ;914
0000dc  8921              LDRH     r1,[r4,#8]            ;914
0000de  ea200701          BIC      r7,r0,r1              ;914
0000e2  b14f              CBZ      r7,|L8.248|
0000e4  4639              MOV      r1,r7                 ;916
0000e6  4628              MOV      r0,r5                 ;916
0000e8  f7fffffe          BL       OS_FlagTaskRdy
0000ec  4680              MOV      r8,r0                 ;916
0000ee  f1b80f01          CMP      r8,#1                 ;917
0000f2  d101              BNE      |L8.248|
0000f4  f04f0b01          MOV      r11,#1                ;918
                  |L8.248|
0000f8  e006              B        |L8.264|
                  |L8.250|
0000fa  9800              LDR      r0,[sp,#0]            ;924
0000fc  f7fffffe          BL       OS_CPU_SR_Restore
000100  206f              MOVS     r0,#0x6f              ;925
000102  7030              STRB     r0,[r6,#0]            ;925
000104  2000              MOVS     r0,#0                 ;926
000106  e789              B        |L8.28|
                  |L8.264|
000108  bf00              NOP                            ;890
00010a  682d              LDR      r5,[r5,#0]            ;928
                  |L8.268|
00010c  2d00              CMP      r5,#0                 ;880
00010e  d1a7              BNE      |L8.96|
000110  9800              LDR      r0,[sp,#0]            ;930
000112  f7fffffe          BL       OS_CPU_SR_Restore
000116  f1bb0f01          CMP      r11,#1                ;931
00011a  d101              BNE      |L8.288|
00011c  f7fffffe          BL       OS_Sched
                  |L8.288|
000120  f7fffffe          BL       OS_CPU_SR_Save
000124  9000              STR      r0,[sp,#0]            ;934
000126  8920              LDRH     r0,[r4,#8]            ;935
000128  9001              STR      r0,[sp,#4]            ;935
00012a  9800              LDR      r0,[sp,#0]            ;936
00012c  f7fffffe          BL       OS_CPU_SR_Restore
000130  2000              MOVS     r0,#0                 ;937
000132  7030              STRB     r0,[r6,#0]            ;937
000134  9801              LDR      r0,[sp,#4]            ;938
000136  e771              B        |L8.28|
;;;940    /*$PAGE*/
                          ENDP


                          AREA ||i.OSFlagQuery||, CODE, READONLY, ALIGN=1

                  OSFlagQuery PROC
;;;960    #if OS_FLAG_QUERY_EN > 0u
;;;961    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;962                           INT8U        *perr)
;;;963    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;964        OS_FLAGS   flags;
;;;965    #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
;;;966        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;967    #endif
;;;968    
;;;969    
;;;970    
;;;971    #ifdef OS_SAFETY_CRITICAL
;;;972        if (perr == (INT8U *)0) {
;;;973            OS_SAFETY_CRITICAL_EXCEPTION();
;;;974            return ((OS_FLAGS)0);
;;;975        }
;;;976    #endif
;;;977    
;;;978    #if OS_ARG_CHK_EN > 0u
;;;979        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;980            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;981            return ((OS_FLAGS)0);
;;;982        }
;;;983    #endif
;;;984        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2805              CMP      r0,#5
00000e  d004              BEQ      |L9.26|
;;;985            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
000012  7028              STRB     r0,[r5,#0]
;;;986            return ((OS_FLAGS)0);
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;987        }
;;;988        OS_ENTER_CRITICAL();
;;;989        flags = pgrp->OSFlagFlags;
;;;990        OS_EXIT_CRITICAL();
;;;991        *perr = OS_ERR_NONE;
;;;992        return (flags);                               /* Return the current value of the event flags       */
;;;993    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;988
000020  8926              LDRH     r6,[r4,#8]            ;989
000022  4638              MOV      r0,r7                 ;990
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2000              MOVS     r0,#0                 ;991
00002a  7028              STRB     r0,[r5,#0]            ;991
00002c  4630              MOV      r0,r6                 ;992
00002e  e7f2              B        |L9.22|
;;;994    #endif
                          ENDP


                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1033   
;;;1034   static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1035                               OS_FLAG_NODE *pnode,
;;;1036                               OS_FLAGS      flags,
;;;1037                               INT8U         wait_type,
;;;1038                               INT32U        timeout)
;;;1039   {
000002  4614              MOV      r4,r2
000004  9e05              LDR      r6,[sp,#0x14]
;;;1040       OS_FLAG_NODE  *pnode_next;
;;;1041       INT8U          y;
;;;1042   
;;;1043   
;;;1044       OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
000006  4f24              LDR      r7,|L10.152|
000008  683f              LDR      r7,[r7,#0]  ; OSTCBCur
00000a  f8977034          LDRB     r7,[r7,#0x34]
00000e  f0470720          ORR      r7,r7,#0x20
000012  f8dfc084          LDR      r12,|L10.152|
000016  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
00001a  f88c7034          STRB     r7,[r12,#0x34]
;;;1045       OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00001e  2700              MOVS     r7,#0
000020  f8dfc074          LDR      r12,|L10.152|
000024  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000028  f88c7035          STRB     r7,[r12,#0x35]
;;;1046       OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002c  4f1a              LDR      r7,|L10.152|
00002e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000030  633e              STR      r6,[r7,#0x30]
;;;1047   #if OS_TASK_DEL_EN > 0u
;;;1048       OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000032  4f19              LDR      r7,|L10.152|
000034  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000036  62b9              STR      r1,[r7,#0x28]
;;;1049   #endif
;;;1050       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000038  820c              STRH     r4,[r1,#0x10]
;;;1051       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00003a  748b              STRB     r3,[r1,#0x12]
;;;1052       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00003c  4f16              LDR      r7,|L10.152|
00003e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000040  608f              STR      r7,[r1,#8]
;;;1053       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000042  6847              LDR      r7,[r0,#4]
000044  600f              STR      r7,[r1,#0]
;;;1054       pnode->OSFlagNodePrev     = (void *)0;
000046  2700              MOVS     r7,#0
000048  604f              STR      r7,[r1,#4]
;;;1055       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00004a  60c8              STR      r0,[r1,#0xc]
;;;1056       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00004c  6845              LDR      r5,[r0,#4]
;;;1057       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00004e  b105              CBZ      r5,|L10.82|
;;;1058           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000050  6069              STR      r1,[r5,#4]
                  |L10.82|
;;;1059       }
;;;1060       pgrp->OSFlagWaitList = (void *)pnode;
000052  6041              STR      r1,[r0,#4]
;;;1061   
;;;1062       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000054  4f10              LDR      r7,|L10.152|
000056  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000058  f8972038          LDRB     r2,[r7,#0x38]
;;;1063       OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005c  4f0f              LDR      r7,|L10.156|
00005e  5cbf              LDRB     r7,[r7,r2]
000060  f8dfc034          LDR      r12,|L10.152|
000064  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000068  f89cc039          LDRB     r12,[r12,#0x39]
00006c  ea27070c          BIC      r7,r7,r12
000070  f8dfc028          LDR      r12,|L10.156|
000074  f80c7002          STRB     r7,[r12,r2]
;;;1064       if (OSRdyTbl[y] == 0x00u) {
000078  4667              MOV      r7,r12
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  b95f              CBNZ     r7,|L10.150|
;;;1065           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00007e  4f06              LDR      r7,|L10.152|
000080  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000082  f897c03a          LDRB     r12,[r7,#0x3a]
000086  4f06              LDR      r7,|L10.160|
000088  783f              LDRB     r7,[r7,#0]  ; OSRdyGrp
00008a  ea27070c          BIC      r7,r7,r12
00008e  f8dfc010          LDR      r12,|L10.160|
000092  f88c7000          STRB     r7,[r12,#0]
                  |L10.150|
;;;1066       }
;;;1067   }
000096  bdf0              POP      {r4-r7,pc}
;;;1068   
                          ENDP

                  |L10.152|
                          DCD      OSTCBCur
                  |L10.156|
                          DCD      OSRdyTbl
                  |L10.160|
                          DCD      OSRdyGrp

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1084   
;;;1085   void  OS_FlagInit (void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1086   {
;;;1087   #if OS_MAX_FLAGS == 1u
;;;1088       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1089       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1090       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1091       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1092   #if OS_FLAG_NAME_EN > 0u
;;;1093       OSFlagFreeList->OSFlagName     = (INT8U *)"?";
;;;1094   #endif
;;;1095   #endif
;;;1096   
;;;1097   #if OS_MAX_FLAGS >= 2u
;;;1098       INT16U        ix;
;;;1099       INT16U        ix_next;
;;;1100       OS_FLAG_GRP  *pgrp1;
;;;1101       OS_FLAG_GRP  *pgrp2;
;;;1102   
;;;1103   
;;;1104       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000004  2150              MOVS     r1,#0x50
000006  4811              LDR      r0,|L11.76|
000008  f7fffffe          BL       OS_MemClr
;;;1105       for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00000c  2500              MOVS     r5,#0
00000e  e00d              B        |L11.44|
                  |L11.16|
;;;1106           ix_next = ix + 1u;
000010  1c68              ADDS     r0,r5,#1
000012  b286              UXTH     r6,r0
;;;1107           pgrp1 = &OSFlagTbl[ix];
000014  480d              LDR      r0,|L11.76|
000016  eb001405          ADD      r4,r0,r5,LSL #4
;;;1108           pgrp2 = &OSFlagTbl[ix_next];
00001a  eb001706          ADD      r7,r0,r6,LSL #4
;;;1109           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001e  2000              MOVS     r0,#0
000020  7020              STRB     r0,[r4,#0]
;;;1110           pgrp1->OSFlagWaitList = (void *)pgrp2;
000022  6067              STR      r7,[r4,#4]
;;;1111   #if OS_FLAG_NAME_EN > 0u
;;;1112           pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
000024  a00a              ADR      r0,|L11.80|
000026  60e0              STR      r0,[r4,#0xc]
000028  1c68              ADDS     r0,r5,#1              ;1105
00002a  b285              UXTH     r5,r0                 ;1105
                  |L11.44|
00002c  2d04              CMP      r5,#4                 ;1105
00002e  d3ef              BCC      |L11.16|
;;;1113   #endif
;;;1114       }
;;;1115       pgrp1                 = &OSFlagTbl[ix];
000030  4806              LDR      r0,|L11.76|
000032  eb001405          ADD      r4,r0,r5,LSL #4
;;;1116       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000036  2000              MOVS     r0,#0
000038  7020              STRB     r0,[r4,#0]
;;;1117       pgrp1->OSFlagWaitList = (void *)0;
00003a  6060              STR      r0,[r4,#4]
;;;1118   #if OS_FLAG_NAME_EN > 0u
;;;1119       pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00003c  a004              ADR      r0,|L11.80|
00003e  60e0              STR      r0,[r4,#0xc]
;;;1120   #endif
;;;1121       OSFlagFreeList        = &OSFlagTbl[0];
000040  4802              LDR      r0,|L11.76|
000042  4904              LDR      r1,|L11.84|
000044  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1122   #endif
;;;1123   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1124   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      OSFlagTbl
                  |L11.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0
                  |L11.84|
                          DCD      OSFlagFreeList

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_FlagTaskRdy PROC
;;;1148   
;;;1149   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1150                                    OS_FLAGS      flags_rdy)
;;;1151   {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;1152       OS_TCB   *ptcb;
;;;1153       BOOLEAN   sched;
;;;1154   
;;;1155   
;;;1156       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000006  68b4              LDR      r4,[r6,#8]
;;;1157       ptcb->OSTCBDly       = 0u;
000008  2000              MOVS     r0,#0
00000a  f104042c          ADD      r4,r4,#0x2c
00000e  6060              STR      r0,[r4,#4]
;;;1158       ptcb->OSTCBFlagsRdy  = flags_rdy;
000010  8027              STRH     r7,[r4,#0]
;;;1159       ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000012  7a20              LDRB     r0,[r4,#8]
000014  f00000df          AND      r0,r0,#0xdf
000018  7220              STRB     r0,[r4,#8]
;;;1160       ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
00001a  f04f0000          MOV      r0,#0
00001e  7260              STRB     r0,[r4,#9]
;;;1161       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000020  7a20              LDRB     r0,[r4,#8]
000022  f1a4042c          SUB      r4,r4,#0x2c
000026  b9a8              CBNZ     r0,|L12.84|
;;;1162           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000028  f1040438          ADD      r4,r4,#0x38
00002c  78a0              LDRB     r0,[r4,#2]
00002e  490c              LDR      r1,|L12.96|
000030  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000032  ea400001          ORR      r0,r0,r1
000036  490a              LDR      r1,|L12.96|
000038  7008              STRB     r0,[r1,#0]
;;;1163           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00003a  7820              LDRB     r0,[r4,#0]
00003c  4909              LDR      r1,|L12.100|
00003e  5c08              LDRB     r0,[r1,r0]
000040  7861              LDRB     r1,[r4,#1]
000042  ea400001          ORR      r0,r0,r1
000046  f8141938          LDRB     r1,[r4],#-0x38
00004a  4a06              LDR      r2,|L12.100|
00004c  5450              STRB     r0,[r2,r1]
;;;1164           sched                   = OS_TRUE;
00004e  f04f0501          MOV      r5,#1
000052  e000              B        |L12.86|
                  |L12.84|
;;;1165       } else {
;;;1166           sched                   = OS_FALSE;
000054  2500              MOVS     r5,#0
                  |L12.86|
;;;1167       }
;;;1168       OS_FlagUnlink(pnode);
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       OS_FlagUnlink
;;;1169       return (sched);
00005c  4628              MOV      r0,r5
;;;1170   }
00005e  bdf0              POP      {r4-r7,pc}
;;;1171   
                          ENDP

                  |L12.96|
                          DCD      OSRdyGrp
                  |L12.100|
                          DCD      OSRdyTbl

                          AREA ||i.OS_FlagUnlink||, CODE, READONLY, ALIGN=1

                  OS_FlagUnlink PROC
;;;1193   
;;;1194   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000000  b530              PUSH     {r4,r5,lr}
;;;1195   {
000002  4601              MOV      r1,r0
;;;1196   #if OS_TASK_DEL_EN > 0u
;;;1197       OS_TCB       *ptcb;
;;;1198   #endif
;;;1199       OS_FLAG_GRP  *pgrp;
;;;1200       OS_FLAG_NODE *pnode_prev;
;;;1201       OS_FLAG_NODE *pnode_next;
;;;1202   
;;;1203   
;;;1204       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000004  684a              LDR      r2,[r1,#4]
;;;1205       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000006  6808              LDR      r0,[r1,#0]
;;;1206       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000008  b92a              CBNZ     r2,|L13.22|
;;;1207           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00000a  68cc              LDR      r4,[r1,#0xc]
;;;1208           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00000c  6060              STR      r0,[r4,#4]
;;;1209           if (pnode_next != (OS_FLAG_NODE *)0) {
00000e  b128              CBZ      r0,|L13.28|
;;;1210               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
000010  2500              MOVS     r5,#0
000012  6045              STR      r5,[r0,#4]
000014  e002              B        |L13.28|
                  |L13.22|
;;;1211           }
;;;1212       } else {                                                    /* No,  A node somewhere in the list   */
;;;1213           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000016  6010              STR      r0,[r2,#0]
;;;1214           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000018  b100              CBZ      r0,|L13.28|
;;;1215               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00001a  6042              STR      r2,[r0,#4]
                  |L13.28|
;;;1216           }
;;;1217       }
;;;1218   #if OS_TASK_DEL_EN > 0u
;;;1219       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00001c  688b              LDR      r3,[r1,#8]
;;;1220       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00001e  2500              MOVS     r5,#0
000020  629d              STR      r5,[r3,#0x28]
;;;1221   #endif
;;;1222   }
000022  bd30              POP      {r4,r5,pc}
;;;1223   #endif
                          ENDP

