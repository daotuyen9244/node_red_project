; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\wm.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\WM\WM.c]
                          THUMB

                          AREA ||i.ResetNextDrawWin||, CODE, READONLY, ALIGN=2

                  ResetNextDrawWin PROC
;;;155    */
;;;156    static void ResetNextDrawWin(void) {
000000  2000              MOVS     r0,#0
;;;157      NextDrawWin = WM_HWIN_NULL;
000002  4901              LDR      r1,|L1.8|
000004  8008              STRH     r0,[r1,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP

                  |L1.8|
                          DCD      NextDrawWin

                          AREA ||i.WM_Activate||, CODE, READONLY, ALIGN=2

                  WM_Activate PROC
;;;1730   */
;;;1731   void WM_Activate(void) {
000000  2001              MOVS     r0,#1
;;;1732     WM_IsActive = 1;       /* Running */
000002  4901              LDR      r1,|L2.8|
000004  7008              STRB     r0,[r1,#0]
;;;1733   }
000006  4770              BX       lr
;;;1734   
                          ENDP

                  |L2.8|
                          DCD      WM_IsActive

                          AREA ||i.WM_CreateWindow||, CODE, READONLY, ALIGN=1

                  WM_CreateWindow PROC
;;;928    */
;;;929    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
000010  f8dd8030          LDR      r8,[sp,#0x30]
;;;930      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
000014  2000              MOVS     r0,#0
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  e88d0701          STM      sp,{r0,r8-r10}
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       WM_CreateWindowAsChild
;;;931    }
000026  b004              ADD      sp,sp,#0x10
000028  e8bd87f0          POP      {r4-r10,pc}
;;;932    
                          ENDP


                          AREA ||i.WM_CreateWindowAsChild||, CODE, READONLY, ALIGN=2

                  WM_CreateWindowAsChild PROC
;;;843    */
;;;844    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;845                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;846                                   ,int NumExtraBytes) {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
00000c  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;847      WM_Obj* pWin;
;;;848      WM_HWIN hWin;
;;;849      WM_ASSERT_NOT_IN_PAINT();
;;;850      WM_LOCK();
000010  f7fffffe          BL       GUI_Lock
;;;851      Style |= WM__CreateFlags;
000014  4841              LDR      r0,|L4.284|
000016  8800              LDRH     r0,[r0,#0]  ; WM__CreateFlags
000018  4305              ORRS     r5,r5,r0
;;;852      /* Default parent is Desktop 0 */
;;;853      if (!hParent) {
00001a  b92f              CBNZ     r7,|L4.40|
;;;854        if (WM__NumWindows) {
00001c  4840              LDR      r0,|L4.288|
00001e  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
000020  b110              CBZ      r0,|L4.40|
;;;855        #if GUI_NUM_LAYERS == 1
;;;856          hParent = WM__ahDesktopWin[0];
000022  4840              LDR      r0,|L4.292|
000024  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L4.40|
;;;857        #else
;;;858          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;859        #endif
;;;860        }
;;;861      }
;;;862      if (hParent == WM_UNATTACHED) {
000028  1c78              ADDS     r0,r7,#1
00002a  d100              BNE      |L4.46|
;;;863        hParent = WM_HWIN_NULL;
00002c  2700              MOVS     r7,#0
                  |L4.46|
;;;864      }  
;;;865      if (hParent) {
00002e  b1f7              CBZ      r7,|L4.110|
;;;866        WM_Obj* pParent = WM_H2P(hParent);
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       GUI_ALLOC_h2p
000036  4606              MOV      r6,r0
;;;867        x0 += pParent->Rect.x0;
000038  f9b60000          LDRSH    r0,[r6,#0]
00003c  4480              ADD      r8,r8,r0
;;;868        y0 += pParent->Rect.y0;
00003e  f9b60002          LDRSH    r0,[r6,#2]
000042  4481              ADD      r9,r9,r0
;;;869        if (width==0) {
000044  f1ba0f00          CMP      r10,#0
000048  d106              BNE      |L4.88|
;;;870          width = pParent->Rect.x1 - pParent->Rect.x0+1;
00004a  f9b60004          LDRSH    r0,[r6,#4]
00004e  f9b61000          LDRSH    r1,[r6,#0]
000052  1a40              SUBS     r0,r0,r1
000054  f1000a01          ADD      r10,r0,#1
                  |L4.88|
;;;871        }
;;;872        if (height==0) {
000058  f1bb0f00          CMP      r11,#0
00005c  d106              BNE      |L4.108|
;;;873          height = pParent->Rect.y1 - pParent->Rect.y0+1;
00005e  f9b60006          LDRSH    r0,[r6,#6]
000062  f9b61002          LDRSH    r1,[r6,#2]
000066  1a40              SUBS     r0,r0,r1
000068  f1000b01          ADD      r11,r0,#1
                  |L4.108|
;;;874        }
;;;875      }
00006c  bf00              NOP      
                  |L4.110|
;;;876      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
00006e  980d              LDR      r0,[sp,#0x34]
000070  3020              ADDS     r0,r0,#0x20
000072  b200              SXTH     r0,r0
000074  f7fffffe          BL       GUI_ALLOC_AllocZero
000078  9000              STR      r0,[sp,#0]
00007a  2800              CMP      r0,#0
00007c  d049              BEQ      |L4.274|
;;;877        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;878      } else {
;;;879        WM__NumWindows++;
00007e  4828              LDR      r0,|L4.288|
000080  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
000082  1c40              ADDS     r0,r0,#1
000084  4926              LDR      r1,|L4.288|
000086  8008              STRH     r0,[r1,#0]
;;;880        pWin = WM_H2P(hWin);
000088  9800              LDR      r0,[sp,#0]
00008a  f7fffffe          BL       GUI_ALLOC_h2p
00008e  4604              MOV      r4,r0
;;;881        pWin->Rect.x0 = x0;
000090  fa0ff088          SXTH     r0,r8
000094  8020              STRH     r0,[r4,#0]
;;;882        pWin->Rect.y0 = y0;
000096  fa0ff089          SXTH     r0,r9
00009a  8060              STRH     r0,[r4,#2]
;;;883        pWin->Rect.x1 = x0 + width - 1;
00009c  eb08000a          ADD      r0,r8,r10
0000a0  1e40              SUBS     r0,r0,#1
0000a2  b200              SXTH     r0,r0
0000a4  80a0              STRH     r0,[r4,#4]
;;;884        pWin->Rect.y1 = y0 + height - 1;
0000a6  eb09000b          ADD      r0,r9,r11
0000aa  1e40              SUBS     r0,r0,#1
0000ac  b200              SXTH     r0,r0
0000ae  80e0              STRH     r0,[r4,#6]
;;;885        pWin->cb = cb;
0000b0  980c              LDR      r0,[sp,#0x30]
0000b2  6120              STR      r0,[r4,#0x10]
;;;886        /* Copy the flags which can simply be accepted */
;;;887        pWin->Status |= (Style & (WM_CF_SHOW |
0000b4  8ba0              LDRH     r0,[r4,#0x1c]
0000b6  f643719f          MOV      r1,#0x3f9f
0000ba  4029              ANDS     r1,r1,r5
0000bc  4308              ORRS     r0,r0,r1
0000be  83a0              STRH     r0,[r4,#0x1c]
;;;888                                  WM_SF_MEMDEV |
;;;889                                  WM_CF_MEMDEV_ON_REDRAW |
;;;890                                  WM_SF_STAYONTOP |
;;;891                                  WM_CF_DISABLED |
;;;892                                  WM_SF_CONST_OUTLINE |
;;;893                                  WM_SF_HASTRANS |
;;;894                                  WM_CF_ANCHOR_RIGHT |
;;;895                                  WM_CF_ANCHOR_BOTTOM |
;;;896                                  WM_CF_ANCHOR_LEFT |
;;;897                                  WM_CF_ANCHOR_TOP |
;;;898                                  WM_CF_LATE_CLIP));
;;;899        /* Add to linked lists */
;;;900        _AddToLinList(hWin);
0000c0  9800              LDR      r0,[sp,#0]
0000c2  f7fffffe          BL       _AddToLinList
;;;901        WM__InsertWindowIntoList(hWin, hParent);
0000c6  4639              MOV      r1,r7
0000c8  9800              LDR      r0,[sp,#0]
0000ca  f7fffffe          BL       WM__InsertWindowIntoList
;;;902        /* Activate window if WM_CF_ACTIVATE is specified */
;;;903        if (Style & WM_CF_ACTIVATE) {
0000ce  f0150f20          TST      r5,#0x20
0000d2  d002              BEQ      |L4.218|
;;;904          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
0000d4  9800              LDR      r0,[sp,#0]
0000d6  f7fffffe          BL       WM_SelectWindow
                  |L4.218|
;;;905        }
;;;906        /* Handle the Style flags, one at a time */
;;;907        #if WM_SUPPORT_TRANSPARENCY
;;;908          if (Style & WM_SF_HASTRANS) {
0000da  f0150f01          TST      r5,#1
0000de  d004              BEQ      |L4.234|
;;;909            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
0000e0  4811              LDR      r0,|L4.296|
0000e2  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
0000e4  1c40              ADDS     r0,r0,#1
0000e6  4910              LDR      r1,|L4.296|
0000e8  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L4.234|
;;;910          }
;;;911        #endif
;;;912        if (Style & WM_CF_BGND) {
0000ea  f0150f40          TST      r5,#0x40
0000ee  d002              BEQ      |L4.246|
;;;913          WM_BringToBottom(hWin);
0000f0  9800              LDR      r0,[sp,#0]
0000f2  f7fffffe          BL       WM_BringToBottom
                  |L4.246|
;;;914        }
;;;915        if (Style & WM_CF_SHOW) {
0000f6  f0150f02          TST      r5,#2
0000fa  d006              BEQ      |L4.266|
;;;916          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
0000fc  8ba0              LDRH     r0,[r4,#0x1c]
0000fe  f0400002          ORR      r0,r0,#2
000102  83a0              STRH     r0,[r4,#0x1c]
;;;917          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
000104  9800              LDR      r0,[sp,#0]
000106  f7fffffe          BL       WM_InvalidateWindow
                  |L4.266|
;;;918        }
;;;919        WM__SendMsgNoData(hWin, WM_CREATE);
00010a  2101              MOVS     r1,#1
00010c  9800              LDR      r0,[sp,#0]
00010e  f7fffffe          BL       WM__SendMsgNoData
                  |L4.274|
;;;920      }
;;;921      WM_UNLOCK();
000112  f7fffffe          BL       GUI_Unlock
;;;922      return hWin;
000116  9800              LDR      r0,[sp,#0]
;;;923    }
000118  e8bd8ff8          POP      {r3-r11,pc}
;;;924    
                          ENDP

                  |L4.284|
                          DCD      WM__CreateFlags
                  |L4.288|
                          DCD      WM__NumWindows
                  |L4.292|
                          DCD      WM__ahDesktopWin
                  |L4.296|
                          DCD      WM__TransWindowCnt

                          AREA ||i.WM_Deactivate||, CODE, READONLY, ALIGN=2

                  WM_Deactivate PROC
;;;1738   */
;;;1739   void WM_Deactivate(void) {
000000  b510              PUSH     {r4,lr}
;;;1740     WM_IsActive = 0;       /* No clipping performed by WM */
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L5.24|
000006  7008              STRB     r0,[r1,#0]
;;;1741     WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;1742     LCD_SetClipRectMax();
00000c  f7fffffe          BL       LCD_SetClipRectMax
;;;1743     WM_UNLOCK();
000010  f7fffffe          BL       GUI_Unlock
;;;1744   }
000014  bd10              POP      {r4,pc}
;;;1745   
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      WM_IsActive

                          AREA ||i.WM_DefaultProc||, CODE, READONLY, ALIGN=1

                  WM_DefaultProc PROC
;;;1755   */
;;;1756   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1757     WM_HWIN hWin = pMsg->hWin;
000006  f9b45004          LDRSH    r5,[r4,#4]
;;;1758     const void *p = pMsg->Data.p;
00000a  68a6              LDR      r6,[r4,#8]
;;;1759     WM_Obj* pWin = WM_H2P(hWin);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4607              MOV      r7,r0
;;;1760     /* Exec message */
;;;1761     switch (pMsg->MsgId) {
000014  6820              LDR      r0,[r4,#0]
000016  2817              CMP      r0,#0x17
000018  d00f              BEQ      |L6.58|
00001a  dc04              BGT      |L6.38|
00001c  280e              CMP      r0,#0xe
00001e  d00f              BEQ      |L6.64|
000020  2814              CMP      r0,#0x14
000022  d11a              BNE      |L6.90|
000024  e004              B        |L6.48|
                  |L6.38|
000026  2822              CMP      r0,#0x22
000028  d00f              BEQ      |L6.74|
00002a  2828              CMP      r0,#0x28
00002c  d115              BNE      |L6.90|
00002e  e010              B        |L6.82|
                  |L6.48|
;;;1762     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1763       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000030  4631              MOV      r1,r6
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       WM__GetClientRectWin
;;;1764       break;
000038  e00f              B        |L6.90|
                  |L6.58|
;;;1765     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1766       pMsg->Data.v = (int)hWin;
00003a  60a5              STR      r5,[r4,#8]
                  |L6.60|
;;;1767       return;                       /* Message handled */
;;;1768     case WM_KEY:
;;;1769       WM_SendToParent(hWin, pMsg);
;;;1770       return;                       /* Message handled */
;;;1771      case WM_GET_BKCOLOR:
;;;1772       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1773       return;                       /* Message handled */
;;;1774     case WM_NOTIFY_ENABLE:
;;;1775       WM_InvalidateWindow(hWin);    
;;;1776       return;                       /* Message handled */
;;;1777     }
;;;1778     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1779     pMsg->Data.v = 0;
;;;1780     pMsg->Data.p = 0;
;;;1781   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L6.64|
000040  4621              MOV      r1,r4                 ;1769
000042  4628              MOV      r0,r5                 ;1769
000044  f7fffffe          BL       WM_SendToParent
000048  e7f8              B        |L6.60|
                  |L6.74|
00004a  f06f4070          MVN      r0,#0xf0000000        ;1772
00004e  60a0              STR      r0,[r4,#8]            ;1772
000050  e7f4              B        |L6.60|
                  |L6.82|
000052  4628              MOV      r0,r5                 ;1775
000054  f7fffffe          BL       WM_InvalidateWindow
000058  e7f0              B        |L6.60|
                  |L6.90|
00005a  bf00              NOP                            ;1764
00005c  2000              MOVS     r0,#0                 ;1779
00005e  60a0              STR      r0,[r4,#8]            ;1779
000060  60a0              STR      r0,[r4,#8]            ;1780
000062  bf00              NOP      
000064  e7ea              B        |L6.60|
;;;1782   
                          ENDP


                          AREA ||i.WM_DeleteWindow||, CODE, READONLY, ALIGN=2

                  WM_DeleteWindow PROC
;;;942    */
;;;943    void WM_DeleteWindow (WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;944      WM_Obj* pWin;
;;;945      if (!hWin) {
000004  b904              CBNZ     r4,|L7.8|
                  |L7.6|
;;;946        return;
;;;947      }
;;;948      WM_ASSERT_NOT_IN_PAINT();
;;;949      WM_LOCK();
;;;950      if (WM__IsWindow(hWin)) {
;;;951        pWin = WM_H2P(hWin);
;;;952        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;953      /* Make sure that focus is set to an existing window */
;;;954        if (WM__hWinFocus == hWin) {
;;;955          WM__hWinFocus = 0;
;;;956        }
;;;957        if (WM__hCapture == hWin) {
;;;958          WM__hCapture = 0;
;;;959        }
;;;960        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;961        _CheckCriticalHandles(hWin);
;;;962        /* Inform parent */
;;;963        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;964        /* Delete all children */
;;;965        _DeleteAllChildren(pWin);
;;;966        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;967          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;968        #endif
;;;969        /* Send WM_DELETE message to window in order to inform window itself */
;;;970        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;971        WM__DetachWindow(hWin);
;;;972        /* Remove window from window stack */
;;;973        WM__RemoveFromLinList(hWin);
;;;974        /* Handle transparency counter if necessary */
;;;975        #if WM_SUPPORT_TRANSPARENCY
;;;976          if (pWin->Status & WM_SF_HASTRANS) {
;;;977            WM__TransWindowCnt--;
;;;978          }
;;;979        #endif
;;;980        /* Make sure window is no longer counted as invalid */
;;;981        if (pWin->Status & WM_SF_INVALID) {
;;;982          WM__NumInvalidWindows--;
;;;983        }
;;;984      /* Free window memory */
;;;985        WM__NumWindows--;
;;;986        GUI_ALLOC_Free(hWin);
;;;987      /* Select a valid window */
;;;988        WM_SelectWindow(WM__FirstWin);
;;;989      } else {
;;;990        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;991      }
;;;992      WM_UNLOCK();
;;;993    }
000006  bd70              POP      {r4-r6,pc}
                  |L7.8|
000008  f7fffffe          BL       GUI_Lock
00000c  4620              MOV      r0,r4                 ;950
00000e  f7fffffe          BL       WM__IsWindow
000012  2800              CMP      r0,#0                 ;950
000014  d048              BEQ      |L7.168|
000016  4620              MOV      r0,r4                 ;951
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4605              MOV      r5,r0                 ;951
00001e  f7fffffe          BL       ResetNextDrawWin
000022  4823              LDR      r0,|L7.176|
000024  f9b00000          LDRSH    r0,[r0,#0]            ;954  ; WM__hWinFocus
000028  42a0              CMP      r0,r4                 ;954
00002a  d102              BNE      |L7.50|
00002c  2000              MOVS     r0,#0                 ;955
00002e  4920              LDR      r1,|L7.176|
000030  8008              STRH     r0,[r1,#0]            ;955
                  |L7.50|
000032  4820              LDR      r0,|L7.180|
000034  f9b00000          LDRSH    r0,[r0,#0]            ;957  ; WM__hCapture
000038  42a0              CMP      r0,r4                 ;957
00003a  d102              BNE      |L7.66|
00003c  2000              MOVS     r0,#0                 ;958
00003e  491d              LDR      r1,|L7.180|
000040  8008              STRH     r0,[r1,#0]            ;958
                  |L7.66|
000042  4620              MOV      r0,r4                 ;961
000044  f7fffffe          BL       _CheckCriticalHandles
000048  2107              MOVS     r1,#7                 ;963
00004a  4620              MOV      r0,r4                 ;963
00004c  f7fffffe          BL       WM_NotifyParent
000050  4628              MOV      r0,r5                 ;965
000052  f7fffffe          BL       _DeleteAllChildren
000056  210b              MOVS     r1,#0xb               ;970
000058  4620              MOV      r0,r4                 ;970
00005a  f7fffffe          BL       WM__SendMsgNoData
00005e  4620              MOV      r0,r4                 ;971
000060  f7fffffe          BL       WM__DetachWindow
000064  4620              MOV      r0,r4                 ;973
000066  f7fffffe          BL       WM__RemoveFromLinList
00006a  7f28              LDRB     r0,[r5,#0x1c]         ;976
00006c  f0100f01          TST      r0,#1                 ;976
000070  d004              BEQ      |L7.124|
000072  4811              LDR      r0,|L7.184|
000074  6800              LDR      r0,[r0,#0]            ;977  ; WM__TransWindowCnt
000076  1e40              SUBS     r0,r0,#1              ;977
000078  490f              LDR      r1,|L7.184|
00007a  6008              STR      r0,[r1,#0]            ;977  ; WM__TransWindowCnt
                  |L7.124|
00007c  7f28              LDRB     r0,[r5,#0x1c]         ;981
00007e  f0100f20          TST      r0,#0x20              ;981
000082  d004              BEQ      |L7.142|
000084  480d              LDR      r0,|L7.188|
000086  8800              LDRH     r0,[r0,#0]            ;982  ; WM__NumInvalidWindows
000088  1e40              SUBS     r0,r0,#1              ;982
00008a  490c              LDR      r1,|L7.188|
00008c  8008              STRH     r0,[r1,#0]            ;982
                  |L7.142|
00008e  480c              LDR      r0,|L7.192|
000090  8800              LDRH     r0,[r0,#0]            ;985  ; WM__NumWindows
000092  1e40              SUBS     r0,r0,#1              ;985
000094  490a              LDR      r1,|L7.192|
000096  8008              STRH     r0,[r1,#0]            ;985
000098  4620              MOV      r0,r4                 ;986
00009a  f7fffffe          BL       GUI_ALLOC_Free
00009e  4809              LDR      r0,|L7.196|
0000a0  f9b00000          LDRSH    r0,[r0,#0]            ;988  ; WM__FirstWin
0000a4  f7fffffe          BL       WM_SelectWindow
                  |L7.168|
0000a8  f7fffffe          BL       GUI_Unlock
0000ac  bf00              NOP      
0000ae  e7aa              B        |L7.6|
;;;994    
                          ENDP

                  |L7.176|
                          DCD      WM__hWinFocus
                  |L7.180|
                          DCD      WM__hCapture
                  |L7.184|
                          DCD      WM__TransWindowCnt
                  |L7.188|
                          DCD      WM__NumInvalidWindows
                  |L7.192|
                          DCD      WM__NumWindows
                  |L7.196|
                          DCD      WM__FirstWin

                          AREA ||i.WM_Exec||, CODE, READONLY, ALIGN=1

                  WM_Exec PROC
;;;1683   */
;;;1684   int WM_Exec(void) {
000000  b510              PUSH     {r4,lr}
;;;1685     int r = 0;
000002  2400              MOVS     r4,#0
;;;1686     while (WM_Exec1()) {
000004  e000              B        |L8.8|
                  |L8.6|
;;;1687       r = 1;                  /* We have done something */
000006  2401              MOVS     r4,#1
                  |L8.8|
000008  f7fffffe          BL       WM_Exec1
00000c  2800              CMP      r0,#0                 ;1686
00000e  d1fa              BNE      |L8.6|
;;;1688     }
;;;1689     return r;
000010  4620              MOV      r0,r4
;;;1690   }
000012  bd10              POP      {r4,pc}
;;;1691   
                          ENDP


                          AREA ||i.WM_Exec1||, CODE, READONLY, ALIGN=2

                  WM_Exec1 PROC
;;;1651   */
;;;1652   int WM_Exec1(void) {
000000  b510              PUSH     {r4,lr}
;;;1653     /* Poll PID if necessary */
;;;1654     if (WM_pfPollPID) {
000002  4813              LDR      r0,|L9.80|
000004  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000006  b110              CBZ      r0,|L9.14|
;;;1655       WM_pfPollPID();
000008  4811              LDR      r0,|L9.80|
00000a  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
00000c  4780              BLX      r0
                  |L9.14|
;;;1656     }
;;;1657     if (WM_pfHandlePID) {
00000e  4811              LDR      r0,|L9.84|
000010  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000012  b128              CBZ      r0,|L9.32|
;;;1658       if (WM_pfHandlePID())
000014  480f              LDR      r0,|L9.84|
000016  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000018  4780              BLX      r0
00001a  b108              CBZ      r0,|L9.32|
;;;1659         return 1;               /* We have done something ... */
00001c  2001              MOVS     r0,#1
                  |L9.30|
;;;1660     }
;;;1661     if (WM_IsActive) {
;;;1662       if (GUI_PollKeyMsg()) {
;;;1663         return 1;               /* We have done something ... */
;;;1664       }
;;;1665     }
;;;1666   #ifdef WIN32
;;;1667     if (WM_PollSimMsg()) {
;;;1668       return 1;               /* We have done something ... */
;;;1669     }
;;;1670   #endif
;;;1671     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1672       WM_LOCK();
;;;1673       _DrawNext();
;;;1674       WM_UNLOCK();
;;;1675       return 1;               /* We have done something ... */
;;;1676     }
;;;1677     return 0;                  /* There was nothing to do ... */
;;;1678   }
00001e  bd10              POP      {r4,pc}
                  |L9.32|
000020  480d              LDR      r0,|L9.88|
000022  7800              LDRB     r0,[r0,#0]            ;1661  ; WM_IsActive
000024  b120              CBZ      r0,|L9.48|
000026  f7fffffe          BL       GUI_PollKeyMsg
00002a  b108              CBZ      r0,|L9.48|
00002c  2001              MOVS     r0,#1                 ;1663
00002e  e7f6              B        |L9.30|
                  |L9.48|
000030  4809              LDR      r0,|L9.88|
000032  7800              LDRB     r0,[r0,#0]            ;1671  ; WM_IsActive
000034  b150              CBZ      r0,|L9.76|
000036  4809              LDR      r0,|L9.92|
000038  8800              LDRH     r0,[r0,#0]            ;1671  ; WM__NumInvalidWindows
00003a  b138              CBZ      r0,|L9.76|
00003c  f7fffffe          BL       GUI_Lock
000040  f7fffffe          BL       _DrawNext
000044  f7fffffe          BL       GUI_Unlock
000048  2001              MOVS     r0,#1                 ;1675
00004a  e7e8              B        |L9.30|
                  |L9.76|
00004c  2000              MOVS     r0,#0                 ;1677
00004e  e7e6              B        |L9.30|
;;;1679   
                          ENDP

                  |L9.80|
                          DCD      WM_pfPollPID
                  |L9.84|
                          DCD      WM_pfHandlePID
                  |L9.88|
                          DCD      WM_IsActive
                  |L9.92|
                          DCD      WM__NumInvalidWindows

                          AREA ||i.WM_GetActiveWindow||, CODE, READONLY, ALIGN=2

                  WM_GetActiveWindow PROC
;;;1036   */
;;;1037   WM_HWIN WM_GetActiveWindow(void) {
000000  4801              LDR      r0,|L10.8|
;;;1038     return GUI_Context.hAWin;
000002  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
;;;1039   }
000006  4770              BX       lr
;;;1040   
                          ENDP

                  |L10.8|
                          DCD      GUI_Context

                          AREA ||i.WM_Init||, CODE, READONLY, ALIGN=2

                  WM_Init PROC
;;;1786   */
;;;1787   void WM_Init(void) {
000000  b50e              PUSH     {r1-r3,lr}
;;;1788   	if (!_IsInited) {
000002  481a              LDR      r0,|L11.108|
000004  7800              LDRB     r0,[r0,#0]  ; _IsInited
000006  bb80              CBNZ     r0,|L11.106|
;;;1789   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
000008  2000              MOVS     r0,#0
00000a  4919              LDR      r1,|L11.112|
00000c  8008              STRH     r0,[r1,#0]
00000e  4919              LDR      r1,|L11.116|
000010  8008              STRH     r0,[r1,#0]
;;;1790   	  GUI_Context.WM__pUserClipRect = NULL;
000012  4919              LDR      r1,|L11.120|
000014  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
;;;1791   	  WM__NumWindows = WM__NumInvalidWindows =0;
000016  4919              LDR      r1,|L11.124|
000018  8008              STRH     r0,[r1,#0]
00001a  4919              LDR      r1,|L11.128|
00001c  8008              STRH     r0,[r1,#0]
;;;1792   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1793   		  drawing routines as they do not have to check if the window is valid.
;;;1794   	  */
;;;1795       #if GUI_NUM_LAYERS == 1
;;;1796         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
00001e  4919              LDR      r1,|L11.132|
000020  2202              MOVS     r2,#2
000022  f64073ff          MOV      r3,#0xfff
000026  e9cd2100          STRD     r2,r1,[sp,#0]
00002a  9002              STR      r0,[sp,#8]
00002c  461a              MOV      r2,r3
00002e  4601              MOV      r1,r0
000030  f7fffffe          BL       WM_CreateWindow
000034  4914              LDR      r1,|L11.136|
000036  8008              STRH     r0,[r1,#0]
;;;1797         WM__aBkColor[0] = GUI_INVALID_COLOR;
000038  f06f4070          MVN      r0,#0xf0000000
00003c  4913              LDR      r1,|L11.140|
00003e  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1798         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
000040  4911              LDR      r1,|L11.136|
000042  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
000046  f7fffffe          BL       WM_InvalidateWindow
;;;1799       #else
;;;1800       {
;;;1801         int i;
;;;1802         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1803           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1804           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1805           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1806         }
;;;1807       }
;;;1808       #endif
;;;1809       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1810       WM__AddCriticalHandle(&WM__CHWinModal);
00004a  4811              LDR      r0,|L11.144|
00004c  f7fffffe          BL       WM__AddCriticalHandle
;;;1811       WM__AddCriticalHandle(&WM__CHWinLast);
000050  4810              LDR      r0,|L11.148|
000052  f7fffffe          BL       WM__AddCriticalHandle
;;;1812       #if GUI_SUPPORT_MOUSE
;;;1813         WM__AddCriticalHandle(&WM__CHWinMouseOver);
;;;1814       #endif
;;;1815   
;;;1816       WM_SelectWindow(WM__ahDesktopWin[0]);
000056  490c              LDR      r1,|L11.136|
000058  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
00005c  f7fffffe          BL       WM_SelectWindow
;;;1817   	  WM_Activate();
000060  f7fffffe          BL       WM_Activate
;;;1818       _IsInited =1;
000064  2001              MOVS     r0,#1
000066  4901              LDR      r1,|L11.108|
000068  7008              STRB     r0,[r1,#0]
                  |L11.106|
;;;1819   	}
;;;1820   }
00006a  bd0e              POP      {r1-r3,pc}
;;;1821   
                          ENDP

                  |L11.108|
                          DCD      _IsInited
                  |L11.112|
                          DCD      WM__FirstWin
                  |L11.116|
                          DCD      NextDrawWin
                  |L11.120|
                          DCD      GUI_Context
                  |L11.124|
                          DCD      WM__NumInvalidWindows
                  |L11.128|
                          DCD      WM__NumWindows
                  |L11.132|
                          DCD      cbBackWin
                  |L11.136|
                          DCD      WM__ahDesktopWin
                  |L11.140|
                          DCD      WM__aBkColor
                  |L11.144|
                          DCD      WM__CHWinModal
                  |L11.148|
                          DCD      WM__CHWinLast

                          AREA ||i.WM_InvalidateRect||, CODE, READONLY, ALIGN=1

                  WM_InvalidateRect PROC
;;;795    */
;;;796    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;797      GUI_RECT r;
;;;798      WM_Obj* pWin;
;;;799      int Status;
;;;800      if (hWin) {
000008  2d00              CMP      r5,#0
00000a  d033              BEQ      |L12.116|
;;;801        WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;802        pWin = WM_H2P(hWin);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4604              MOV      r4,r0
;;;803        Status = pWin->Status;
000018  8ba7              LDRH     r7,[r4,#0x1c]
;;;804        if (Status & WM_SF_ISVIS) {
00001a  f0170f02          TST      r7,#2
00001e  d027              BEQ      |L12.112|
;;;805          r = pWin->Rect;
000020  e9d40100          LDRD     r0,r1,[r4,#0]
000024  e9cd0102          STRD     r0,r1,[sp,#8]
;;;806          if (pRect) {
000028  b166              CBZ      r6,|L12.68|
;;;807            GUI_RECT rPara;
;;;808            rPara = *pRect;
00002a  6830              LDR      r0,[r6,#0]
00002c  9000              STR      r0,[sp,#0]
00002e  6870              LDR      r0,[r6,#4]
000030  9001              STR      r0,[sp,#4]
;;;809            WM__Client2Screen(pWin, &rPara);
000032  4669              MOV      r1,sp
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       WM__Client2Screen
;;;810            GUI__IntersectRect(&r, &rPara);
00003a  4669              MOV      r1,sp
00003c  a802              ADD      r0,sp,#8
00003e  f7fffffe          BL       GUI__IntersectRect
;;;811          }
000042  bf00              NOP      
                  |L12.68|
;;;812          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
000044  4629              MOV      r1,r5
000046  a802              ADD      r0,sp,#8
000048  f7fffffe          BL       WM__ClipAtParentBorders
00004c  b180              CBZ      r0,|L12.112|
;;;813            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
00004e  f6400001          MOV      r0,#0x801
000052  4038              ANDS     r0,r0,r7
000054  2801              CMP      r0,#1
000056  d107              BNE      |L12.104|
;;;814              WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
000058  f9b4201a          LDRSH    r2,[r4,#0x1a]
00005c  f9b41016          LDRSH    r1,[r4,#0x16]
000060  a802              ADD      r0,sp,#8
000062  f7fffffe          BL       WM__InvalidateRectEx
000066  e003              B        |L12.112|
                  |L12.104|
;;;815            } else {
;;;816              WM__Invalidate1Abs(hWin, &r);
000068  a902              ADD      r1,sp,#8
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       WM__Invalidate1Abs
                  |L12.112|
;;;817            }
;;;818          }
;;;819        }
;;;820        WM_UNLOCK();
000070  f7fffffe          BL       GUI_Unlock
                  |L12.116|
;;;821      }
;;;822    }
000074  e8bd81ff          POP      {r0-r8,pc}
;;;823    
                          ENDP


                          AREA ||i.WM_InvalidateWindow||, CODE, READONLY, ALIGN=1

                  WM_InvalidateWindow PROC
;;;829    */
;;;830    void WM_InvalidateWindow(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;831      WM_InvalidateRect(hWin, NULL);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       WM_InvalidateRect
;;;832    }
00000c  bd10              POP      {r4,pc}
;;;833    
                          ENDP


                          AREA ||i.WM_InvalidateWindowAndDescsEx||, CODE, READONLY, ALIGN=1

                  WM_InvalidateWindowAndDescsEx PROC
;;;490    */
;;;491    void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;492      GUI_RECT Rect;
;;;493      WM_Obj*  pWin;
;;;494      WM_Obj* pChild;
;;;495      WM_HWIN hChild;
;;;496      int Status;
;;;497    
;;;498      if (hWin) {
000008  b337              CBZ      r7,|L14.88|
;;;499        pWin = WM_H2P(hWin);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4604              MOV      r4,r0
;;;500        Status  = pWin->Status;
000012  f8b4801c          LDRH     r8,[r4,#0x1c]
;;;501        if ((Status & WM_SF_ISVIS) == 0) {
000016  f0180f02          TST      r8,#2
00001a  d101              BNE      |L14.32|
                  |L14.28|
;;;502          return;                                                            /* Window is not visible... we are done */
;;;503        }
;;;504        if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;505          return;                                                            /* No intersection, nothing to do */
;;;506        }
;;;507        WM__Invalidate1Abs(hWin, &Rect);    /* Invalidate window itself */
;;;508        for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
;;;509          WM_InvalidateWindowAndDescsEx(hChild, &Rect);
;;;510          pChild = WM_H2P(hChild);
;;;511        }
;;;512      }
;;;513    }
00001c  e8bd87fc          POP      {r2-r10,pc}
                  |L14.32|
000020  4622              MOV      r2,r4                 ;504
000022  4649              MOV      r1,r9                 ;504
000024  4668              MOV      r0,sp                 ;504
000026  f7fffffe          BL       GUI__IntersectRects
00002a  b900              CBNZ     r0,|L14.46|
00002c  e7f6              B        |L14.28|
                  |L14.46|
00002e  4669              MOV      r1,sp                 ;507
000030  4638              MOV      r0,r7                 ;507
000032  f7fffffe          BL       WM__Invalidate1Abs
000036  4638              MOV      r0,r7                 ;508
000038  f7fffffe          BL       WM_GetFirstChild
00003c  4606              MOV      r6,r0                 ;508
00003e  e009              B        |L14.84|
                  |L14.64|
000040  4669              MOV      r1,sp                 ;509
000042  4630              MOV      r0,r6                 ;509
000044  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
000048  4630              MOV      r0,r6                 ;510
00004a  f7fffffe          BL       GUI_ALLOC_h2p
00004e  4605              MOV      r5,r0                 ;510
000050  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;508
                  |L14.84|
000054  2e00              CMP      r6,#0                 ;508
000056  d1f3              BNE      |L14.64|
                  |L14.88|
000058  bf00              NOP      
00005a  e7df              B        |L14.28|
;;;514    
                          ENDP


                          AREA ||i.WM_SelectWindow||, CODE, READONLY, ALIGN=2

                  WM_SelectWindow PROC
;;;1001   */
;;;1002   WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1003     WM_HWIN hWinPrev;
;;;1004     WM_Obj* pObj;
;;;1005   
;;;1006     WM_ASSERT_NOT_IN_PAINT();
;;;1007     WM_LOCK();
000004  f7fffffe          BL       GUI_Lock
;;;1008     hWinPrev = GUI_Context.hAWin;
000008  480d              LDR      r0,|L15.64|
00000a  f9b06040          LDRSH    r6,[r0,#0x40]  ; GUI_Context
;;;1009     if (hWin == 0) {
00000e  b914              CBNZ     r4,|L15.22|
;;;1010       hWin = WM__FirstWin;
000010  480c              LDR      r0,|L15.68|
000012  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L15.22|
;;;1011     }
;;;1012     /* Select new window */
;;;1013     GUI_Context.hAWin = hWin;
000016  480a              LDR      r0,|L15.64|
000018  f8a04040          STRH     r4,[r0,#0x40]
;;;1014     #if GUI_NUM_LAYERS > 1
;;;1015     {
;;;1016       WM_HWIN hTop;
;;;1017       int LayerIndex;
;;;1018       hTop = _GetTopLevelWindow(hWin);
;;;1019       LayerIndex = _DesktopHandle2Index(hTop);
;;;1020       if (LayerIndex >= 0) {
;;;1021         GUI_SelectLayer(LayerIndex);
;;;1022       }
;;;1023     }
;;;1024     #endif
;;;1025     pObj = WM_H2P(hWin);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GUI_ALLOC_h2p
000022  4605              MOV      r5,r0
;;;1026     LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
000024  f7fffffe          BL       LCD_SetClipRectMax
;;;1027     GUI_Context.xOff = pObj->Rect.x0;
000028  f9b50000          LDRSH    r0,[r5,#0]
00002c  4904              LDR      r1,|L15.64|
00002e  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1028     GUI_Context.yOff = pObj->Rect.y0;
000030  f9b50002          LDRSH    r0,[r5,#2]
000034  6488              STR      r0,[r1,#0x48]  ; GUI_Context
;;;1029     WM_UNLOCK();
000036  f7fffffe          BL       GUI_Unlock
;;;1030     return hWinPrev;
00003a  4630              MOV      r0,r6
;;;1031   }
00003c  bd70              POP      {r4-r6,pc}
;;;1032   
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      GUI_Context
                  |L15.68|
                          DCD      WM__FirstWin

                          AREA ||i.WM_SendMessage||, CODE, READONLY, ALIGN=1

                  WM_SendMessage PROC
;;;741    */
;;;742    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;743      if (hWin) {
000006  b13c              CBZ      r4,|L16.24|
;;;744        WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;745        WM__SendMessage(hWin, pMsg);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       WM__SendMessage
;;;746        WM_UNLOCK();
000014  f7fffffe          BL       GUI_Unlock
                  |L16.24|
;;;747      }  
;;;748    }
000018  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP


                          AREA ||i.WM_SetDefault||, CODE, READONLY, ALIGN=2

                  WM_SetDefault PROC
;;;1326   */
;;;1327   void WM_SetDefault(void) {
000000  b510              PUSH     {r4,lr}
;;;1328     GL_SetDefault();
000002  f7fffffe          BL       GL_SetDefault
;;;1329     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000006  2000              MOVS     r0,#0
000008  4901              LDR      r1,|L17.16|
00000a  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
;;;1330   }
00000c  bd10              POP      {r4,pc}
;;;1331   
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      GUI_Context

                          AREA ||i.WM__ActivateClipRect||, CODE, READONLY, ALIGN=2

                  WM__ActivateClipRect PROC
;;;314    */
;;;315    void  WM__ActivateClipRect(void) {
000000  b51c              PUSH     {r2-r4,lr}
;;;316      if (WM_IsActive) {
000002  480f              LDR      r0,|L18.64|
000004  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000006  b118              CBZ      r0,|L18.16|
;;;317        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000008  480e              LDR      r0,|L18.68|
00000a  f7fffffe          BL       _SetClipRectUserIntersect
00000e  e016              B        |L18.62|
                  |L18.16|
;;;318      } else {    /* Window manager disabled, typically because meory device is active */
;;;319        GUI_RECT r;
;;;320        WM_Obj *pAWin;
;;;321        pAWin = WM_H2P(GUI_Context.hAWin);
000010  490d              LDR      r1,|L18.72|
000012  f9b10040          LDRSH    r0,[r1,#0x40]  ; GUI_Context
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;322        r = pAWin->Rect;
00001c  e9d40100          LDRD     r0,r1,[r4,#0]
000020  e9cd0100          STRD     r0,r1,[sp,#0]
;;;323        #if WM_SUPPORT_TRANSPARENCY
;;;324          if (WM__hATransWindow) {
000024  4809              LDR      r0,|L18.76|
000026  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
000028  b128              CBZ      r0,|L18.54|
;;;325            WM__ClipAtParentBorders(&r, WM__hATransWindow);
00002a  4808              LDR      r0,|L18.76|
00002c  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       WM__ClipAtParentBorders
                  |L18.54|
;;;326          }
;;;327        #endif
;;;328        /* Take UserClipRect into account */
;;;329        _SetClipRectUserIntersect(&r);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       _SetClipRectUserIntersect
;;;330      }
00003c  bf00              NOP      
                  |L18.62|
;;;331    }
00003e  bd1c              POP      {r2-r4,pc}
;;;332    
                          ENDP

                  |L18.64|
                          DCD      WM_IsActive
                  |L18.68|
                          DCD      _ClipContext+0x8
                  |L18.72|
                          DCD      GUI_Context
                  |L18.76|
                          DCD      WM__hATransWindow

                          AREA ||i.WM__Client2Screen||, CODE, READONLY, ALIGN=1

                  WM__Client2Screen PROC
;;;462    */
;;;463    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;464      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
000006  f9b42002          LDRSH    r2,[r4,#2]
00000a  f9b41000          LDRSH    r1,[r4,#0]
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       GUI_MoveRect
;;;465    }
000014  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP


                          AREA ||i.WM__ClipAtParentBorders||, CODE, READONLY, ALIGN=1

                  WM__ClipAtParentBorders PROC
;;;281    */
;;;282    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;283      WM_Obj* pWin;
;;;284    
;;;285      /* Iterate up the window hierarchy.
;;;286         If the window is invisible, we are done.
;;;287         Clip at parent boarders.
;;;288         We are done with iterating if hWin has no parent.
;;;289      */
;;;290      do {
000006  bf00              NOP      
                  |L20.8|
;;;291        pWin = WM_H2P(hWin);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;292        if ((pWin->Status & WM_SF_ISVIS) == 0) {
000010  7f20              LDRB     r0,[r4,#0x1c]
000012  f0100f02          TST      r0,#2
000016  d101              BNE      |L20.28|
;;;293          return 0;                     /* Invisible */
000018  2000              MOVS     r0,#0
                  |L20.26|
;;;294        }
;;;295        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;296        if (pWin->hParent == 0) {
;;;297          break;   /* hWin is now the top level window which has no parent */
;;;298        }
;;;299        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;300      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;301      
;;;302      /* Now check if the top level window is a desktop window. If it is not,
;;;303        then the window is not visible.
;;;304      */
;;;305      if (_DesktopHandle2Index(hWin) < 0) {
;;;306        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;307      }
;;;308      return 1;               /* Something may be visible */
;;;309    }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  4621              MOV      r1,r4                 ;295
00001e  4630              MOV      r0,r6                 ;295
000020  f7fffffe          BL       GUI__IntersectRect
000024  8ae0              LDRH     r0,[r4,#0x16]         ;296
000026  b900              CBNZ     r0,|L20.42|
000028  e002              B        |L20.48|
                  |L20.42|
00002a  f9b45016          LDRSH    r5,[r4,#0x16]         ;299
00002e  e7eb              B        |L20.8|
                  |L20.48|
000030  bf00              NOP                            ;297
000032  4628              MOV      r0,r5                 ;305
000034  f7fffffe          BL       _DesktopHandle2Index
000038  2800              CMP      r0,#0                 ;305
00003a  da01              BGE      |L20.64|
00003c  2000              MOVS     r0,#0                 ;306
00003e  e7ec              B        |L20.26|
                  |L20.64|
000040  2001              MOVS     r0,#1                 ;308
000042  e7ea              B        |L20.26|
;;;310    
                          ENDP


                          AREA ||i.WM__DetachWindow||, CODE, READONLY, ALIGN=1

                  WM__DetachWindow PROC
;;;430    */
;;;431    void WM__DetachWindow(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;432      WM_Obj* pWin;
;;;433      WM_HWIN hParent;
;;;434      pWin = WM_H2P(hWin);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       GUI_ALLOC_h2p
00000a  4604              MOV      r4,r0
;;;435      hParent = pWin->hParent;
00000c  f9b46016          LDRSH    r6,[r4,#0x16]
;;;436      if (hParent) {
000010  b15e              CBZ      r6,|L21.42|
;;;437        WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
000012  f9b4201a          LDRSH    r2,[r4,#0x1a]
000016  f9b41016          LDRSH    r1,[r4,#0x16]
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       WM__InvalidateRectEx
;;;438        WM__RemoveWindowFromList(hWin);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       WM__RemoveWindowFromList
;;;439        pWin->hParent = 0;
000026  2000              MOVS     r0,#0
000028  82e0              STRH     r0,[r4,#0x16]
                  |L21.42|
;;;440      }
;;;441    }
00002a  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP


                          AREA ||i.WM__GetClientRectWin||, CODE, READONLY, ALIGN=1

                  WM__GetClientRectWin PROC
;;;767    */
;;;768    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
000000  2200              MOVS     r2,#0
;;;769      pRect->x0 = pRect->y0 = 0;
000002  804a              STRH     r2,[r1,#2]
000004  800a              STRH     r2,[r1,#0]
;;;770      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
000006  8882              LDRH     r2,[r0,#4]
000008  8803              LDRH     r3,[r0,#0]
00000a  1ad2              SUBS     r2,r2,r3
00000c  b212              SXTH     r2,r2
00000e  808a              STRH     r2,[r1,#4]
;;;771      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
000010  88c2              LDRH     r2,[r0,#6]
000012  8843              LDRH     r3,[r0,#2]
000014  1ad2              SUBS     r2,r2,r3
000016  b212              SXTH     r2,r2
000018  80ca              STRH     r2,[r1,#6]
;;;772    }
00001a  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.WM__GetInvalidRectAbs||, CODE, READONLY, ALIGN=1

                  WM__GetInvalidRectAbs PROC
;;;777    */
;;;778    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
000000  6882              LDR      r2,[r0,#8]
;;;779      *pRect = pWin->InvalidRect;
000002  600a              STR      r2,[r1,#0]
000004  68c2              LDR      r2,[r0,#0xc]
000006  604a              STR      r2,[r1,#4]
;;;780    }
000008  4770              BX       lr
;;;781    
                          ENDP


                          AREA ||i.WM__GetNextIVR||, CODE, READONLY, ALIGN=2

                  WM__GetNextIVR PROC
;;;1210   */
;;;1211   int  WM__GetNextIVR(void) {
000000  b510              PUSH     {r4,lr}
;;;1212     #if GUI_SUPPORT_CURSOR
;;;1213       static char _CursorHidden;
;;;1214     #endif
;;;1215     /* If WM is not active, we have no rectangles to return */
;;;1216     if (WM_IsActive==0) {
000002  481b              LDR      r0,|L24.112|
000004  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000006  b908              CBNZ     r0,|L24.12|
;;;1217       return 0;
000008  2000              MOVS     r0,#0
                  |L24.10|
;;;1218     }
;;;1219     if (_ClipContext.EntranceCnt > 1) {
;;;1220       _ClipContext.EntranceCnt--;
;;;1221       return 0;
;;;1222     }
;;;1223     #if GUI_SUPPORT_CURSOR
;;;1224       if (_CursorHidden) {
;;;1225         _CursorHidden = 0;
;;;1226         (*GUI_CURSOR_pfTempUnhide) ();
;;;1227       }
;;;1228     #endif
;;;1229     ++_ClipContext.Cnt;
;;;1230     /* Find next rectangle and use it as ClipRect */
;;;1231     if (!_FindNext_IVR()) {
;;;1232       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1233       return 0;        /* Could not find an other one ! */
;;;1234     }
;;;1235     WM__ActivateClipRect();
;;;1236     /* Hide cursor if necessary */
;;;1237     #if GUI_SUPPORT_CURSOR
;;;1238       if (GUI_CURSOR_pfTempHide) {
;;;1239         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1240       }
;;;1241     #endif
;;;1242     return 1;
;;;1243   }
00000a  bd10              POP      {r4,pc}
                  |L24.12|
00000c  4819              LDR      r0,|L24.116|
00000e  6940              LDR      r0,[r0,#0x14]         ;1219  ; _ClipContext
000010  2801              CMP      r0,#1                 ;1219
000012  dd06              BLE      |L24.34|
000014  4817              LDR      r0,|L24.116|
000016  6940              LDR      r0,[r0,#0x14]         ;1220  ; _ClipContext
000018  1e40              SUBS     r0,r0,#1              ;1220
00001a  4916              LDR      r1,|L24.116|
00001c  6148              STR      r0,[r1,#0x14]         ;1220  ; _ClipContext
00001e  2000              MOVS     r0,#0                 ;1221
000020  e7f3              B        |L24.10|
                  |L24.34|
000022  4815              LDR      r0,|L24.120|
000024  7800              LDRB     r0,[r0,#0]            ;1224  ; _CursorHidden
000026  b128              CBZ      r0,|L24.52|
000028  2000              MOVS     r0,#0                 ;1225
00002a  4913              LDR      r1,|L24.120|
00002c  7008              STRB     r0,[r1,#0]            ;1225
00002e  4813              LDR      r0,|L24.124|
000030  6800              LDR      r0,[r0,#0]            ;1226  ; GUI_CURSOR_pfTempUnhide
000032  4780              BLX      r0                    ;1226
                  |L24.52|
000034  480f              LDR      r0,|L24.116|
000036  6900              LDR      r0,[r0,#0x10]         ;1229  ; _ClipContext
000038  1c40              ADDS     r0,r0,#1              ;1229
00003a  490e              LDR      r1,|L24.116|
00003c  6108              STR      r0,[r1,#0x10]         ;1229  ; _ClipContext
00003e  f7fffffe          BL       _FindNext_IVR
000042  b930              CBNZ     r0,|L24.82|
000044  480b              LDR      r0,|L24.116|
000046  6940              LDR      r0,[r0,#0x14]         ;1232  ; _ClipContext
000048  1e40              SUBS     r0,r0,#1              ;1232
00004a  490a              LDR      r1,|L24.116|
00004c  6148              STR      r0,[r1,#0x14]         ;1232  ; _ClipContext
00004e  2000              MOVS     r0,#0                 ;1233
000050  e7db              B        |L24.10|
                  |L24.82|
000052  f7fffffe          BL       WM__ActivateClipRect
000056  480a              LDR      r0,|L24.128|
000058  6800              LDR      r0,[r0,#0]            ;1238  ; GUI_CURSOR_pfTempHide
00005a  b130              CBZ      r0,|L24.106|
00005c  4805              LDR      r0,|L24.116|
00005e  3008              ADDS     r0,r0,#8              ;1239
000060  4907              LDR      r1,|L24.128|
000062  6809              LDR      r1,[r1,#0]            ;1239  ; GUI_CURSOR_pfTempHide
000064  4788              BLX      r1                    ;1239
000066  4904              LDR      r1,|L24.120|
000068  7008              STRB     r0,[r1,#0]            ;1239
                  |L24.106|
00006a  2001              MOVS     r0,#1                 ;1242
00006c  e7cd              B        |L24.10|
;;;1244   
                          ENDP

00006e  0000              DCW      0x0000
                  |L24.112|
                          DCD      WM_IsActive
                  |L24.116|
                          DCD      _ClipContext
                  |L24.120|
                          DCD      _CursorHidden
                  |L24.124|
                          DCD      GUI_CURSOR_pfTempUnhide
                  |L24.128|
                          DCD      GUI_CURSOR_pfTempHide

                          AREA ||i.WM__InitIVRSearch||, CODE, READONLY, ALIGN=2

                  WM__InitIVRSearch PROC
;;;1256   */
;;;1257   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4605              MOV      r5,r0
;;;1258     GUI_RECT r;
;;;1259     WM_Obj* pAWin;
;;;1260     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1261      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1262     if (WM_IsActive==0) {
000004  483c              LDR      r0,|L25.248|
000006  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000008  b920              CBNZ     r0,|L25.20|
;;;1263       WM__ActivateClipRect();
00000a  f7fffffe          BL       WM__ActivateClipRect
;;;1264       return 1;
00000e  2001              MOVS     r0,#1
                  |L25.16|
;;;1265     }
;;;1266     /* If we entered multiple times, leave Cliprect alone */
;;;1267     if (++_ClipContext.EntranceCnt > 1)
;;;1268       return 1;
;;;1269     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1270     _ClipContext.Cnt        = -1;
;;;1271    /* When using callback mechanism, it is legal to reduce drawing
;;;1272       area to the invalid area ! */
;;;1273     if (WM__PaintCallbackCnt) {
;;;1274       WM__GetInvalidRectAbs(pAWin, &r);
;;;1275     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1276       if (pAWin->Status & WM_SF_ISVIS) {
;;;1277         r = pAWin->Rect;
;;;1278       } else {
;;;1279         --_ClipContext.EntranceCnt;
;;;1280         return 0;  /* window is not even visible ! */
;;;1281       }
;;;1282     }
;;;1283     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1284     if (pMaxRect) {
;;;1285       GUI__IntersectRect(&r, pMaxRect);
;;;1286     }
;;;1287     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1288     if (GUI_Context.WM__pUserClipRect) {
;;;1289       WM_Obj* pWin = pAWin;
;;;1290       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1291       #if WM_SUPPORT_TRANSPARENCY
;;;1292         if (WM__hATransWindow) {
;;;1293           pWin = WM_H2P(WM__hATransWindow);
;;;1294         }   
;;;1295       #endif
;;;1296       WM__Client2Screen(pWin, &rUser);
;;;1297       GUI__IntersectRect(&r, &rUser);
;;;1298     }
;;;1299     /* For transparent windows, we need to further reduce the rectangle */
;;;1300     #if WM_SUPPORT_TRANSPARENCY
;;;1301       if (WM__hATransWindow) {
;;;1302         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1303           --_ClipContext.EntranceCnt;
;;;1304           return 0;           /* Nothing to draw */
;;;1305         }
;;;1306       }
;;;1307     #endif
;;;1308     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1309     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1310       --_ClipContext.EntranceCnt;
;;;1311       return 0;           /* Nothing to draw */
;;;1312     }
;;;1313     /* Store the rectangle and find the first rectangle of the area */
;;;1314     _ClipContext.ClientRect = r;
;;;1315     return WM__GetNextIVR();
;;;1316   }
000010  b004              ADD      sp,sp,#0x10
000012  bd70              POP      {r4-r6,pc}
                  |L25.20|
000014  4839              LDR      r0,|L25.252|
000016  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000018  1c40              ADDS     r0,r0,#1              ;1267
00001a  4938              LDR      r1,|L25.252|
00001c  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
00001e  2801              CMP      r0,#1                 ;1267
000020  dd01              BLE      |L25.38|
000022  2001              MOVS     r0,#1                 ;1268
000024  e7f4              B        |L25.16|
                  |L25.38|
000026  4936              LDR      r1,|L25.256|
000028  f9b10040          LDRSH    r0,[r1,#0x40]         ;1269  ; GUI_Context
00002c  f7fffffe          BL       GUI_ALLOC_h2p
000030  4604              MOV      r4,r0                 ;1269
000032  f04f30ff          MOV      r0,#0xffffffff        ;1270
000036  4931              LDR      r1,|L25.252|
000038  6108              STR      r0,[r1,#0x10]         ;1270  ; _ClipContext
00003a  4832              LDR      r0,|L25.260|
00003c  7800              LDRB     r0,[r0,#0]            ;1273  ; WM__PaintCallbackCnt
00003e  b120              CBZ      r0,|L25.74|
000040  a902              ADD      r1,sp,#8              ;1274
000042  4620              MOV      r0,r4                 ;1274
000044  f7fffffe          BL       WM__GetInvalidRectAbs
000048  e00f              B        |L25.106|
                  |L25.74|
00004a  7f20              LDRB     r0,[r4,#0x1c]         ;1276
00004c  f0100f02          TST      r0,#2                 ;1276
000050  d004              BEQ      |L25.92|
000052  e9d40100          LDRD     r0,r1,[r4,#0]         ;1277
000056  e9cd0102          STRD     r0,r1,[sp,#8]         ;1277
00005a  e006              B        |L25.106|
                  |L25.92|
00005c  4827              LDR      r0,|L25.252|
00005e  6940              LDR      r0,[r0,#0x14]         ;1279  ; _ClipContext
000060  1e40              SUBS     r0,r0,#1              ;1279
000062  4926              LDR      r1,|L25.252|
000064  6148              STR      r0,[r1,#0x14]         ;1279  ; _ClipContext
000066  2000              MOVS     r0,#0                 ;1280
000068  e7d2              B        |L25.16|
                  |L25.106|
00006a  b11d              CBZ      r5,|L25.116|
00006c  4629              MOV      r1,r5                 ;1285
00006e  a802              ADD      r0,sp,#8              ;1285
000070  f7fffffe          BL       GUI__IntersectRect
                  |L25.116|
000074  4822              LDR      r0,|L25.256|
000076  6bc0              LDR      r0,[r0,#0x3c]         ;1288  ; GUI_Context
000078  b1c0              CBZ      r0,|L25.172|
00007a  4626              MOV      r6,r4                 ;1289
00007c  4820              LDR      r0,|L25.256|
00007e  6bc0              LDR      r0,[r0,#0x3c]         ;1290  ; GUI_Context
000080  6801              LDR      r1,[r0,#0]            ;1290
000082  9100              STR      r1,[sp,#0]            ;1290
000084  6840              LDR      r0,[r0,#4]            ;1290
000086  9001              STR      r0,[sp,#4]            ;1290
000088  481f              LDR      r0,|L25.264|
00008a  8800              LDRH     r0,[r0,#0]            ;1292  ; WM__hATransWindow
00008c  b128              CBZ      r0,|L25.154|
00008e  481e              LDR      r0,|L25.264|
000090  f9b00000          LDRSH    r0,[r0,#0]            ;1293  ; WM__hATransWindow
000094  f7fffffe          BL       GUI_ALLOC_h2p
000098  4606              MOV      r6,r0                 ;1293
                  |L25.154|
00009a  4669              MOV      r1,sp                 ;1296
00009c  4630              MOV      r0,r6                 ;1296
00009e  f7fffffe          BL       WM__Client2Screen
0000a2  4669              MOV      r1,sp                 ;1297
0000a4  a802              ADD      r0,sp,#8              ;1297
0000a6  f7fffffe          BL       GUI__IntersectRect
0000aa  bf00              NOP                            ;1298
                  |L25.172|
0000ac  4816              LDR      r0,|L25.264|
0000ae  8800              LDRH     r0,[r0,#0]            ;1301  ; WM__hATransWindow
0000b0  b168              CBZ      r0,|L25.206|
0000b2  4815              LDR      r0,|L25.264|
0000b4  f9b01000          LDRSH    r1,[r0,#0]            ;1302  ; WM__hATransWindow
0000b8  a802              ADD      r0,sp,#8              ;1302
0000ba  f7fffffe          BL       WM__ClipAtParentBorders
0000be  b930              CBNZ     r0,|L25.206|
0000c0  480e              LDR      r0,|L25.252|
0000c2  6940              LDR      r0,[r0,#0x14]         ;1303  ; _ClipContext
0000c4  1e40              SUBS     r0,r0,#1              ;1303
0000c6  490d              LDR      r1,|L25.252|
0000c8  6148              STR      r0,[r1,#0x14]         ;1303  ; _ClipContext
0000ca  2000              MOVS     r0,#0                 ;1304
0000cc  e7a0              B        |L25.16|
                  |L25.206|
0000ce  480c              LDR      r0,|L25.256|
0000d0  f9b01040          LDRSH    r1,[r0,#0x40]         ;1309  ; GUI_Context
0000d4  a802              ADD      r0,sp,#8              ;1309
0000d6  f7fffffe          BL       WM__ClipAtParentBorders
0000da  b930              CBNZ     r0,|L25.234|
0000dc  4807              LDR      r0,|L25.252|
0000de  6940              LDR      r0,[r0,#0x14]         ;1310  ; _ClipContext
0000e0  1e40              SUBS     r0,r0,#1              ;1310
0000e2  4906              LDR      r1,|L25.252|
0000e4  6148              STR      r0,[r1,#0x14]         ;1310  ; _ClipContext
0000e6  2000              MOVS     r0,#0                 ;1311
0000e8  e792              B        |L25.16|
                  |L25.234|
0000ea  4804              LDR      r0,|L25.252|
0000ec  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1314
0000f0  c006              STM      r0!,{r1,r2}           ;1314
0000f2  f7fffffe          BL       WM__GetNextIVR
0000f6  e78b              B        |L25.16|
;;;1317   
                          ENDP

                  |L25.248|
                          DCD      WM_IsActive
                  |L25.252|
                          DCD      _ClipContext
                  |L25.256|
                          DCD      GUI_Context
                  |L25.260|
                          DCD      WM__PaintCallbackCnt
                  |L25.264|
                          DCD      WM__hATransWindow

                          AREA ||i.WM__InsertWindowIntoList||, CODE, READONLY, ALIGN=1

                  WM__InsertWindowIntoList PROC
;;;341    */
;;;342    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;343      int OnTop;
;;;344      WM_HWIN hi;
;;;345      WM_Obj * pWin;
;;;346      WM_Obj * pParent;
;;;347      WM_Obj * pi;
;;;348    
;;;349      if (hParent) {
000008  f1b80f00          CMP      r8,#0
00000c  d03f              BEQ      |L26.142|
;;;350        pWin = WM_H2P(hWin);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4604              MOV      r4,r0
;;;351        pWin->hNext = 0;
000016  2000              MOVS     r0,#0
000018  8360              STRH     r0,[r4,#0x1a]
;;;352        pWin->hParent = hParent;
00001a  f8a48016          STRH     r8,[r4,#0x16]
;;;353        pParent = WM_H2P(hParent);
00001e  4640              MOV      r0,r8
000020  f7fffffe          BL       GUI_ALLOC_h2p
000024  4607              MOV      r7,r0
;;;354        OnTop   = pWin->Status & WM_CF_STAYONTOP;
000026  7f20              LDRB     r0,[r4,#0x1c]
000028  f0000b08          AND      r11,r0,#8
;;;355        hi = pParent->hFirstChild;
00002c  f9b79018          LDRSH    r9,[r7,#0x18]
;;;356        /* Put it at beginning of the list if there is no child */
;;;357        if (hi == 0) {   /* No child yet ... Makes things easy ! */
000030  f1b90f00          CMP      r9,#0
000034  d102              BNE      |L26.60|
;;;358          pParent->hFirstChild = hWin;
000036  833e              STRH     r6,[r7,#0x18]
                  |L26.56|
;;;359          return;                         /* Early out ... We are done */
;;;360        }
;;;361        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;362        pi = WM_H2P(hi);
;;;363        if (!OnTop) {
;;;364          if (pi->Status & WM_SF_STAYONTOP) {
;;;365            pWin->hNext = hi;
;;;366            pParent->hFirstChild = hWin;
;;;367            return;                         /* Early out ... We are done */
;;;368          }
;;;369        }
;;;370        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;371        do {
;;;372          WM_Obj* pNext;
;;;373          WM_HWIN hNext;
;;;374          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;375            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;376            break;
;;;377          }
;;;378          pNext = WM_H2P(hNext);
;;;379          if (!OnTop) {
;;;380            if (pNext->Status & WM_SF_STAYONTOP) {
;;;381              pi->hNext = hWin;
;;;382              pWin->hNext = hNext;
;;;383              break;
;;;384            }
;;;385          }
;;;386          pi = pNext;
;;;387        }  while (1);
;;;388        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;389          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;390        #endif
;;;391      }
;;;392    }
000038  e8bd8ff8          POP      {r3-r11,pc}
                  |L26.60|
00003c  4648              MOV      r0,r9                 ;362
00003e  f7fffffe          BL       GUI_ALLOC_h2p
000042  4605              MOV      r5,r0                 ;362
000044  f1bb0f00          CMP      r11,#0                ;363
000048  d107              BNE      |L26.90|
00004a  7f28              LDRB     r0,[r5,#0x1c]         ;364
00004c  f0100f08          TST      r0,#8                 ;364
000050  d003              BEQ      |L26.90|
000052  f8a4901a          STRH     r9,[r4,#0x1a]         ;365
000056  833e              STRH     r6,[r7,#0x18]         ;366
000058  e7ee              B        |L26.56|
                  |L26.90|
00005a  bf00              NOP                            ;371
                  |L26.92|
00005c  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;374
000060  9000              STR      r0,[sp,#0]            ;374
000062  b908              CBNZ     r0,|L26.104|
000064  836e              STRH     r6,[r5,#0x1a]         ;375
000066  e011              B        |L26.140|
                  |L26.104|
000068  9800              LDR      r0,[sp,#0]            ;378
00006a  f7fffffe          BL       GUI_ALLOC_h2p
00006e  4682              MOV      r10,r0                ;378
000070  f1bb0f00          CMP      r11,#0                ;379
000074  d108              BNE      |L26.136|
000076  f89a001c          LDRB     r0,[r10,#0x1c]        ;380
00007a  f0100f08          TST      r0,#8                 ;380
00007e  d003              BEQ      |L26.136|
000080  836e              STRH     r6,[r5,#0x1a]         ;381
000082  9800              LDR      r0,[sp,#0]            ;382
000084  8360              STRH     r0,[r4,#0x1a]         ;382
000086  e001              B        |L26.140|
                  |L26.136|
000088  4655              MOV      r5,r10                ;386
00008a  e7e7              B        |L26.92|
                  |L26.140|
00008c  bf00              NOP                            ;376
                  |L26.142|
00008e  bf00              NOP      
000090  e7d2              B        |L26.56|
;;;393    
                          ENDP


                          AREA ||i.WM__Invalidate1Abs||, CODE, READONLY, ALIGN=2

                  WM__Invalidate1Abs PROC
;;;209    */
;;;210    void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;211      GUI_RECT r;
;;;212      WM_Obj* pWin;
;;;213      int Status;
;;;214      pWin = WM_H2P(hWin);
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;215      Status = pWin->Status;
000010  8ba6              LDRH     r6,[r4,#0x1c]
;;;216      if ((Status & WM_SF_ISVIS) == 0) {
000012  f0160f02          TST      r6,#2
000016  d101              BNE      |L27.28|
                  |L27.24|
;;;217        return;   /* Window is not visible... we are done */
;;;218      }
;;;219      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;220        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;221      }
;;;222      if (WM__RectIsNZ(pRect) == 0) {
;;;223        return;   /* Nothing to do ... */
;;;224      }
;;;225      /* Calc affected area */
;;;226      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;227      if (WM__RectIsNZ(&r)) {
;;;228        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;229          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;230        #endif
;;;231    
;;;232        if (pWin->Status & WM_SF_INVALID) {
;;;233          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;234        } else {
;;;235          pWin->InvalidRect = r;
;;;236          pWin->Status |= WM_SF_INVALID;
;;;237          WM__NumInvalidWindows++;
;;;238          /* Optional code: Call external routine to notify that drawing is required */
;;;239          #ifdef GUI_X_REDRAW
;;;240          if (_IsInited) {
;;;241            GUI_RECT r;
;;;242            r = pWin->Rect;
;;;243            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;244              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;245            }
;;;246          }
;;;247          #endif
;;;248          GUI_X_SIGNAL_EVENT();
;;;249        }
;;;250        /* Debug code: shows invalid areas */
;;;251        #if (WM_SUPPORT_DIAG)
;;;252          if (WM__pfShowInvalid) {
;;;253            (WM__pfShowInvalid)(hWin);
;;;254          }
;;;255        #endif
;;;256      }
;;;257    }
000018  e8bd81fc          POP      {r2-r8,pc}
                  |L27.28|
00001c  f6400001          MOV      r0,#0x801             ;219
000020  4030              ANDS     r0,r0,r6              ;219
000022  2801              CMP      r0,#1                 ;219
000024  d100              BNE      |L27.40|
000026  e7f7              B        |L27.24|
                  |L27.40|
000028  4628              MOV      r0,r5                 ;222
00002a  f7fffffe          BL       WM__RectIsNZ
00002e  b900              CBNZ     r0,|L27.50|
000030  e7f2              B        |L27.24|
                  |L27.50|
000032  4622              MOV      r2,r4                 ;226
000034  4629              MOV      r1,r5                 ;226
000036  4668              MOV      r0,sp                 ;226
000038  f7fffffe          BL       GUI__IntersectRects
00003c  4668              MOV      r0,sp                 ;227
00003e  f7fffffe          BL       WM__RectIsNZ
000042  b1b8              CBZ      r0,|L27.116|
000044  7f20              LDRB     r0,[r4,#0x1c]         ;232
000046  f0100f20          TST      r0,#0x20              ;232
00004a  d006              BEQ      |L27.90|
00004c  466a              MOV      r2,sp                 ;233
00004e  f1040108          ADD      r1,r4,#8              ;233
000052  4608              MOV      r0,r1                 ;233
000054  f7fffffe          BL       GUI_MergeRect
000058  e00c              B        |L27.116|
                  |L27.90|
00005a  9800              LDR      r0,[sp,#0]            ;235
00005c  60a0              STR      r0,[r4,#8]            ;235
00005e  9801              LDR      r0,[sp,#4]            ;235
000060  60e0              STR      r0,[r4,#0xc]          ;235
000062  8ba0              LDRH     r0,[r4,#0x1c]         ;236
000064  f0400020          ORR      r0,r0,#0x20           ;236
000068  83a0              STRH     r0,[r4,#0x1c]         ;236
00006a  4803              LDR      r0,|L27.120|
00006c  8800              LDRH     r0,[r0,#0]            ;237  ; WM__NumInvalidWindows
00006e  1c40              ADDS     r0,r0,#1              ;237
000070  4901              LDR      r1,|L27.120|
000072  8008              STRH     r0,[r1,#0]            ;237
                  |L27.116|
000074  bf00              NOP      
000076  e7cf              B        |L27.24|
;;;258    
                          ENDP

                  |L27.120|
                          DCD      WM__NumInvalidWindows

                          AREA ||i.WM__InvalidateRectEx||, CODE, READONLY, ALIGN=1

                  WM__InvalidateRectEx PROC
;;;534    */
;;;535    void WM__InvalidateRectEx(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4692              MOV      r10,r2
;;;536      GUI_RECT Rect;
;;;537      WM_Obj*  pParent;
;;;538      WM_Obj*  pi;
;;;539      WM_HWIN  hi;
;;;540      int Status;
;;;541    
;;;542      /* Perform some parameter checks and check for "early out" conditions. */
;;;543      if (hParent == 0) {
00000a  b90e              CBNZ     r6,|L28.16|
                  |L28.12|
;;;544        return;                                                            /* Desktop window or unattached wind. Nothing to do. */
;;;545      }
;;;546      pParent = WM_H2P(hParent);
;;;547      Status  = pParent->Status;
;;;548      if ((Status & WM_SF_ISVIS) == 0) {
;;;549        return;                                                            /* Window is not visible... we are done */
;;;550      }
;;;551      if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;552        return;                                                            /* No intersection, nothing to do */
;;;553      }
;;;554      /* Invalidate the rectangle in the parent */
;;;555      /* If the parent is (partially) transparent, we need to move up in the hierarchy */
;;;556      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;557        WM__InvalidateRectEx(&Rect, pParent->hParent, pParent->hNext);
;;;558      } else {
;;;559        WM__Invalidate1Abs(hParent, &Rect);
;;;560      }
;;;561      /* Invalidate siblings up to hStop */
;;;562      for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
;;;563        if (hi == hStop) {
;;;564          break;
;;;565        }
;;;566        WM_InvalidateWindowAndDescsEx(hi, &Rect);
;;;567        pi = WM_H2P(hi);
;;;568      }
;;;569    }
00000c  e8bd87fc          POP      {r2-r10,pc}
                  |L28.16|
000010  4630              MOV      r0,r6                 ;546
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4604              MOV      r4,r0                 ;546
000018  f8b4801c          LDRH     r8,[r4,#0x1c]         ;547
00001c  f0180f02          TST      r8,#2                 ;548
000020  d100              BNE      |L28.36|
000022  e7f3              B        |L28.12|
                  |L28.36|
000024  4622              MOV      r2,r4                 ;551
000026  4649              MOV      r1,r9                 ;551
000028  4668              MOV      r0,sp                 ;551
00002a  f7fffffe          BL       GUI__IntersectRects
00002e  b900              CBNZ     r0,|L28.50|
000030  e7ec              B        |L28.12|
                  |L28.50|
000032  f6400001          MOV      r0,#0x801             ;556
000036  ea080000          AND      r0,r8,r0              ;556
00003a  2801              CMP      r0,#1                 ;556
00003c  d107              BNE      |L28.78|
00003e  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;557
000042  f9b41016          LDRSH    r1,[r4,#0x16]         ;557
000046  4668              MOV      r0,sp                 ;557
000048  f7fffffe          BL       WM__InvalidateRectEx
00004c  e003              B        |L28.86|
                  |L28.78|
00004e  4669              MOV      r1,sp                 ;559
000050  4630              MOV      r0,r6                 ;559
000052  f7fffffe          BL       WM__Invalidate1Abs
                  |L28.86|
000056  f9b45018          LDRSH    r5,[r4,#0x18]         ;562
00005a  e00c              B        |L28.118|
                  |L28.92|
00005c  4555              CMP      r5,r10                ;563
00005e  d100              BNE      |L28.98|
000060  e00b              B        |L28.122|
                  |L28.98|
000062  4669              MOV      r1,sp                 ;566
000064  4628              MOV      r0,r5                 ;566
000066  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
00006a  4628              MOV      r0,r5                 ;567
00006c  f7fffffe          BL       GUI_ALLOC_h2p
000070  4607              MOV      r7,r0                 ;567
000072  f9b7501a          LDRSH    r5,[r7,#0x1a]         ;562
                  |L28.118|
000076  2d00              CMP      r5,#0                 ;562
000078  d1f0              BNE      |L28.92|
                  |L28.122|
00007a  bf00              NOP                            ;564
00007c  bf00              NOP      
00007e  e7c5              B        |L28.12|
;;;570    
                          ENDP


                          AREA ||i.WM__IsWindow||, CODE, READONLY, ALIGN=2

                  WM__IsWindow PROC
;;;470    */
;;;471    int WM__IsWindow(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;472      WM_HWIN iWin;
;;;473      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
000004  4808              LDR      r0,|L29.40|
000006  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
00000a  e008              B        |L29.30|
                  |L29.12|
;;;474        if (iWin == hWin) {
00000c  42ac              CMP      r4,r5
00000e  d101              BNE      |L29.20|
;;;475          return 1;
000010  2001              MOVS     r0,#1
                  |L29.18|
;;;476        }
;;;477      }
;;;478      return 0;
;;;479    }
000012  bd70              POP      {r4-r6,pc}
                  |L29.20|
000014  4620              MOV      r0,r4                 ;473
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  f9b04014          LDRSH    r4,[r0,#0x14]         ;473
                  |L29.30|
00001e  2c00              CMP      r4,#0                 ;473
000020  d1f4              BNE      |L29.12|
000022  2000              MOVS     r0,#0                 ;478
000024  e7f5              B        |L29.18|
;;;480    
                          ENDP

000026  0000              DCW      0x0000
                  |L29.40|
                          DCD      WM__FirstWin

                          AREA ||i.WM__Paint||, CODE, READONLY, ALIGN=2

                  WM__Paint PROC
;;;1584   */
;;;1585   int WM__Paint(WM_HWIN hWin, WM_Obj* pWin) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1586     int Ret = 0;
000008  2600              MOVS     r6,#0
;;;1587     if (pWin->Status & WM_SF_INVALID) {
00000a  7f20              LDRB     r0,[r4,#0x1c]
00000c  f0100f20          TST      r0,#0x20
000010  d03d              BEQ      |L30.142|
;;;1588       if (pWin->cb) {
000012  6920              LDR      r0,[r4,#0x10]
000014  b350              CBZ      r0,|L30.108|
;;;1589         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000016  4629              MOV      r1,r5
000018  f1040008          ADD      r0,r4,#8
00001c  f7fffffe          BL       WM__ClipAtParentBorders
000020  b320              CBZ      r0,|L30.108|
;;;1590           WM_PAINTINFO Info;
;;;1591           Info.hWin = hWin;
000022  f8ad500c          STRH     r5,[sp,#0xc]
;;;1592           WM_SelectWindow(hWin);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       WM_SelectWindow
;;;1593           #if GUI_SUPPORT_MEMDEV
;;;1594             Info.pWin = NULL; /* 'Invalidate' the window pointer, because it can 
00002c  2000              MOVS     r0,#0
00002e  9004              STR      r0,[sp,#0x10]
;;;1595                                   become invalid through the creation of a memory device
;;;1596                               */
;;;1597             if (pWin->Status & WM_SF_MEMDEV) {
000030  7f20              LDRB     r0,[r4,#0x1c]
000032  f0100f04          TST      r0,#4
000036  d013              BEQ      |L30.96|
;;;1598               int Flags;
;;;1599               GUI_RECT r = pWin->InvalidRect;
000038  68a0              LDR      r0,[r4,#8]
00003a  9001              STR      r0,[sp,#4]
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  9002              STR      r0,[sp,#8]
;;;1600               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
000040  7f20              LDRB     r0,[r4,#0x1c]
000042  f0000001          AND      r0,r0,#1
000046  f0800701          EOR      r7,r0,#1
;;;1601               /*
;;;1602                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1603                */
;;;1604               if (pWin->hParent == 0) {
00004a  8ae0              LDRH     r0,[r4,#0x16]
00004c  b900              CBNZ     r0,|L30.80|
;;;1605                 Flags = GUI_MEMDEV_HASTRANS;
00004e  2700              MOVS     r7,#0
                  |L30.80|
;;;1606               }
;;;1607               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
000050  2300              MOVS     r3,#0
000052  aa03              ADD      r2,sp,#0xc
000054  490f              LDR      r1,|L30.148|
000056  a801              ADD      r0,sp,#4
000058  9700              STR      r7,[sp,#0]
00005a  f7fffffe          BL       GUI_MEMDEV_Draw
;;;1608             } else
00005e  e004              B        |L30.106|
                  |L30.96|
;;;1609           #endif
;;;1610           {
;;;1611             Info.pWin = pWin;
000060  9404              STR      r4,[sp,#0x10]
;;;1612             WM__PaintWinAndOverlays(&Info);
000062  a803              ADD      r0,sp,#0xc
000064  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1613             Ret = 1;    /* Something has been done */
000068  2601              MOVS     r6,#1
                  |L30.106|
;;;1614           }
;;;1615         }
00006a  bf00              NOP      
                  |L30.108|
;;;1616       }
;;;1617       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1618       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
00006c  8ba0              LDRH     r0,[r4,#0x1c]
00006e  f0200020          BIC      r0,r0,#0x20
000072  83a0              STRH     r0,[r4,#0x1c]
;;;1619       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000074  8ba0              LDRH     r0,[r4,#0x1c]
000076  f4105f00          TST      r0,#0x2000
00007a  d003              BEQ      |L30.132|
;;;1620         pWin->Status |= WM_CF_MEMDEV;
00007c  8ba0              LDRH     r0,[r4,#0x1c]
00007e  f0400004          ORR      r0,r0,#4
000082  83a0              STRH     r0,[r4,#0x1c]
                  |L30.132|
;;;1621       }
;;;1622       WM__NumInvalidWindows--;
000084  4804              LDR      r0,|L30.152|
000086  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000088  1e40              SUBS     r0,r0,#1
00008a  4903              LDR      r1,|L30.152|
00008c  8008              STRH     r0,[r1,#0]
                  |L30.142|
;;;1623     }
;;;1624     return Ret;      /* Nothing done */
00008e  4630              MOV      r0,r6
;;;1625   }
000090  b005              ADD      sp,sp,#0x14
000092  bdf0              POP      {r4-r7,pc}
;;;1626   
                          ENDP

                  |L30.148|
                          DCD      _cbPaintMemDev
                  |L30.152|
                          DCD      WM__NumInvalidWindows

                          AREA ||i.WM__PaintWinAndOverlays||, CODE, READONLY, ALIGN=2

                  WM__PaintWinAndOverlays PROC
;;;1518   */
;;;1519   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1520     WM_HWIN hWin;
;;;1521     WM_Obj* pWin;
;;;1522     hWin = pInfo->hWin;
000004  f9b46000          LDRSH    r6,[r4,#0]
;;;1523     pWin = pInfo->pWin;
000008  6865              LDR      r5,[r4,#4]
;;;1524     if (!pWin) {
00000a  b91d              CBNZ     r5,|L31.20|
;;;1525       pWin = WM_H2P(hWin);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4605              MOV      r5,r0
                  |L31.20|
;;;1526     }
;;;1527     #if WM_SUPPORT_TRANSPARENCY
;;;1528       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1529       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000014  8ba8              LDRH     r0,[r5,#0x1c]
000016  f6400101          MOV      r1,#0x801
00001a  4008              ANDS     r0,r0,r1
00001c  2801              CMP      r0,#1
00001e  d007              BEQ      |L31.48|
;;;1530     #endif
;;;1531     _Paint1(hWin, pWin);    /* Draw the window itself */
000020  4629              MOV      r1,r5
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       _Paint1
;;;1532     #if GUI_SUPPORT_MEMDEV
;;;1533       /* Within the paint event the application is alowed to deal with memory devices.
;;;1534          So the pointer(s) could be invalid after the last function call and needs
;;;1535          to be restored.
;;;1536       */
;;;1537       pWin = WM_H2P(hWin);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       GUI_ALLOC_h2p
00002e  4605              MOV      r5,r0
                  |L31.48|
;;;1538     #endif
;;;1539     #if WM_SUPPORT_TRANSPARENCY
;;;1540       }
;;;1541       if (WM__TransWindowCnt != 0) {
000030  4807              LDR      r0,|L31.80|
000032  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000034  b158              CBZ      r0,|L31.78|
;;;1542         _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
000036  4629              MOV      r1,r5
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       _PaintTransChildren
;;;1543         #if GUI_SUPPORT_MEMDEV
;;;1544           /* Within the paint event the application is alowed to deal with memory devices.
;;;1545              So the pointer(s) could be invalid after the last function call and needs
;;;1546              to be restored.
;;;1547           */
;;;1548           pWin = WM_H2P(hWin);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GUI_ALLOC_h2p
000044  4605              MOV      r5,r0
;;;1549         #endif
;;;1550         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000046  4629              MOV      r1,r5
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       _PaintTransTopSiblings
                  |L31.78|
;;;1551       }
;;;1552     #endif
;;;1553   }
00004e  bd70              POP      {r4-r6,pc}
;;;1554   
                          ENDP

                  |L31.80|
                          DCD      WM__TransWindowCnt

                          AREA ||i.WM__RectIsNZ||, CODE, READONLY, ALIGN=1

                  WM__RectIsNZ PROC
;;;613    */
;;;614    int WM__RectIsNZ(const GUI_RECT* pr) {
000000  4601              MOV      r1,r0
;;;615      if (pr->x0 > pr->x1)
000002  f9b10000          LDRSH    r0,[r1,#0]
000006  f9b12004          LDRSH    r2,[r1,#4]
00000a  4290              CMP      r0,r2
00000c  dd01              BLE      |L32.18|
;;;616        return 0;
00000e  2000              MOVS     r0,#0
                  |L32.16|
;;;617      if (pr->y0 > pr->y1)
;;;618        return 0;
;;;619      return 1;
;;;620    }
000010  4770              BX       lr
                  |L32.18|
000012  f9b10002          LDRSH    r0,[r1,#2]            ;617
000016  f9b12006          LDRSH    r2,[r1,#6]            ;617
00001a  4290              CMP      r0,r2                 ;617
00001c  dd01              BLE      |L32.34|
00001e  2000              MOVS     r0,#0                 ;618
000020  e7f6              B        |L32.16|
                  |L32.34|
000022  2001              MOVS     r0,#1                 ;619
000024  e7f4              B        |L32.16|
;;;621    
                          ENDP


                          AREA ||i.WM__RemoveFromLinList||, CODE, READONLY, ALIGN=2

                  WM__RemoveFromLinList PROC
;;;574    */
;;;575    void WM__RemoveFromLinList(WM_HWIN hWin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;576      WM_Obj* piWin;
;;;577      WM_HWIN hiWin;
;;;578      WM_HWIN hNext;
;;;579      for (hiWin = WM__FirstWin; hiWin; ) {
000006  480c              LDR      r0,|L33.56|
000008  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
00000c  e00e              B        |L33.44|
                  |L33.14|
;;;580        piWin = WM_H2P(hiWin);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4604              MOV      r4,r0
;;;581        hNext = piWin->hNextLin;
000016  f9b45014          LDRSH    r5,[r4,#0x14]
;;;582        if (hNext == hWin) {
00001a  42b5              CMP      r5,r6
00001c  d105              BNE      |L33.42|
;;;583          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       GUI_ALLOC_h2p
000024  8a80              LDRH     r0,[r0,#0x14]
000026  82a0              STRH     r0,[r4,#0x14]
;;;584          break;
000028  e002              B        |L33.48|
                  |L33.42|
;;;585        }
;;;586        hiWin = hNext;
00002a  462f              MOV      r7,r5
                  |L33.44|
00002c  2f00              CMP      r7,#0                 ;579
00002e  d1ee              BNE      |L33.14|
                  |L33.48|
000030  bf00              NOP                            ;584
;;;587      }
;;;588    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;589    
                          ENDP

000036  0000              DCW      0x0000
                  |L33.56|
                          DCD      WM__FirstWin

                          AREA ||i.WM__RemoveWindowFromList||, CODE, READONLY, ALIGN=1

                  WM__RemoveWindowFromList PROC
;;;397    */
;;;398    void WM__RemoveWindowFromList(WM_HWIN hWin) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
;;;399      WM_HWIN hi, hParent;
;;;400      WM_Obj * pWin, * pParent, * pi;
;;;401      
;;;402      pWin = WM_H2P(hWin);
000006  4638              MOV      r0,r7
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4681              MOV      r9,r0
;;;403      hParent = pWin->hParent;
00000e  f9b98016          LDRSH    r8,[r9,#0x16]
;;;404      if (hParent) {
000012  f1b80f00          CMP      r8,#0
000016  d020              BEQ      |L34.90|
;;;405        pParent = WM_H2P(hParent);
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       GUI_ALLOC_h2p
00001e  4606              MOV      r6,r0
;;;406        hi = pParent->hFirstChild;
000020  f9b65018          LDRSH    r5,[r6,#0x18]
;;;407        if (hi == hWin) {
000024  42bd              CMP      r5,r7
000026  d106              BNE      |L34.54|
;;;408          pi = WM_H2P(hi);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       GUI_ALLOC_h2p
00002e  4604              MOV      r4,r0
;;;409          pParent->hFirstChild = pi->hNext;
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  8330              STRH     r0,[r6,#0x18]
000034  e011              B        |L34.90|
                  |L34.54|
;;;410        } else {
;;;411          while (hi) {
000036  e00d              B        |L34.84|
                  |L34.56|
;;;412            pi = WM_H2P(hi);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GUI_ALLOC_h2p
00003e  4604              MOV      r4,r0
;;;413            if (pi->hNext == hWin) {
000040  f9b4001a          LDRSH    r0,[r4,#0x1a]
000044  42b8              CMP      r0,r7
000046  d103              BNE      |L34.80|
;;;414              pi->hNext = pWin->hNext;
000048  f8b9001a          LDRH     r0,[r9,#0x1a]
00004c  8360              STRH     r0,[r4,#0x1a]
;;;415              break;
00004e  e003              B        |L34.88|
                  |L34.80|
;;;416            }
;;;417            hi = pi->hNext;
000050  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L34.84|
000054  2d00              CMP      r5,#0                 ;411
000056  d1ef              BNE      |L34.56|
                  |L34.88|
000058  bf00              NOP                            ;415
                  |L34.90|
;;;418          }
;;;419        }
;;;420      }
;;;421    }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;422    
                          ENDP


                          AREA ||i.WM__SendMsgNoData||, CODE, READONLY, ALIGN=1

                  WM__SendMsgNoData PROC
;;;753    */
;;;754    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
000000  b53e              PUSH     {r1-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;755      WM_MESSAGE Msg;
;;;756      Msg.hWin  = hWin;
000006  f8ad5004          STRH     r5,[sp,#4]
;;;757      Msg.MsgId = MsgId;
00000a  9400              STR      r4,[sp,#0]
;;;758      WM__SendMessage(hWin, &Msg);
00000c  4669              MOV      r1,sp
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       WM__SendMessage
;;;759    }
000014  bd3e              POP      {r1-r5,pc}
;;;760    
                          ENDP


                          AREA ||i._AddToLinList||, CODE, READONLY, ALIGN=2

                  _AddToLinList PROC
;;;593    */
;;;594    static void _AddToLinList(WM_HWIN hNew) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;595      WM_Obj* pFirst;
;;;596      WM_Obj* pNew;
;;;597      if (WM__FirstWin) {
000004  4809              LDR      r0,|L36.44|
000006  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
000008  b168              CBZ      r0,|L36.38|
;;;598        pFirst = WM_H2P(WM__FirstWin);
00000a  4808              LDR      r0,|L36.44|
00000c  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4606              MOV      r6,r0
;;;599        pNew   = WM_H2P(hNew);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4605              MOV      r5,r0
;;;600        pNew->hNextLin = pFirst->hNextLin;
00001e  8ab0              LDRH     r0,[r6,#0x14]
000020  82a8              STRH     r0,[r5,#0x14]
;;;601        pFirst->hNextLin = hNew;
000022  82b4              STRH     r4,[r6,#0x14]
000024  e001              B        |L36.42|
                  |L36.38|
;;;602      } else {
;;;603        WM__FirstWin = hNew;
000026  4801              LDR      r0,|L36.44|
000028  8004              STRH     r4,[r0,#0]
                  |L36.42|
;;;604      }
;;;605    }
00002a  bd70              POP      {r4-r6,pc}
;;;606    
                          ENDP

                  |L36.44|
                          DCD      WM__FirstWin

                          AREA ||i._CheckCriticalHandles||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4a06              LDR      r2,|L37.28|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e006              B        |L37.22|
                  |L37.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d101              BNE      |L37.20|
;;;104          pCH->hWin = 0;
000010  2200              MOVS     r2,#0
000012  8082              STRH     r2,[r0,#4]
                  |L37.20|
000014  6800              LDR      r0,[r0,#0]            ;102
                  |L37.22|
000016  2800              CMP      r0,#0                 ;102
000018  d1f6              BNE      |L37.8|
;;;105        }
;;;106      }
;;;107    }
00001a  4770              BX       lr
;;;108    
                          ENDP

                  |L37.28|
                          DCD      WM__pFirstCriticalHandle

                          AREA ||i._DeleteAllChildren||, CODE, READONLY, ALIGN=1

                  _DeleteAllChildren PROC
;;;446    */
;;;447    static void _DeleteAllChildren(WM_Obj * pParent) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;448      do {
000004  bf00              NOP      
                  |L38.6|
;;;449        WM_DeleteWindow(pParent->hFirstChild);
000006  f9b40018          LDRSH    r0,[r4,#0x18]
00000a  f7fffffe          BL       WM_DeleteWindow
;;;450      } while (pParent->hFirstChild);
00000e  8b20              LDRH     r0,[r4,#0x18]
000010  2800              CMP      r0,#0
000012  d1f8              BNE      |L38.6|
;;;451    }
000014  bd10              POP      {r4,pc}
;;;452    
                          ENDP


                          AREA ||i._DesktopHandle2Index||, CODE, READONLY, ALIGN=2

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
000000  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
000002  4805              LDR      r0,|L39.24|
000004  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000008  4288              CMP      r0,r1
00000a  d101              BNE      |L39.16|
;;;130        return 0;
00000c  2000              MOVS     r0,#0
                  |L39.14|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00000e  4770              BX       lr
                  |L39.16|
000010  f04f30ff          MOV      r0,#0xffffffff        ;133
000014  e7fb              B        |L39.14|
;;;135    
                          ENDP

000016  0000              DCW      0x0000
                  |L39.24|
                          DCD      WM__ahDesktopWin

                          AREA ||i._DrawNext||, CODE, READONLY, ALIGN=2

                  _DrawNext PROC
;;;1630   */
;;;1631   static void _DrawNext(void) {
000000  b570              PUSH     {r4-r6,lr}
000002  b09a              SUB      sp,sp,#0x68
;;;1632     int UpdateRem = 1;
000004  2601              MOVS     r6,#1
;;;1633     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000006  4813              LDR      r0,|L40.84|
000008  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
00000a  b918              CBNZ     r0,|L40.20|
00000c  4812              LDR      r0,|L40.88|
00000e  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000012  e002              B        |L40.26|
                  |L40.20|
000014  480f              LDR      r0,|L40.84|
000016  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L40.26|
00001a  4604              MOV      r4,r0
;;;1634     GUI_CONTEXT ContextOld;
;;;1635     GUI_SaveContext(&ContextOld);
00001c  a801              ADD      r0,sp,#4
00001e  f7fffffe          BL       GUI_SaveContext_W_M
;;;1636     /* Make sure the next window to redraw is valid */
;;;1637     for (; iWin && UpdateRem; ) {
000022  e00c              B        |L40.62|
                  |L40.36|
;;;1638       WM_Obj* pWin = WM_H2P(iWin);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GUI_ALLOC_h2p
00002a  4605              MOV      r5,r0
;;;1639       if (WM__Paint(iWin, pWin)) {
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       WM__Paint
000034  b100              CBZ      r0,|L40.56|
;;;1640         UpdateRem--;  /* Only the given number of windows at a time ... */
000036  1e76              SUBS     r6,r6,#1
                  |L40.56|
;;;1641       }
;;;1642       iWin = pWin->hNextLin;
000038  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1643     }  
00003c  bf00              NOP      
                  |L40.62|
00003e  b10c              CBZ      r4,|L40.68|
000040  2e00              CMP      r6,#0                 ;1637
000042  d1ef              BNE      |L40.36|
                  |L40.68|
;;;1644     NextDrawWin = iWin;   /* Remember the window */
000044  4803              LDR      r0,|L40.84|
000046  8004              STRH     r4,[r0,#0]
;;;1645     GUI_RestoreContext(&ContextOld);
000048  a801              ADD      r0,sp,#4
00004a  f7fffffe          BL       GUI_RestoreContext
;;;1646   }
00004e  b01a              ADD      sp,sp,#0x68
000050  bd70              POP      {r4-r6,pc}
;;;1647   
                          ENDP

000052  0000              DCW      0x0000
                  |L40.84|
                          DCD      NextDrawWin
                  |L40.88|
                          DCD      WM__FirstWin

                          AREA ||i._FindNext_IVR||, CODE, READONLY, ALIGN=2

                  _FindNext_IVR PROC
;;;1071   #if WM_SUPPORT_OBSTRUCT
;;;1072   static int _FindNext_IVR(void) {
000000  b57c              PUSH     {r2-r6,lr}
;;;1073     WM_HMEM hParent;
;;;1074     GUI_RECT r;
;;;1075     WM_Obj* pAWin;
;;;1076     WM_Obj* pParent;
;;;1077     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
000002  495c              LDR      r1,|L41.372|
000004  e9d10102          LDRD     r0,r1,[r1,#8]
000008  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1078     /*
;;;1079        STEP 1:
;;;1080          Set the next position which could be part of the next IVR
;;;1081          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1082          or next one down if we are at the right border.
;;;1083     */
;;;1084     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
00000c  4859              LDR      r0,|L41.372|
00000e  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
000010  b940              CBNZ     r0,|L41.36|
;;;1085       r.x0 = _ClipContext.ClientRect.x0;
000012  4858              LDR      r0,|L41.372|
000014  8800              LDRH     r0,[r0,#0]  ; _ClipContext
000016  f8ad0000          STRH     r0,[sp,#0]
;;;1086       r.y0 = _ClipContext.ClientRect.y0;
00001a  4856              LDR      r0,|L41.372|
00001c  8840              LDRH     r0,[r0,#2]  ; _ClipContext
00001e  f8ad0002          STRH     r0,[sp,#2]
000022  e01b              B        |L41.92|
                  |L41.36|
;;;1087     } else {
;;;1088       r.x0 = _ClipContext.CurRect.x1+1;
000024  4853              LDR      r0,|L41.372|
000026  8980              LDRH     r0,[r0,#0xc]
000028  1c40              ADDS     r0,r0,#1
00002a  b200              SXTH     r0,r0
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;1089       r.y0 = _ClipContext.CurRect.y0;
000030  4850              LDR      r0,|L41.372|
000032  8940              LDRH     r0,[r0,#0xa]
000034  f8ad0002          STRH     r0,[sp,#2]
;;;1090       if (r.x0 > _ClipContext.ClientRect.x1) {
000038  f9bd0000          LDRSH    r0,[sp,#0]
00003c  494d              LDR      r1,|L41.372|
00003e  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
000042  4288              CMP      r0,r1
000044  dd0a              BLE      |L41.92|
;;;1091   NextStripe:  /* go down to next stripe */
000046  bf00              NOP      
                  |L41.72|
;;;1092         r.x0 = _ClipContext.ClientRect.x0;
000048  484a              LDR      r0,|L41.372|
00004a  8800              LDRH     r0,[r0,#0]  ; _ClipContext
00004c  f8ad0000          STRH     r0,[sp,#0]
;;;1093         r.y0 = _ClipContext.CurRect.y1+1;
000050  4848              LDR      r0,|L41.372|
000052  89c0              LDRH     r0,[r0,#0xe]
000054  1c40              ADDS     r0,r0,#1
000056  b200              SXTH     r0,r0
000058  f8ad0002          STRH     r0,[sp,#2]
                  |L41.92|
;;;1094       }
;;;1095     }
;;;1096     /*
;;;1097        STEP 2:
;;;1098          Check if we are done completely.
;;;1099     */
;;;1100     if (r.y0 >_ClipContext.ClientRect.y1) {
00005c  f9bd0002          LDRSH    r0,[sp,#2]
000060  4944              LDR      r1,|L41.372|
000062  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
000066  4288              CMP      r0,r1
000068  dd01              BLE      |L41.110|
;;;1101       return 0;
00006a  2000              MOVS     r0,#0
                  |L41.108|
;;;1102     }
;;;1103     /* STEP 3:
;;;1104          Find out the max. height (r.y1) if we are at the left border.
;;;1105          Since we are using the same height for all IVRs at the same y0,
;;;1106          we do this only for the leftmost one.
;;;1107     */
;;;1108     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1109     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1110       r.y1 = _ClipContext.ClientRect.y1;
;;;1111       r.x1 = _ClipContext.ClientRect.x1;
;;;1112       /* Iterate over all windows which are above */
;;;1113       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1114       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1115         pParent = WM_H2P(hParent);
;;;1116         _Findy1(pParent->hNext, &r, NULL);
;;;1117       }
;;;1118       /* Check all children */
;;;1119       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1120     }
;;;1121     /* 
;;;1122       STEP 4
;;;1123         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1124         if we find one that intersects, adjust x0 to the right.
;;;1125     */
;;;1126   Find_x0:
;;;1127     r.x1 = r.x0;
;;;1128     /* Iterate over all windows which are above */
;;;1129     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1130     #if 0   /* This is a planned, but not yet released optimization */
;;;1131       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1132       {
;;;1133         hParent = pAWin->hParent;
;;;1134       } else
;;;1135     #endif
;;;1136     {
;;;1137       hParent = GUI_Context.hAWin;
;;;1138     }
;;;1139     for (; hParent; hParent = pParent->hParent) {
;;;1140       pParent = WM_H2P(hParent);
;;;1141       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1142         goto Find_x0;
;;;1143       }
;;;1144     }
;;;1145     /* Check all children */
;;;1146     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1147       goto Find_x0;
;;;1148     }
;;;1149     /* 
;;;1150      STEP 5:
;;;1151        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1152        Find out x1 for the given x0, y0, y1
;;;1153     */
;;;1154     r.x1 = _ClipContext.ClientRect.x1;
;;;1155     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1156       _ClipContext.CurRect = r;
;;;1157       goto NextStripe;
;;;1158     }    
;;;1159     /* 
;;;1160      STEP 6:
;;;1161        Find r.x1. We have to Iterate over all windows which are above
;;;1162     */
;;;1163     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1164     #if 0   /* This is a planned, but not yet released optimization */
;;;1165       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1166       {
;;;1167         hParent = pAWin->hParent;
;;;1168       } else
;;;1169     #endif
;;;1170     {
;;;1171       hParent = GUI_Context.hAWin;
;;;1172     }
;;;1173     for (; hParent; hParent = pParent->hParent) {
;;;1174       pParent = WM_H2P(hParent);
;;;1175       _Findx1(pParent->hNext, &r, NULL);
;;;1176     }
;;;1177     /* Check all children */
;;;1178     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1179     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1180     if (_ClipContext.Cnt >200) {
;;;1181       return 0;  /* error !!! This should not happen !*/
;;;1182     }
;;;1183     _ClipContext.CurRect = r;
;;;1184     return 1;  /* IVR is valid ! */
;;;1185   }
00006c  bd7c              POP      {r2-r6,pc}
                  |L41.110|
00006e  4942              LDR      r1,|L41.376|
000070  f9b10040          LDRSH    r0,[r1,#0x40]         ;1108  ; GUI_Context
000074  f7fffffe          BL       GUI_ALLOC_h2p
000078  4605              MOV      r5,r0                 ;1108
00007a  f9bd0000          LDRSH    r0,[sp,#0]            ;1109
00007e  493d              LDR      r1,|L41.372|
000080  f9b11000          LDRSH    r1,[r1,#0]            ;1109  ; _ClipContext
000084  4288              CMP      r0,r1                 ;1109
000086  d11f              BNE      |L41.200|
000088  483a              LDR      r0,|L41.372|
00008a  88c0              LDRH     r0,[r0,#6]            ;1110  ; _ClipContext
00008c  f8ad0006          STRH     r0,[sp,#6]            ;1110
000090  4838              LDR      r0,|L41.372|
000092  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
000094  f8ad0004          STRH     r0,[sp,#4]            ;1111
000098  4837              LDR      r0,|L41.376|
00009a  f9b06040          LDRSH    r6,[r0,#0x40]         ;1114  ; GUI_Context
00009e  e00b              B        |L41.184|
                  |L41.160|
0000a0  4630              MOV      r0,r6                 ;1115
0000a2  f7fffffe          BL       GUI_ALLOC_h2p
0000a6  4604              MOV      r4,r0                 ;1115
0000a8  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1116
0000ac  2200              MOVS     r2,#0                 ;1116
0000ae  4669              MOV      r1,sp                 ;1116
0000b0  f7fffffe          BL       _Findy1
0000b4  f9b46016          LDRSH    r6,[r4,#0x16]         ;1114
                  |L41.184|
0000b8  2e00              CMP      r6,#0                 ;1114
0000ba  d1f1              BNE      |L41.160|
0000bc  f9b50018          LDRSH    r0,[r5,#0x18]         ;1119
0000c0  2200              MOVS     r2,#0                 ;1119
0000c2  4669              MOV      r1,sp                 ;1119
0000c4  f7fffffe          BL       _Findy1
                  |L41.200|
0000c8  bf00              NOP                            ;1126
                  |L41.202|
0000ca  f8bd0000          LDRH     r0,[sp,#0]            ;1127
0000ce  f8ad0004          STRH     r0,[sp,#4]            ;1127
0000d2  4829              LDR      r0,|L41.376|
0000d4  f9b06040          LDRSH    r6,[r0,#0x40]         ;1137  ; GUI_Context
0000d8  e00d              B        |L41.246|
                  |L41.218|
0000da  4630              MOV      r0,r6                 ;1140
0000dc  f7fffffe          BL       GUI_ALLOC_h2p
0000e0  4604              MOV      r4,r0                 ;1140
0000e2  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1141
0000e6  2200              MOVS     r2,#0                 ;1141
0000e8  4669              MOV      r1,sp                 ;1141
0000ea  f7fffffe          BL       _Findx0
0000ee  b100              CBZ      r0,|L41.242|
0000f0  e7eb              B        |L41.202|
                  |L41.242|
0000f2  f9b46016          LDRSH    r6,[r4,#0x16]         ;1139
                  |L41.246|
0000f6  2e00              CMP      r6,#0                 ;1139
0000f8  d1ef              BNE      |L41.218|
0000fa  f9b50018          LDRSH    r0,[r5,#0x18]         ;1146
0000fe  2200              MOVS     r2,#0                 ;1146
000100  4669              MOV      r1,sp                 ;1146
000102  f7fffffe          BL       _Findx0
000106  b100              CBZ      r0,|L41.266|
000108  e7df              B        |L41.202|
                  |L41.266|
00010a  481a              LDR      r0,|L41.372|
00010c  8880              LDRH     r0,[r0,#4]            ;1154  ; _ClipContext
00010e  f8ad0004          STRH     r0,[sp,#4]            ;1154
000112  f9bd0004          LDRSH    r0,[sp,#4]            ;1155
000116  f9bd1000          LDRSH    r1,[sp,#0]            ;1155
00011a  4288              CMP      r0,r1                 ;1155
00011c  da05              BGE      |L41.298|
00011e  4815              LDR      r0,|L41.372|
000120  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1156
000124  e9c01202          STRD     r1,r2,[r0,#8]         ;1156
000128  e78e              B        |L41.72|
                  |L41.298|
00012a  4813              LDR      r0,|L41.376|
00012c  f9b06040          LDRSH    r6,[r0,#0x40]         ;1171  ; GUI_Context
000130  e00b              B        |L41.330|
                  |L41.306|
000132  4630              MOV      r0,r6                 ;1174
000134  f7fffffe          BL       GUI_ALLOC_h2p
000138  4604              MOV      r4,r0                 ;1174
00013a  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1175
00013e  2200              MOVS     r2,#0                 ;1175
000140  4669              MOV      r1,sp                 ;1175
000142  f7fffffe          BL       _Findx1
000146  f9b46016          LDRSH    r6,[r4,#0x16]         ;1173
                  |L41.330|
00014a  2e00              CMP      r6,#0                 ;1173
00014c  d1f1              BNE      |L41.306|
00014e  f9b50018          LDRSH    r0,[r5,#0x18]         ;1178
000152  2200              MOVS     r2,#0                 ;1178
000154  4669              MOV      r1,sp                 ;1178
000156  f7fffffe          BL       _Findx1
00015a  4806              LDR      r0,|L41.372|
00015c  6900              LDR      r0,[r0,#0x10]         ;1180  ; _ClipContext
00015e  28c8              CMP      r0,#0xc8              ;1180
000160  dd01              BLE      |L41.358|
000162  2000              MOVS     r0,#0                 ;1181
000164  e782              B        |L41.108|
                  |L41.358|
000166  4803              LDR      r0,|L41.372|
000168  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1183
00016c  e9c01202          STRD     r1,r2,[r0,#8]         ;1183
000170  2001              MOVS     r0,#1                 ;1184
000172  e77b              B        |L41.108|
;;;1186   
                          ENDP

                  |L41.372|
                          DCD      _ClipContext
                  |L41.376|
                          DCD      GUI_Context

                          AREA ||i._Findx0||, CODE, READONLY, ALIGN=1

                  _Findx0 PROC
;;;664    */
;;;665    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;666      WM_Obj* pWin;
;;;667      int r = 0;
00000a  f04f0b00          MOV      r11,#0
;;;668      for (; hWin; hWin = pWin->hNext) { 
00000e  e03b              B        |L42.136|
                  |L42.16|
;;;669        int Status = (pWin = WM_H2P(hWin))->Status;
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4604              MOV      r4,r0
000018  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;670        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
00001c  f0180f02          TST      r8,#2
000020  d030              BEQ      |L42.132|
;;;671          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;672          if (pParentRect) {
000022  b12f              CBZ      r7,|L42.48|
;;;673            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000024  463a              MOV      r2,r7
000026  4621              MOV      r1,r4
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       GUI__IntersectRects
00002e  e003              B        |L42.56|
                  |L42.48|
;;;674          } else {
;;;675            rWinClipped = pWin->Rect;
000030  e9d40100          LDRD     r0,r1,[r4,#0]
000034  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L42.56|
;;;676          }
;;;677          /* Check if this window affects us at all */    
;;;678          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000038  4669              MOV      r1,sp
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       GUI_RectsIntersect
000040  b1f8              CBZ      r0,|L42.130|
;;;679            if ((Status & WM_SF_HASTRANS) == 0) {
000042  f0180f01          TST      r8,#1
000046  d107              BNE      |L42.88|
;;;680              pRect->x0 = rWinClipped.x1+1;
000048  f8bd0004          LDRH     r0,[sp,#4]
00004c  1c40              ADDS     r0,r0,#1
00004e  b200              SXTH     r0,r0
000050  8028              STRH     r0,[r5,#0]
;;;681              r = 1;
000052  f04f0b01          MOV      r11,#1
000056  e014              B        |L42.130|
                  |L42.88|
;;;682            } else {
;;;683              /* Check all children */
;;;684              WM_HWIN hChild;
;;;685              WM_Obj* pChild;
;;;686              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000058  f9b49018          LDRSH    r9,[r4,#0x18]
00005c  e00d              B        |L42.122|
                  |L42.94|
;;;687                pChild = WM_H2P(hChild);
00005e  4648              MOV      r0,r9
000060  f7fffffe          BL       GUI_ALLOC_h2p
000064  4682              MOV      r10,r0
;;;688                if (_Findx0(hChild, pRect, &rWinClipped)) {
000066  466a              MOV      r2,sp
000068  4629              MOV      r1,r5
00006a  4648              MOV      r0,r9
00006c  f7fffffe          BL       _Findx0
000070  b108              CBZ      r0,|L42.118|
;;;689                  r = 1;
000072  f04f0b01          MOV      r11,#1
                  |L42.118|
000076  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;686
                  |L42.122|
00007a  f1b90f00          CMP      r9,#0                 ;686
00007e  d1ee              BNE      |L42.94|
;;;690                }
;;;691              }
;;;692            }
000080  bf00              NOP      
                  |L42.130|
;;;693          }
;;;694        }
000082  bf00              NOP      
                  |L42.132|
000084  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;668
                  |L42.136|
000088  2e00              CMP      r6,#0                 ;668
00008a  d1c1              BNE      |L42.16|
;;;695      }
;;;696      return r;
00008c  4658              MOV      r0,r11
;;;697    }
00008e  e8bd9ffc          POP      {r2-r12,pc}
;;;698    
                          ENDP


                          AREA ||i._Findx1||, CODE, READONLY, ALIGN=1

                  _Findx1 PROC
;;;702    */
;;;703    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;704      WM_Obj* pWin;
;;;705      for (; hWin; hWin = pWin->hNext) { 
00000a  e036              B        |L43.122|
                  |L43.12|
;;;706        int Status = (pWin = WM_H2P(hWin))->Status;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4604              MOV      r4,r0
000014  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;707        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000018  f0180f02          TST      r8,#2
00001c  d02b              BEQ      |L43.118|
;;;708          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;709          if (pParentRect) {
00001e  b12f              CBZ      r7,|L43.44|
;;;710            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000020  463a              MOV      r2,r7
000022  4621              MOV      r1,r4
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       GUI__IntersectRects
00002a  e003              B        |L43.52|
                  |L43.44|
;;;711          } else {
;;;712            rWinClipped = pWin->Rect;
00002c  e9d40100          LDRD     r0,r1,[r4,#0]
000030  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L43.52|
;;;713          }
;;;714          /* Check if this window affects us at all */    
;;;715          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000034  4669              MOV      r1,sp
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       GUI_RectsIntersect
00003c  b1d0              CBZ      r0,|L43.116|
;;;716            if ((Status & WM_SF_HASTRANS) == 0) {
00003e  f0180f01          TST      r8,#1
000042  d105              BNE      |L43.80|
;;;717              pRect->x1 = rWinClipped.x0-1;
000044  f8bd0000          LDRH     r0,[sp,#0]
000048  1e40              SUBS     r0,r0,#1
00004a  b200              SXTH     r0,r0
00004c  80a8              STRH     r0,[r5,#4]
00004e  e011              B        |L43.116|
                  |L43.80|
;;;718            } else {
;;;719              /* Check all children */
;;;720              WM_HWIN hChild;
;;;721              WM_Obj* pChild;
;;;722              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000050  f9b49018          LDRSH    r9,[r4,#0x18]
000054  e00a              B        |L43.108|
                  |L43.86|
;;;723                pChild = WM_H2P(hChild);
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       GUI_ALLOC_h2p
00005c  4682              MOV      r10,r0
;;;724                _Findx1(hChild, pRect, &rWinClipped);
00005e  466a              MOV      r2,sp
000060  4629              MOV      r1,r5
000062  4648              MOV      r0,r9
000064  f7fffffe          BL       _Findx1
000068  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;722
                  |L43.108|
00006c  f1b90f00          CMP      r9,#0                 ;722
000070  d1f1              BNE      |L43.86|
;;;725              }
;;;726            }
000072  bf00              NOP      
                  |L43.116|
;;;727          }
;;;728        }
000074  bf00              NOP      
                  |L43.118|
000076  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;705
                  |L43.122|
00007a  2e00              CMP      r6,#0                 ;705
00007c  d1c6              BNE      |L43.12|
;;;729      }
;;;730    }
00007e  e8bd87fc          POP      {r2-r10,pc}
;;;731    
                          ENDP


                          AREA ||i._Findy1||, CODE, READONLY, ALIGN=1

                  _Findy1 PROC
;;;626    */
;;;627    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;628      WM_Obj* pWin;
;;;629      for (; iWin; iWin = pWin->hNext) { 
00000a  e04d              B        |L44.168|
                  |L44.12|
;;;630        int Status = (pWin = WM_H2P(iWin))->Status;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4605              MOV      r5,r0
000014  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;631        /* Check if this window affects us at all */    
;;;632        if (Status & WM_SF_ISVIS) {
000018  f0180f02          TST      r8,#2
00001c  d042              BEQ      |L44.164|
;;;633          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;634          if (pParentRect) {
00001e  b12f              CBZ      r7,|L44.44|
;;;635            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000020  463a              MOV      r2,r7
000022  4629              MOV      r1,r5
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       GUI__IntersectRects
00002a  e003              B        |L44.52|
                  |L44.44|
;;;636          } else {
;;;637            rWinClipped = pWin->Rect;
00002c  e9d50100          LDRD     r0,r1,[r5,#0]
000030  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L44.52|
;;;638          }
;;;639          /* Check if this window affects us at all */    
;;;640          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000034  4669              MOV      r1,sp
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       GUI_RectsIntersect
00003c  b388              CBZ      r0,|L44.162|
;;;641            if ((Status & WM_SF_HASTRANS) == 0) {
00003e  f0180f01          TST      r8,#1
000042  d11c              BNE      |L44.126|
;;;642              if (pWin->Rect.y0 > pRect->y0) {
000044  f9b50002          LDRSH    r0,[r5,#2]
000048  f9b41002          LDRSH    r1,[r4,#2]
00004c  4288              CMP      r0,r1
00004e  dd0c              BLE      |L44.106|
;;;643                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
000050  f9bd0002          LDRSH    r0,[sp,#2]
000054  1e40              SUBS     r0,r0,#1
000056  f9b41006          LDRSH    r1,[r4,#6]
00005a  4288              CMP      r0,r1
00005c  da21              BGE      |L44.162|
00005e  f8bd0002          LDRH     r0,[sp,#2]
000062  1e40              SUBS     r0,r0,#1
000064  b200              SXTH     r0,r0
000066  80e0              STRH     r0,[r4,#6]
000068  e01b              B        |L44.162|
                  |L44.106|
;;;644              } else {
;;;645                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
00006a  f9bd0006          LDRSH    r0,[sp,#6]
00006e  f9b41006          LDRSH    r1,[r4,#6]
000072  4288              CMP      r0,r1
000074  da15              BGE      |L44.162|
000076  f8bd0006          LDRH     r0,[sp,#6]
00007a  80e0              STRH     r0,[r4,#6]
00007c  e011              B        |L44.162|
                  |L44.126|
;;;646              }
;;;647            } else {
;;;648              /* Check all children*/ 
;;;649              WM_HWIN hChild;
;;;650              WM_Obj* pChild;
;;;651              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00007e  f9b59018          LDRSH    r9,[r5,#0x18]
000082  e00a              B        |L44.154|
                  |L44.132|
;;;652                pChild = WM_H2P(hChild);
000084  4648              MOV      r0,r9
000086  f7fffffe          BL       GUI_ALLOC_h2p
00008a  4682              MOV      r10,r0
;;;653                _Findy1(hChild, pRect, &rWinClipped);
00008c  466a              MOV      r2,sp
00008e  4621              MOV      r1,r4
000090  4648              MOV      r0,r9
000092  f7fffffe          BL       _Findy1
000096  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;651
                  |L44.154|
00009a  f1b90f00          CMP      r9,#0                 ;651
00009e  d1f1              BNE      |L44.132|
;;;654              }
;;;655            }
0000a0  bf00              NOP      
                  |L44.162|
;;;656          }
;;;657        }
0000a2  bf00              NOP      
                  |L44.164|
0000a4  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;629
                  |L44.168|
0000a8  2e00              CMP      r6,#0                 ;629
0000aa  d1af              BNE      |L44.12|
;;;658      }
;;;659    }
0000ac  e8bd87fc          POP      {r2-r10,pc}
;;;660    
                          ENDP


                          AREA ||i._GethDrawWin||, CODE, READONLY, ALIGN=2

                  _GethDrawWin PROC
;;;167    */
;;;168    static WM_HWIN _GethDrawWin(void) {
000000  4905              LDR      r1,|L45.24|
;;;169      WM_HWIN h;
;;;170      #if WM_SUPPORT_TRANSPARENCY
;;;171        if (WM__hATransWindow) {
000002  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
000004  b119              CBZ      r1,|L45.14|
;;;172          h = WM__hATransWindow;
000006  4904              LDR      r1,|L45.24|
000008  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
00000c  e002              B        |L45.20|
                  |L45.14|
;;;173        } else
;;;174      #endif
;;;175      {
;;;176        h = GUI_Context.hAWin;
00000e  4903              LDR      r1,|L45.28|
000010  f9b10040          LDRSH    r0,[r1,#0x40]  ; GUI_Context
                  |L45.20|
;;;177      }
;;;178      return h;
;;;179    }
000014  4770              BX       lr
;;;180    
                          ENDP

000016  0000              DCW      0x0000
                  |L45.24|
                          DCD      WM__hATransWindow
                  |L45.28|
                          DCD      GUI_Context

                          AREA ||i._Paint1||, CODE, READONLY, ALIGN=2

                  _Paint1 PROC
;;;1335   */
;;;1336   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1337     int Status = pWin->Status;
000006  8ba6              LDRH     r6,[r4,#0x1c]
;;;1338     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1339     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000008  6920              LDR      r0,[r4,#0x10]
00000a  2800              CMP      r0,#0
00000c  d035              BEQ      |L46.122|
00000e  f0160f02          TST      r6,#2
000012  d032              BEQ      |L46.122|
;;;1340       WM_MESSAGE Msg;
;;;1341       WM__PaintCallbackCnt++;
000014  4819              LDR      r0,|L46.124|
000016  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000018  1c40              ADDS     r0,r0,#1
00001a  4918              LDR      r1,|L46.124|
00001c  7008              STRB     r0,[r1,#0]
;;;1342       if (Status & WM_SF_LATE_CLIP) {
00001e  f4165f80          TST      r6,#0x1000
000022  d00d              BEQ      |L46.64|
;;;1343         Msg.hWin   = hWin;
000024  f8ad5004          STRH     r5,[sp,#4]
;;;1344         Msg.MsgId  = WM_PAINT;
000028  200f              MOVS     r0,#0xf
00002a  9000              STR      r0,[sp,#0]
;;;1345         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
00002c  f1040008          ADD      r0,r4,#8
000030  9002              STR      r0,[sp,#8]
;;;1346         WM_SetDefault();
000032  f7fffffe          BL       WM_SetDefault
;;;1347         WM__SendMessage(hWin, &Msg);
000036  4669              MOV      r1,sp
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       WM__SendMessage
00003e  e016              B        |L46.110|
                  |L46.64|
;;;1348       } else {
;;;1349         WM_ITERATE_START(&pWin->InvalidRect) {
000040  f1040008          ADD      r0,r4,#8
000044  f7fffffe          BL       WM__InitIVRSearch
000048  b188              CBZ      r0,|L46.110|
00004a  bf00              NOP      
                  |L46.76|
;;;1350           Msg.hWin   = hWin;
00004c  f8ad5004          STRH     r5,[sp,#4]
;;;1351           Msg.MsgId  = WM_PAINT;
000050  200f              MOVS     r0,#0xf
000052  9000              STR      r0,[sp,#0]
;;;1352           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000054  f1040008          ADD      r0,r4,#8
000058  9002              STR      r0,[sp,#8]
;;;1353           WM_SetDefault();
00005a  f7fffffe          BL       WM_SetDefault
;;;1354           WM__SendMessage(hWin, &Msg);
00005e  4669              MOV      r1,sp
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       WM__SendMessage
;;;1355         } WM_ITERATE_END();
000066  f7fffffe          BL       WM__GetNextIVR
00006a  2800              CMP      r0,#0
00006c  d1ee              BNE      |L46.76|
                  |L46.110|
;;;1356       }
;;;1357       WM__PaintCallbackCnt--;
00006e  4803              LDR      r0,|L46.124|
000070  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000072  1e40              SUBS     r0,r0,#1
000074  4901              LDR      r1,|L46.124|
000076  7008              STRB     r0,[r1,#0]
;;;1358     }
000078  bf00              NOP      
                  |L46.122|
;;;1359   }
00007a  bdfe              POP      {r1-r7,pc}
;;;1360   /*********************************************************************
                          ENDP

                  |L46.124|
                          DCD      WM__PaintCallbackCnt

                          AREA ||i._Paint1Trans||, CODE, READONLY, ALIGN=2

                  _Paint1Trans PROC
;;;1382   #if WM_SUPPORT_TRANSPARENCY
;;;1383   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1384     int xPrev, yPrev;
;;;1385     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000008  4916              LDR      r1,|L47.100|
00000a  f9b10040          LDRSH    r0,[r1,#0x40]  ; GUI_Context
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4680              MOV      r8,r0
;;;1386     /* Check if we need to do any drawing */
;;;1387     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000014  4621              MOV      r1,r4
000016  f1080008          ADD      r0,r8,#8
00001a  f7fffffe          BL       GUI_RectsIntersect
00001e  b1f8              CBZ      r0,|L47.96|
;;;1388       /* Save old values */
;;;1389       xPrev = GUI_Context.xOff;
000020  4810              LDR      r0,|L47.100|
000022  6c46              LDR      r6,[r0,#0x44]  ; GUI_Context
;;;1390       yPrev = GUI_Context.yOff;
000024  6c87              LDR      r7,[r0,#0x48]  ; GUI_Context
;;;1391       /* Set values for the current (transparent) window, rather than the one below */
;;;1392       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000026  f1080208          ADD      r2,r8,#8
00002a  4621              MOV      r1,r4
00002c  f1040008          ADD      r0,r4,#8
000030  f7fffffe          BL       GUI__IntersectRects
;;;1393       WM__hATransWindow = hWin;
000034  480c              LDR      r0,|L47.104|
000036  8005              STRH     r5,[r0,#0]
;;;1394       GUI_Context.xOff = pWin->Rect.x0;
000038  f9b40000          LDRSH    r0,[r4,#0]
00003c  4909              LDR      r1,|L47.100|
00003e  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1395       GUI_Context.yOff = pWin->Rect.y0;
000040  f9b40002          LDRSH    r0,[r4,#2]
000044  6488              STR      r0,[r1,#0x48]  ; GUI_Context
;;;1396       /* Do the actual drawing ... */
;;;1397       _Paint1(hWin, pWin);
000046  4621              MOV      r1,r4
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       _Paint1
;;;1398       /* Restore settings */
;;;1399       WM__hATransWindow = 0;
00004e  2000              MOVS     r0,#0
000050  4905              LDR      r1,|L47.104|
000052  8008              STRH     r0,[r1,#0]
;;;1400       GUI_Context.xOff = xPrev;
000054  4803              LDR      r0,|L47.100|
000056  6446              STR      r6,[r0,#0x44]  ; GUI_Context
;;;1401       GUI_Context.yOff = yPrev;
000058  6487              STR      r7,[r0,#0x48]  ; GUI_Context
;;;1402       return 1;                       /* Some drawing took place */
00005a  2001              MOVS     r0,#1
                  |L47.92|
;;;1403     }
;;;1404     return 0;                         /* No invalid area, so nothing was drawn */
;;;1405   }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L47.96|
000060  2000              MOVS     r0,#0                 ;1404
000062  e7fb              B        |L47.92|
;;;1406   #endif
                          ENDP

                  |L47.100|
                          DCD      GUI_Context
                  |L47.104|
                          DCD      WM__hATransWindow

                          AREA ||i._PaintTransChildren||, CODE, READONLY, ALIGN=1

                  _PaintTransChildren PROC
;;;1419   #if WM_SUPPORT_TRANSPARENCY
;;;1420   static void _PaintTransChildren(WM_HWIN hWin, WM_Obj* pWin) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;1421     WM_HWIN hChild;
;;;1422     WM_Obj* pChild;
;;;1423     if (pWin->Status & WM_SF_ISVIS) {
000008  7f20              LDRB     r0,[r4,#0x1c]
00000a  f0100f02          TST      r0,#2
00000e  d033              BEQ      |L48.120|
;;;1424       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000010  f9b46018          LDRSH    r6,[r4,#0x18]
000014  e02e              B        |L48.116|
                  |L48.22|
;;;1425         pChild = WM_H2P(hChild);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4605              MOV      r5,r0
;;;1426         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
00001e  7f28              LDRB     r0,[r5,#0x1c]
000020  f0000003          AND      r0,r0,#3
000024  2803              CMP      r0,#3
000026  d123              BNE      |L48.112|
;;;1427   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1428           /* Set invalid area of the window to draw */
;;;1429           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000028  f1040108          ADD      r1,r4,#8
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GUI_RectsIntersect
000032  b1e8              CBZ      r0,|L48.112|
;;;1430             GUI_RECT InvalidRectPrev;
;;;1431             InvalidRectPrev = pWin->InvalidRect;
000034  68a0              LDR      r0,[r4,#8]
000036  9000              STR      r0,[sp,#0]
000038  68e0              LDR      r0,[r4,#0xc]
00003a  9001              STR      r0,[sp,#4]
;;;1432             if(_Paint1Trans(hChild, pChild)) {
00003c  4629              MOV      r1,r5
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       _Paint1Trans
000044  b178              CBZ      r0,|L48.102|
;;;1433               #if GUI_SUPPORT_MEMDEV
;;;1434                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1435                    So the pointer(s) could be invalid after the last function call and needs
;;;1436                    to be restored.
;;;1437                 */
;;;1438                 pChild = WM_H2P(hChild);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       GUI_ALLOC_h2p
00004c  4605              MOV      r5,r0
;;;1439               #endif
;;;1440               _PaintTransChildren(hChild, pChild);
00004e  4629              MOV      r1,r5
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       _PaintTransChildren
;;;1441               #if GUI_SUPPORT_MEMDEV
;;;1442                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1443                    So the pointer(s) could be invalid after the last function call and needs
;;;1444                    to be restored.
;;;1445                 */
;;;1446                 pChild = WM_H2P(hChild);
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       GUI_ALLOC_h2p
00005c  4605              MOV      r5,r0
;;;1447                 pWin   = WM_H2P(hWin);
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       GUI_ALLOC_h2p
000064  4604              MOV      r4,r0
                  |L48.102|
;;;1448               #endif
;;;1449             }
;;;1450             pWin->InvalidRect = InvalidRectPrev;
000066  9800              LDR      r0,[sp,#0]
000068  60a0              STR      r0,[r4,#8]
00006a  9801              LDR      r0,[sp,#4]
00006c  60e0              STR      r0,[r4,#0xc]
;;;1451           }
00006e  bf00              NOP      
                  |L48.112|
000070  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1424
                  |L48.116|
000074  2e00              CMP      r6,#0                 ;1424
000076  d1ce              BNE      |L48.22|
                  |L48.120|
;;;1452         }
;;;1453       }
;;;1454     }
;;;1455   }
000078  e8bd81fc          POP      {r2-r8,pc}
;;;1456   #endif
                          ENDP


                          AREA ||i._PaintTransTopSiblings||, CODE, READONLY, ALIGN=1

                  _PaintTransTopSiblings PROC
;;;1469   #if WM_SUPPORT_TRANSPARENCY
;;;1470   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1471     WM_HWIN hParent;
;;;1472     WM_Obj* pParent;
;;;1473     hParent = pWin->hParent;
000008  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1474     hWin = pWin->hNext;
00000c  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1475     while (hParent) { /* Go hierarchy up to desktop window */
000010  e021              B        |L49.86|
                  |L49.18|
;;;1476       for (; hWin; hWin = pWin->hNext) {
000012  e016              B        |L49.66|
                  |L49.20|
;;;1477         pWin = WM_H2P(hWin);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;1478         /* paint window if it is transparent & visible */
;;;1479         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
00001c  7f20              LDRB     r0,[r4,#0x1c]
00001e  f0000003          AND      r0,r0,#3
000022  2803              CMP      r0,#3
000024  d107              BNE      |L49.54|
;;;1480           _Paint1Trans(hWin, pWin);
000026  4621              MOV      r1,r4
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       _Paint1Trans
;;;1481           #if GUI_SUPPORT_MEMDEV
;;;1482             /* Within the paint event the application is alowed to deal with memory devices.
;;;1483                So the pointer(s) could be invalid after the last function call and needs
;;;1484                to be restored.
;;;1485             */
;;;1486             pWin   = WM_H2P(hWin);
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       GUI_ALLOC_h2p
000034  4604              MOV      r4,r0
                  |L49.54|
;;;1487           #endif
;;;1488         }
;;;1489         /* paint transparent & visible children */
;;;1490         _PaintTransChildren(hWin, pWin);
000036  4621              MOV      r1,r4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       _PaintTransChildren
00003e  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1476
                  |L49.66|
000042  2e00              CMP      r6,#0                 ;1476
000044  d1e6              BNE      |L49.20|
;;;1491       }
;;;1492       pParent = WM_H2P(hParent);
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       GUI_ALLOC_h2p
00004c  4605              MOV      r5,r0
;;;1493       hWin = pParent->hNext;
00004e  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1494       hParent = pParent->hParent;
000052  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L49.86|
000056  2f00              CMP      r7,#0                 ;1475
000058  d1db              BNE      |L49.18|
;;;1495     }
;;;1496   }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;1497   #endif
                          ENDP


                          AREA ||i._SetClipRectUserIntersect||, CODE, READONLY, ALIGN=2

                  _SetClipRectUserIntersect PROC
;;;184    */
;;;185    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
;;;186      if (GUI_Context.WM__pUserClipRect == NULL) {
000004  480f              LDR      r0,|L50.68|
000006  6bc0              LDR      r0,[r0,#0x3c]  ; GUI_Context
000008  b918              CBNZ     r0,|L50.18|
;;;187        LCD_SetClipRectEx(prSrc);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       LCD_SetClipRectEx
000010  e016              B        |L50.64|
                  |L50.18|
;;;188      } else {
;;;189        GUI_RECT r;
;;;190        r = *GUI_Context.WM__pUserClipRect;             
000012  480c              LDR      r0,|L50.68|
000014  6bc0              LDR      r0,[r0,#0x3c]  ; GUI_Context
000016  6801              LDR      r1,[r0,#0]
000018  9100              STR      r1,[sp,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  9001              STR      r0,[sp,#4]
;;;191        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
00001e  f7fffffe          BL       _GethDrawWin
000022  4606              MOV      r6,r0
000024  f7fffffe          BL       GUI_ALLOC_h2p
000028  4605              MOV      r5,r0
00002a  4669              MOV      r1,sp
00002c  f7fffffe          BL       WM__Client2Screen
;;;192        /* Set intersection as clip rect */    
;;;193        GUI__IntersectRect(&r, prSrc);
000030  4621              MOV      r1,r4
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       GUI__IntersectRect
;;;194        LCD_SetClipRectEx(&r);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       LCD_SetClipRectEx
;;;195      }
00003e  bf00              NOP      
                  |L50.64|
;;;196    }
000040  bd7c              POP      {r2-r6,pc}
;;;197    
                          ENDP

000042  0000              DCW      0x0000
                  |L50.68|
                          DCD      GUI_Context

                          AREA ||i._cbPaintMemDev||, CODE, READONLY, ALIGN=2

                  _cbPaintMemDev PROC
;;;1567   #if GUI_SUPPORT_MEMDEV
;;;1568   static void _cbPaintMemDev(void* p) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
;;;1569     GUI_RECT Rect;
;;;1570     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000004  490b              LDR      r1,|L51.52|
000006  f9b10040          LDRSH    r0,[r1,#0x40]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;1571     Rect = pWin->InvalidRect;
000010  68a0              LDR      r0,[r4,#8]
000012  9000              STR      r0,[sp,#0]
000014  68e0              LDR      r0,[r4,#0xc]
000016  9001              STR      r0,[sp,#4]
;;;1572     pWin->InvalidRect = GUI_Context.ClipRect;
000018  4806              LDR      r0,|L51.52|
00001a  6881              LDR      r1,[r0,#8]  ; GUI_Context
00001c  60a1              STR      r1,[r4,#8]
00001e  68c0              LDR      r0,[r0,#0xc]  ; GUI_Context
000020  60e0              STR      r0,[r4,#0xc]
;;;1573     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1574     pWin->InvalidRect = Rect;
000028  9800              LDR      r0,[sp,#0]
00002a  60a0              STR      r0,[r4,#8]
00002c  9801              LDR      r0,[sp,#4]
00002e  60e0              STR      r0,[r4,#0xc]
;;;1575   }
000030  bd7c              POP      {r2-r6,pc}
;;;1576   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L51.52|
                          DCD      GUI_Context

                          AREA ||i.cbBackWin||, CODE, READONLY, ALIGN=2

                  cbBackWin PROC
;;;1699   */
;;;1700   static void cbBackWin( WM_MESSAGE* pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1701     const WM_KEY_INFO* pKeyInfo;
;;;1702     switch (pMsg->MsgId) {
000004  6820              LDR      r0,[r4,#0]
000006  280e              CMP      r0,#0xe
000008  d002              BEQ      |L52.16|
00000a  280f              CMP      r0,#0xf
00000c  d118              BNE      |L52.64|
00000e  e007              B        |L52.32|
                  |L52.16|
;;;1703     case WM_KEY:
;;;1704       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
000010  68a5              LDR      r5,[r4,#8]
;;;1705       if (pKeyInfo->PressedCnt == 1) {
000012  6868              LDR      r0,[r5,#4]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L52.30|
;;;1706         GUI_StoreKey(pKeyInfo->Key);
000018  6828              LDR      r0,[r5,#0]
00001a  f7fffffe          BL       GUI_StoreKey
                  |L52.30|
;;;1707       }
;;;1708       break;
00001e  e013              B        |L52.72|
                  |L52.32|
;;;1709     case WM_PAINT:
;;;1710       {
;;;1711         int LayerIndex;
;;;1712         #if GUI_NUM_LAYERS > 1
;;;1713           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1714         #else
;;;1715           LayerIndex = 0;
000020  2600              MOVS     r6,#0
;;;1716         #endif
;;;1717         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000022  480a              LDR      r0,|L52.76|
000024  f8500026          LDR      r0,[r0,r6,LSL #2]
000028  f06f4170          MVN      r1,#0xf0000000
00002c  4288              CMP      r0,r1
00002e  d006              BEQ      |L52.62|
;;;1718           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
000030  4906              LDR      r1,|L52.76|
000032  f8510026          LDR      r0,[r1,r6,LSL #2]
000036  f7fffffe          BL       GUI_SetBkColor
;;;1719           GUI_Clear();
00003a  f7fffffe          BL       GUI_Clear
                  |L52.62|
;;;1720         }
;;;1721       }
;;;1722     default:
00003e  bf00              NOP      
                  |L52.64|
;;;1723       WM_DefaultProc(pMsg);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       WM_DefaultProc
000046  bf00              NOP                            ;1702
                  |L52.72|
000048  bf00              NOP                            ;1708
;;;1724     }
;;;1725   }
00004a  bd70              POP      {r4-r6,pc}
;;;1726   
                          ENDP

                  |L52.76|
                          DCD      WM__aBkColor

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  _CursorHidden
000000  0000              DCB      0x00,0x00
                  WM__NumWindows
000002  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000004  0000              DCB      0x00,0x00
                  WM__FirstWin
000006  0000              DCB      0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
