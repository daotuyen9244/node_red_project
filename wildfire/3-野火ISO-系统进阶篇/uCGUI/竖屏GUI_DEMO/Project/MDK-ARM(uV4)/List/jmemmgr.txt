; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jmemmgr.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jmemmgr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jmemmgr.c]
                          THUMB

                          AREA ||i.access_virt_barray||, CODE, READONLY, ALIGN=1

                  access_virt_barray PROC
;;;799    /* caller intends to modify the accessed area. */
;;;800    METHODDEF(JBLOCKARRAY) access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows,  boolean writable) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  469a              MOV      r10,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;801      JDIMENSION end_row = start_row + num_rows;
000010  eb06070a          ADD      r7,r6,r10
;;;802      JDIMENSION undef_row;
;;;803    
;;;804      /* debugging check */
;;;805      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000014  6860              LDR      r0,[r4,#4]
000016  42b8              CMP      r0,r7
000018  d304              BCC      |L1.36|
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  4550              CMP      r0,r10
00001e  d301              BCC      |L1.36|
;;;806          ptr->mem_buffer == NULL)
000020  6820              LDR      r0,[r4,#0]
000022  b930              CBNZ     r0,|L1.50|
                  |L1.36|
;;;807        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000024  2016              MOVS     r0,#0x16
000026  6829              LDR      r1,[r5,#0]
000028  6148              STR      r0,[r1,#0x14]
00002a  6828              LDR      r0,[r5,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4628              MOV      r0,r5
000030  4788              BLX      r1
                  |L1.50|
;;;808    
;;;809      /* Make the desired part of the virtual array accessible */
;;;810      if (start_row < ptr->cur_start_row ||
000032  69a0              LDR      r0,[r4,#0x18]
000034  42b0              CMP      r0,r6
000036  d804              BHI      |L1.66|
;;;811          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
000038  6921              LDR      r1,[r4,#0x10]
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  4408              ADD      r0,r0,r1
00003e  42b8              CMP      r0,r7
000040  d222              BCS      |L1.136|
                  |L1.66|
;;;812        if (! ptr->b_s_open)
000042  6aa0              LDR      r0,[r4,#0x28]
000044  b930              CBNZ     r0,|L1.84|
;;;813          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
000046  2045              MOVS     r0,#0x45
000048  6829              LDR      r1,[r5,#0]
00004a  6148              STR      r0,[r1,#0x14]
00004c  6828              LDR      r0,[r5,#0]
00004e  6801              LDR      r1,[r0,#0]
000050  4628              MOV      r0,r5
000052  4788              BLX      r1
                  |L1.84|
;;;814        /* Flush old buffer contents if necessary */
;;;815        if (ptr->dirty) {
000054  6a60              LDR      r0,[r4,#0x24]
000056  b130              CBZ      r0,|L1.102|
;;;816          do_barray_io(cinfo, ptr, TRUE);
000058  2201              MOVS     r2,#1
00005a  4621              MOV      r1,r4
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       do_barray_io
;;;817          ptr->dirty = FALSE;
000062  2000              MOVS     r0,#0
000064  6260              STR      r0,[r4,#0x24]
                  |L1.102|
;;;818        }
;;;819        /* Decide what part of virtual array to access.
;;;820         * Algorithm: if target address > current window, assume forward scan,
;;;821         * load starting at target address.  If target address < current window,
;;;822         * assume backward scan, load so that target area is top of window.
;;;823         * Note that when switching from forward write to forward read, will have
;;;824         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;825         */
;;;826        if (start_row > ptr->cur_start_row) {
000066  69a0              LDR      r0,[r4,#0x18]
000068  42b0              CMP      r0,r6
00006a  d201              BCS      |L1.112|
;;;827          ptr->cur_start_row = start_row;
00006c  61a6              STR      r6,[r4,#0x18]
00006e  e006              B        |L1.126|
                  |L1.112|
;;;828        } else {
;;;829          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;830          long ltemp;
;;;831    
;;;832          ltemp = (long) end_row - (long) ptr->rows_in_mem;
000070  6921              LDR      r1,[r4,#0x10]
000072  1a78              SUBS     r0,r7,r1
;;;833          if (ltemp < 0)
000074  2800              CMP      r0,#0
000076  da00              BGE      |L1.122|
;;;834    	ltemp = 0;		/* don't fall off front end of file */
000078  2000              MOVS     r0,#0
                  |L1.122|
;;;835          ptr->cur_start_row = (JDIMENSION) ltemp;
00007a  61a0              STR      r0,[r4,#0x18]
;;;836        }
00007c  bf00              NOP      
                  |L1.126|
;;;837        /* Read in the selected part of the array.
;;;838         * During the initial write pass, we will do no actual read
;;;839         * because the selected part is all undefined.
;;;840         */
;;;841        do_barray_io(cinfo, ptr, FALSE);
00007e  2200              MOVS     r2,#0
000080  4621              MOV      r1,r4
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       do_barray_io
                  |L1.136|
;;;842      }
;;;843      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;844       * To improve locality of access, we only prezero the part of the array
;;;845       * that the caller is about to access, not the entire in-memory array.
;;;846       */
;;;847      if (ptr->first_undef_row < end_row) {
000088  69e0              LDR      r0,[r4,#0x1c]
00008a  42b8              CMP      r0,r7
00008c  d234              BCS      |L1.248|
;;;848        if (ptr->first_undef_row < start_row) {
00008e  69e0              LDR      r0,[r4,#0x1c]
000090  42b0              CMP      r0,r6
000092  d20b              BCS      |L1.172|
;;;849          if (writable)		/* writer skipped over a section of array */
000094  f1b90f00          CMP      r9,#0
000098  d006              BEQ      |L1.168|
;;;850    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
00009a  2016              MOVS     r0,#0x16
00009c  6829              LDR      r1,[r5,#0]
00009e  6148              STR      r0,[r1,#0x14]
0000a0  6828              LDR      r0,[r5,#0]
0000a2  6801              LDR      r1,[r0,#0]
0000a4  4628              MOV      r0,r5
0000a6  4788              BLX      r1
                  |L1.168|
;;;851          undef_row = start_row;	/* but reader is allowed to read ahead */
0000a8  46b0              MOV      r8,r6
0000aa  e001              B        |L1.176|
                  |L1.172|
;;;852        } else {
;;;853          undef_row = ptr->first_undef_row;
0000ac  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L1.176|
;;;854        }
;;;855        if (writable)
0000b0  f1b90f00          CMP      r9,#0
0000b4  d000              BEQ      |L1.184|
;;;856          ptr->first_undef_row = end_row;
0000b6  61e7              STR      r7,[r4,#0x1c]
                  |L1.184|
;;;857        if (ptr->pre_zero) {
0000b8  6a20              LDR      r0,[r4,#0x20]
0000ba  b198              CBZ      r0,|L1.228|
;;;858          size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
0000bc  68a0              LDR      r0,[r4,#8]
0000be  ea4f1bc0          LSL      r11,r0,#7
;;;859          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
0000c2  69a0              LDR      r0,[r4,#0x18]
0000c4  eba80800          SUB      r8,r8,r0
;;;860          end_row -= ptr->cur_start_row;
0000c8  69a0              LDR      r0,[r4,#0x18]
0000ca  1a3f              SUBS     r7,r7,r0
;;;861          while (undef_row < end_row) {
0000cc  e007              B        |L1.222|
                  |L1.206|
;;;862    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
0000ce  6821              LDR      r1,[r4,#0]
0000d0  f8510028          LDR      r0,[r1,r8,LSL #2]
0000d4  4659              MOV      r1,r11
0000d6  f7fffffe          BL       jzero_far
;;;863    	undef_row++;
0000da  f1080801          ADD      r8,r8,#1
                  |L1.222|
0000de  45b8              CMP      r8,r7                 ;861
0000e0  d3f5              BCC      |L1.206|
;;;864          }
;;;865        } else {
0000e2  e009              B        |L1.248|
                  |L1.228|
;;;866          if (! writable)		/* reader looking at undefined data */
0000e4  f1b90f00          CMP      r9,#0
0000e8  d106              BNE      |L1.248|
;;;867    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0000ea  2016              MOVS     r0,#0x16
0000ec  6829              LDR      r1,[r5,#0]
0000ee  6148              STR      r0,[r1,#0x14]
0000f0  6828              LDR      r0,[r5,#0]
0000f2  6801              LDR      r1,[r0,#0]
0000f4  4628              MOV      r0,r5
0000f6  4788              BLX      r1
                  |L1.248|
;;;868        }
;;;869      }
;;;870      /* Flag the buffer dirty if caller will write in it */
;;;871      if (writable)
0000f8  f1b90f00          CMP      r9,#0
0000fc  d001              BEQ      |L1.258|
;;;872        ptr->dirty = TRUE;
0000fe  2001              MOVS     r0,#1
000100  6260              STR      r0,[r4,#0x24]
                  |L1.258|
;;;873      /* Return address of proper part of the buffer */
;;;874      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
000102  69a1              LDR      r1,[r4,#0x18]
000104  1a71              SUBS     r1,r6,r1
000106  6820              LDR      r0,[r4,#0]
000108  eb000081          ADD      r0,r0,r1,LSL #2
;;;875    }
00010c  e8bd9ff0          POP      {r4-r12,pc}
;;;876    
                          ENDP


                          AREA ||i.access_virt_sarray||, CODE, READONLY, ALIGN=1

                  access_virt_sarray PROC
;;;718    /* caller intends to modify the accessed area. */
;;;719    METHODDEF(JSAMPARRAY) access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  469a              MOV      r10,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;720      JDIMENSION end_row = start_row + num_rows;
000010  eb06070a          ADD      r7,r6,r10
;;;721      JDIMENSION undef_row;
;;;722    
;;;723      /* debugging check */
;;;724      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000014  6860              LDR      r0,[r4,#4]
000016  42b8              CMP      r0,r7
000018  d304              BCC      |L2.36|
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  4550              CMP      r0,r10
00001e  d301              BCC      |L2.36|
;;;725          ptr->mem_buffer == NULL)
000020  6820              LDR      r0,[r4,#0]
000022  b930              CBNZ     r0,|L2.50|
                  |L2.36|
;;;726        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000024  2016              MOVS     r0,#0x16
000026  6829              LDR      r1,[r5,#0]
000028  6148              STR      r0,[r1,#0x14]
00002a  6828              LDR      r0,[r5,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4628              MOV      r0,r5
000030  4788              BLX      r1
                  |L2.50|
;;;727    
;;;728      /* Make the desired part of the virtual array accessible */
;;;729      if (start_row < ptr->cur_start_row ||
000032  69a0              LDR      r0,[r4,#0x18]
000034  42b0              CMP      r0,r6
000036  d804              BHI      |L2.66|
;;;730          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
000038  6921              LDR      r1,[r4,#0x10]
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  4408              ADD      r0,r0,r1
00003e  42b8              CMP      r0,r7
000040  d222              BCS      |L2.136|
                  |L2.66|
;;;731        if (! ptr->b_s_open)
000042  6aa0              LDR      r0,[r4,#0x28]
000044  b930              CBNZ     r0,|L2.84|
;;;732          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
000046  2045              MOVS     r0,#0x45
000048  6829              LDR      r1,[r5,#0]
00004a  6148              STR      r0,[r1,#0x14]
00004c  6828              LDR      r0,[r5,#0]
00004e  6801              LDR      r1,[r0,#0]
000050  4628              MOV      r0,r5
000052  4788              BLX      r1
                  |L2.84|
;;;733        /* Flush old buffer contents if necessary */
;;;734        if (ptr->dirty) {
000054  6a60              LDR      r0,[r4,#0x24]
000056  b130              CBZ      r0,|L2.102|
;;;735          do_sarray_io(cinfo, ptr, TRUE);
000058  2201              MOVS     r2,#1
00005a  4621              MOV      r1,r4
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       do_sarray_io
;;;736          ptr->dirty = FALSE;
000062  2000              MOVS     r0,#0
000064  6260              STR      r0,[r4,#0x24]
                  |L2.102|
;;;737        }
;;;738        /* Decide what part of virtual array to access.
;;;739         * Algorithm: if target address > current window, assume forward scan,
;;;740         * load starting at target address.  If target address < current window,
;;;741         * assume backward scan, load so that target area is top of window.
;;;742         * Note that when switching from forward write to forward read, will have
;;;743         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;744         */
;;;745        if (start_row > ptr->cur_start_row) {
000066  69a0              LDR      r0,[r4,#0x18]
000068  42b0              CMP      r0,r6
00006a  d201              BCS      |L2.112|
;;;746          ptr->cur_start_row = start_row;
00006c  61a6              STR      r6,[r4,#0x18]
00006e  e006              B        |L2.126|
                  |L2.112|
;;;747        } else {
;;;748          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;749          long ltemp;
;;;750    
;;;751          ltemp = (long) end_row - (long) ptr->rows_in_mem;
000070  6921              LDR      r1,[r4,#0x10]
000072  1a78              SUBS     r0,r7,r1
;;;752          if (ltemp < 0)
000074  2800              CMP      r0,#0
000076  da00              BGE      |L2.122|
;;;753    	ltemp = 0;		/* don't fall off front end of file */
000078  2000              MOVS     r0,#0
                  |L2.122|
;;;754          ptr->cur_start_row = (JDIMENSION) ltemp;
00007a  61a0              STR      r0,[r4,#0x18]
;;;755        }
00007c  bf00              NOP      
                  |L2.126|
;;;756        /* Read in the selected part of the array.
;;;757         * During the initial write pass, we will do no actual read
;;;758         * because the selected part is all undefined.
;;;759         */
;;;760        do_sarray_io(cinfo, ptr, FALSE);
00007e  2200              MOVS     r2,#0
000080  4621              MOV      r1,r4
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       do_sarray_io
                  |L2.136|
;;;761      }
;;;762      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;763       * To improve locality of access, we only prezero the part of the array
;;;764       * that the caller is about to access, not the entire in-memory array.
;;;765       */
;;;766      if (ptr->first_undef_row < end_row) {
000088  69e0              LDR      r0,[r4,#0x1c]
00008a  42b8              CMP      r0,r7
00008c  d233              BCS      |L2.246|
;;;767        if (ptr->first_undef_row < start_row) {
00008e  69e0              LDR      r0,[r4,#0x1c]
000090  42b0              CMP      r0,r6
000092  d20b              BCS      |L2.172|
;;;768          if (writable)		/* writer skipped over a section of array */
000094  f1b90f00          CMP      r9,#0
000098  d006              BEQ      |L2.168|
;;;769    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
00009a  2016              MOVS     r0,#0x16
00009c  6829              LDR      r1,[r5,#0]
00009e  6148              STR      r0,[r1,#0x14]
0000a0  6828              LDR      r0,[r5,#0]
0000a2  6801              LDR      r1,[r0,#0]
0000a4  4628              MOV      r0,r5
0000a6  4788              BLX      r1
                  |L2.168|
;;;770          undef_row = start_row;	/* but reader is allowed to read ahead */
0000a8  46b0              MOV      r8,r6
0000aa  e001              B        |L2.176|
                  |L2.172|
;;;771        } else {
;;;772          undef_row = ptr->first_undef_row;
0000ac  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L2.176|
;;;773        }
;;;774        if (writable)
0000b0  f1b90f00          CMP      r9,#0
0000b4  d000              BEQ      |L2.184|
;;;775          ptr->first_undef_row = end_row;
0000b6  61e7              STR      r7,[r4,#0x1c]
                  |L2.184|
;;;776        if (ptr->pre_zero) {
0000b8  6a20              LDR      r0,[r4,#0x20]
0000ba  b190              CBZ      r0,|L2.226|
;;;777          size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
0000bc  f8d4b008          LDR      r11,[r4,#8]
;;;778          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
0000c0  69a0              LDR      r0,[r4,#0x18]
0000c2  eba80800          SUB      r8,r8,r0
;;;779          end_row -= ptr->cur_start_row;
0000c6  69a0              LDR      r0,[r4,#0x18]
0000c8  1a3f              SUBS     r7,r7,r0
;;;780          while (undef_row < end_row) {
0000ca  e007              B        |L2.220|
                  |L2.204|
;;;781    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
0000cc  6821              LDR      r1,[r4,#0]
0000ce  f8510028          LDR      r0,[r1,r8,LSL #2]
0000d2  4659              MOV      r1,r11
0000d4  f7fffffe          BL       jzero_far
;;;782    	undef_row++;
0000d8  f1080801          ADD      r8,r8,#1
                  |L2.220|
0000dc  45b8              CMP      r8,r7                 ;780
0000de  d3f5              BCC      |L2.204|
;;;783          }
;;;784        } else {
0000e0  e009              B        |L2.246|
                  |L2.226|
;;;785          if (! writable)		/* reader looking at undefined data */
0000e2  f1b90f00          CMP      r9,#0
0000e6  d106              BNE      |L2.246|
;;;786    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0000e8  2016              MOVS     r0,#0x16
0000ea  6829              LDR      r1,[r5,#0]
0000ec  6148              STR      r0,[r1,#0x14]
0000ee  6828              LDR      r0,[r5,#0]
0000f0  6801              LDR      r1,[r0,#0]
0000f2  4628              MOV      r0,r5
0000f4  4788              BLX      r1
                  |L2.246|
;;;787        }
;;;788      }
;;;789      /* Flag the buffer dirty if caller will write in it */
;;;790      if (writable)
0000f6  f1b90f00          CMP      r9,#0
0000fa  d001              BEQ      |L2.256|
;;;791        ptr->dirty = TRUE;
0000fc  2001              MOVS     r0,#1
0000fe  6260              STR      r0,[r4,#0x24]
                  |L2.256|
;;;792      /* Return address of proper part of the buffer */
;;;793      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
000100  69a1              LDR      r1,[r4,#0x18]
000102  1a71              SUBS     r1,r6,r1
000104  6820              LDR      r0,[r4,#0]
000106  eb000081          ADD      r0,r0,r1,LSL #2
;;;794    }
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;795    
                          ENDP


                          AREA ||i.alloc_barray||, CODE, READONLY, ALIGN=2

                  alloc_barray PROC
;;;425    
;;;426    METHODDEF(JBLOCKARRAY) alloc_barray (j_common_ptr cinfo, int pool_id,  JDIMENSION blocksperrow, JDIMENSION numrows) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b083              SUB      sp,sp,#0xc
000006  4607              MOV      r7,r0
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;427      /* Allocate a 2-D coefficient-block array */
;;;428      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00000c  6878              LDR      r0,[r7,#4]
00000e  9002              STR      r0,[sp,#8]
;;;429      JBLOCKARRAY result;
;;;430      JBLOCKROW workspace;
;;;431      JDIMENSION rowsperchunk, currow, i;
;;;432      long ltemp;
;;;433    
;;;434      /* Calculate max # of rows allowed in one allocation chunk */
;;;435      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000010  ea4f10c8          LSL      r0,r8,#7
000014  491f              LDR      r1,|L3.148|
000016  fbb1faf0          UDIV     r10,r1,r0
;;;436    	  ((long) blocksperrow * SIZEOF(JBLOCK));
;;;437      if (ltemp <= 0)
00001a  f1ba0f00          CMP      r10,#0
00001e  dc06              BGT      |L3.46|
;;;438        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
000020  2046              MOVS     r0,#0x46
000022  6839              LDR      r1,[r7,#0]
000024  6148              STR      r0,[r1,#0x14]
000026  6838              LDR      r0,[r7,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  4638              MOV      r0,r7
00002c  4788              BLX      r1
                  |L3.46|
;;;439      if (ltemp < (long) numrows)
00002e  45a2              CMP      r10,r4
000030  da01              BGE      |L3.54|
;;;440        rowsperchunk = (JDIMENSION) ltemp;
000032  4655              MOV      r5,r10
000034  e000              B        |L3.56|
                  |L3.54|
;;;441      else
;;;442        rowsperchunk = numrows;
000036  4625              MOV      r5,r4
                  |L3.56|
;;;443      mem->last_rowsperchunk = rowsperchunk;
000038  9802              LDR      r0,[sp,#8]
00003a  6505              STR      r5,[r0,#0x50]
;;;444    
;;;445      /* Get space for row pointers (small object) */
;;;446      result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
00003c  00a2              LSLS     r2,r4,#2
00003e  4638              MOV      r0,r7
000040  9904              LDR      r1,[sp,#0x10]
000042  f7fffffe          BL       alloc_small
000046  4681              MOV      r9,r0
;;;447    				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
;;;448    
;;;449      /* Get the rows themselves (large objects) */
;;;450      currow = 0;
000048  2600              MOVS     r6,#0
;;;451      while (currow < numrows) {
00004a  e01c              B        |L3.134|
                  |L3.76|
;;;452        rowsperchunk = MIN(rowsperchunk, numrows - currow);
00004c  1ba0              SUBS     r0,r4,r6
00004e  42a8              CMP      r0,r5
000050  d901              BLS      |L3.86|
000052  4628              MOV      r0,r5
000054  e000              B        |L3.88|
                  |L3.86|
000056  1ba0              SUBS     r0,r4,r6
                  |L3.88|
000058  4605              MOV      r5,r0
;;;453        workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
00005a  fb05f008          MUL      r0,r5,r8
00005e  01c2              LSLS     r2,r0,#7
000060  4638              MOV      r0,r7
000062  9904              LDR      r1,[sp,#0x10]
000064  f7fffffe          BL       alloc_large
000068  4683              MOV      r11,r0
;;;454    	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
;;;455    		  * SIZEOF(JBLOCK)));
;;;456        for (i = rowsperchunk; i > 0; i--) {
00006a  9501              STR      r5,[sp,#4]
00006c  e008              B        |L3.128|
                  |L3.110|
;;;457          result[currow++] = workspace;
00006e  4630              MOV      r0,r6
000070  1c76              ADDS     r6,r6,#1
000072  f849b020          STR      r11,[r9,r0,LSL #2]
;;;458          workspace += blocksperrow;
000076  eb0b1bc8          ADD      r11,r11,r8,LSL #7
00007a  9801              LDR      r0,[sp,#4]            ;456
00007c  1e40              SUBS     r0,r0,#1              ;456
00007e  9001              STR      r0,[sp,#4]            ;456
                  |L3.128|
000080  9801              LDR      r0,[sp,#4]            ;456
000082  2800              CMP      r0,#0                 ;456
000084  d1f3              BNE      |L3.110|
                  |L3.134|
000086  42a6              CMP      r6,r4                 ;451
000088  d3e0              BCC      |L3.76|
;;;459        }
;;;460      }
;;;461    
;;;462      return result;
00008a  4648              MOV      r0,r9
;;;463    }
00008c  b007              ADD      sp,sp,#0x1c
00008e  e8bd8ff0          POP      {r4-r11,pc}
;;;464    
                          ENDP

000092  0000              DCW      0x0000
                  |L3.148|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_large||, CODE, READONLY, ALIGN=2

                  alloc_large PROC
;;;332    
;;;333    METHODDEF(void FAR *) alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject) /* Allocate a "large" object */ {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;334      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00000a  f8d78004          LDR      r8,[r7,#4]
;;;335      large_pool_ptr hdr_ptr;
;;;336      size_t odd_bytes;
;;;337    
;;;338      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;339      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr))) {
00000e  481f              LDR      r0,|L4.140|
000010  4285              CMP      r5,r0
000012  d903              BLS      |L4.28|
;;;340        out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
000014  2103              MOVS     r1,#3
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       out_of_memory
                  |L4.28|
;;;341      }
;;;342      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;343      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
00001c  f0050907          AND      r9,r5,#7
;;;344      if (odd_bytes > 0) {
000020  f1b90f00          CMP      r9,#0
000024  d002              BEQ      |L4.44|
;;;345        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000026  f1c90008          RSB      r0,r9,#8
00002a  4405              ADD      r5,r5,r0
                  |L4.44|
;;;346      }
;;;347      /* Always make a new pool */
;;;348      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS) {
00002c  2e00              CMP      r6,#0
00002e  db01              BLT      |L4.52|
000030  2e02              CMP      r6,#2
000032  db08              BLT      |L4.70|
                  |L4.52|
;;;349        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000034  200e              MOVS     r0,#0xe
000036  6839              LDR      r1,[r7,#0]
000038  6148              STR      r0,[r1,#0x14]
00003a  6838              LDR      r0,[r7,#0]
00003c  6186              STR      r6,[r0,#0x18]
00003e  6838              LDR      r0,[r7,#0]
000040  6801              LDR      r1,[r0,#0]
000042  4638              MOV      r0,r7
000044  4788              BLX      r1
                  |L4.70|
;;;350      }
;;;351    
;;;352      hdr_ptr = (large_pool_ptr) jpeg_get_small/*RS: Changed from jpeg_get_large*/ (cinfo, sizeofobject +  SIZEOF(large_pool_hdr));
000046  f1050110          ADD      r1,r5,#0x10
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       jpeg_get_small
000050  4604              MOV      r4,r0
;;;353      if (hdr_ptr == NULL) {
000052  b91c              CBNZ     r4,|L4.92|
;;;354        out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
000054  2104              MOVS     r1,#4
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       out_of_memory
                  |L4.92|
;;;355      }
;;;356      mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
00005c  f1050010          ADD      r0,r5,#0x10
000060  f8d8104c          LDR      r1,[r8,#0x4c]
000064  4408              ADD      r0,r0,r1
000066  f8c8004c          STR      r0,[r8,#0x4c]
;;;357      /* Success, initialize the new pool header and add to list */
;;;358      hdr_ptr->hdr.next = mem->large_list[pool_id];
00006a  f108003c          ADD      r0,r8,#0x3c
00006e  f8500026          LDR      r0,[r0,r6,LSL #2]
000072  6020              STR      r0,[r4,#0]
;;;359      /* We maintain space counts in each pool header for statistical purposes,
;;;360       * even though they are not needed for allocation.
;;;361       */
;;;362      hdr_ptr->hdr.bytes_used = sizeofobject;
000074  6065              STR      r5,[r4,#4]
;;;363      hdr_ptr->hdr.bytes_left = 0;
000076  2000              MOVS     r0,#0
000078  60a0              STR      r0,[r4,#8]
;;;364      mem->large_list[pool_id] = hdr_ptr;
00007a  f108003c          ADD      r0,r8,#0x3c
00007e  f8404026          STR      r4,[r0,r6,LSL #2]
;;;365    
;;;366      return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
000082  f1040010          ADD      r0,r4,#0x10
;;;367    }
000086  e8bd87f0          POP      {r4-r10,pc}
;;;368    
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_sarray||, CODE, READONLY, ALIGN=2

                  alloc_sarray PROC
;;;382    
;;;383    METHODDEF(JSAMPARRAY) alloc_sarray (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b083              SUB      sp,sp,#0xc
000006  4680              MOV      r8,r0
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;384    /* Allocate a 2-D sample array */
;;;385      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00000c  f8d80004          LDR      r0,[r8,#4]
000010  9002              STR      r0,[sp,#8]
;;;386      JSAMPARRAY result;
;;;387      JSAMPROW workspace;
;;;388      JDIMENSION rowsperchunk, currow, i;
;;;389      long ltemp;
;;;390    
;;;391      /* Calculate max # of rows allowed in one allocation chunk */
;;;392      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000012  481f              LDR      r0,|L5.144|
000014  fbb0faf6          UDIV     r10,r0,r6
;;;393    	  ((long) samplesperrow * SIZEOF(JSAMPLE));
;;;394      if (ltemp <= 0)
000018  f1ba0f00          CMP      r10,#0
00001c  dc08              BGT      |L5.48|
;;;395        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
00001e  2046              MOVS     r0,#0x46
000020  f8d81000          LDR      r1,[r8,#0]
000024  6148              STR      r0,[r1,#0x14]
000026  f8d80000          LDR      r0,[r8,#0]
00002a  6801              LDR      r1,[r0,#0]
00002c  4640              MOV      r0,r8
00002e  4788              BLX      r1
                  |L5.48|
;;;396      if (ltemp < (long) numrows)
000030  45a2              CMP      r10,r4
000032  da01              BGE      |L5.56|
;;;397        rowsperchunk = (JDIMENSION) ltemp;
000034  4655              MOV      r5,r10
000036  e000              B        |L5.58|
                  |L5.56|
;;;398      else
;;;399        rowsperchunk = numrows;
000038  4625              MOV      r5,r4
                  |L5.58|
;;;400      mem->last_rowsperchunk = rowsperchunk;
00003a  9802              LDR      r0,[sp,#8]
00003c  6505              STR      r5,[r0,#0x50]
;;;401    
;;;402      /* Get space for row pointers (small object) */
;;;403      result = (JSAMPARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows * SIZEOF(JSAMPROW)));
00003e  00a2              LSLS     r2,r4,#2
000040  4640              MOV      r0,r8
000042  9904              LDR      r1,[sp,#0x10]
000044  f7fffffe          BL       alloc_small
000048  4681              MOV      r9,r0
;;;404      /* Get the rows themselves (large objects) */
;;;405      currow = 0;
00004a  2700              MOVS     r7,#0
;;;406      while (currow < numrows) {
00004c  e01a              B        |L5.132|
                  |L5.78|
;;;407        rowsperchunk = MIN(rowsperchunk, numrows - currow);
00004e  1be0              SUBS     r0,r4,r7
000050  42a8              CMP      r0,r5
000052  d901              BLS      |L5.88|
000054  4628              MOV      r0,r5
000056  e000              B        |L5.90|
                  |L5.88|
000058  1be0              SUBS     r0,r4,r7
                  |L5.90|
00005a  4605              MOV      r5,r0
;;;408        workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
00005c  fb05f206          MUL      r2,r5,r6
000060  4640              MOV      r0,r8
000062  9904              LDR      r1,[sp,#0x10]
000064  f7fffffe          BL       alloc_large
000068  4683              MOV      r11,r0
;;;409    	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
;;;410    		  * SIZEOF(JSAMPLE)));
;;;411        for (i = rowsperchunk; i > 0; i--) {
00006a  9501              STR      r5,[sp,#4]
00006c  e007              B        |L5.126|
                  |L5.110|
;;;412          result[currow++] = workspace;
00006e  4638              MOV      r0,r7
000070  1c7f              ADDS     r7,r7,#1
000072  f849b020          STR      r11,[r9,r0,LSL #2]
;;;413          workspace += samplesperrow;
000076  44b3              ADD      r11,r11,r6
000078  9801              LDR      r0,[sp,#4]            ;411
00007a  1e40              SUBS     r0,r0,#1              ;411
00007c  9001              STR      r0,[sp,#4]            ;411
                  |L5.126|
00007e  9801              LDR      r0,[sp,#4]            ;411
000080  2800              CMP      r0,#0                 ;411
000082  d1f4              BNE      |L5.110|
                  |L5.132|
000084  42a7              CMP      r7,r4                 ;406
000086  d3e2              BCC      |L5.78|
;;;414        }
;;;415      }
;;;416    
;;;417      return result;
000088  4648              MOV      r0,r9
;;;418    }
00008a  b007              ADD      sp,sp,#0x1c
00008c  e8bd8ff0          POP      {r4-r11,pc}
;;;419    
                          ENDP

                  |L5.144|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_small||, CODE, READONLY, ALIGN=2

                  alloc_small PROC
;;;248    
;;;249    METHODDEF(void *) alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;250    /* Allocate a "small" object */
;;;251    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;252      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00000a  f8d8b004          LDR      r11,[r8,#4]
;;;253      small_pool_ptr hdr_ptr, prev_hdr_ptr;
;;;254      char * data_ptr;
;;;255      size_t odd_bytes, min_request, slop;
;;;256    
;;;257      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;258      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
00000e  483f              LDR      r0,|L6.268|
000010  4285              CMP      r5,r0
000012  d903              BLS      |L6.28|
;;;259        out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
000014  2101              MOVS     r1,#1
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       out_of_memory
                  |L6.28|
;;;260    
;;;261      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;262      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
00001c  f0050007          AND      r0,r5,#7
000020  9000              STR      r0,[sp,#0]
;;;263      if (odd_bytes > 0)
000022  9800              LDR      r0,[sp,#0]
000024  b118              CBZ      r0,|L6.46|
;;;264        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000026  9800              LDR      r0,[sp,#0]
000028  f1c00008          RSB      r0,r0,#8
00002c  4405              ADD      r5,r5,r0
                  |L6.46|
;;;265    
;;;266      /* See if space is available in any existing pool */
;;;267      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
00002e  2e00              CMP      r6,#0
000030  db01              BLT      |L6.54|
000032  2e02              CMP      r6,#2
000034  db0b              BLT      |L6.78|
                  |L6.54|
;;;268        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000036  200e              MOVS     r0,#0xe
000038  f8d81000          LDR      r1,[r8,#0]
00003c  6148              STR      r0,[r1,#0x14]
00003e  f8d80000          LDR      r0,[r8,#0]
000042  6186              STR      r6,[r0,#0x18]
000044  f8d80000          LDR      r0,[r8,#0]
000048  6801              LDR      r1,[r0,#0]
00004a  4640              MOV      r0,r8
00004c  4788              BLX      r1
                  |L6.78|
;;;269      prev_hdr_ptr = NULL;
00004e  f04f0900          MOV      r9,#0
;;;270      hdr_ptr = mem->small_list[pool_id];
000052  f10b0034          ADD      r0,r11,#0x34
000056  f8504026          LDR      r4,[r0,r6,LSL #2]
;;;271      while (hdr_ptr != NULL) {
00005a  e005              B        |L6.104|
                  |L6.92|
;;;272        if (hdr_ptr->hdr.bytes_left >= sizeofobject)
00005c  68a0              LDR      r0,[r4,#8]
00005e  42a8              CMP      r0,r5
000060  d300              BCC      |L6.100|
;;;273          break;			/* found pool with enough space */
000062  e003              B        |L6.108|
                  |L6.100|
;;;274        prev_hdr_ptr = hdr_ptr;
000064  46a1              MOV      r9,r4
;;;275        hdr_ptr = hdr_ptr->hdr.next;
000066  6824              LDR      r4,[r4,#0]
                  |L6.104|
000068  2c00              CMP      r4,#0                 ;271
00006a  d1f7              BNE      |L6.92|
                  |L6.108|
00006c  bf00              NOP                            ;273
;;;276      }
;;;277    
;;;278      /* Time to make a new pool? */
;;;279      if (hdr_ptr == NULL) {
00006e  bbd4              CBNZ     r4,|L6.230|
;;;280        /* min_request is what we need now, slop is what will be leftover */
;;;281        min_request = sizeofobject + SIZEOF(small_pool_hdr);
000070  f1050a10          ADD      r10,r5,#0x10
;;;282        if (prev_hdr_ptr == NULL)	/* first pool in class? */
000074  f1b90f00          CMP      r9,#0
000078  d103              BNE      |L6.130|
;;;283          slop = first_pool_slop[pool_id];
00007a  4825              LDR      r0,|L6.272|
00007c  f8507026          LDR      r7,[r0,r6,LSL #2]
000080  e002              B        |L6.136|
                  |L6.130|
;;;284        else
;;;285          slop = extra_pool_slop[pool_id];
000082  4824              LDR      r0,|L6.276|
000084  f8507026          LDR      r7,[r0,r6,LSL #2]
                  |L6.136|
;;;286        /* Don't ask for more than MAX_ALLOC_CHUNK */
;;;287        if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
000088  4820              LDR      r0,|L6.268|
00008a  3010              ADDS     r0,r0,#0x10
00008c  eba0000a          SUB      r0,r0,r10
000090  42b8              CMP      r0,r7
000092  d203              BCS      |L6.156|
;;;288          slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
000094  481d              LDR      r0,|L6.268|
000096  3010              ADDS     r0,r0,#0x10
000098  eba0070a          SUB      r7,r0,r10
                  |L6.156|
;;;289        /* Try to get space, if fail reduce slop and try again */
;;;290        while(1) {
00009c  e00e              B        |L6.188|
                  |L6.158|
;;;291          hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
00009e  eb0a0107          ADD      r1,r10,r7
0000a2  4640              MOV      r0,r8
0000a4  f7fffffe          BL       jpeg_get_small
0000a8  4604              MOV      r4,r0
;;;292          if (hdr_ptr != NULL)
0000aa  b104              CBZ      r4,|L6.174|
;;;293    	break;
0000ac  e007              B        |L6.190|
                  |L6.174|
;;;294          slop /= 2;
0000ae  087f              LSRS     r7,r7,#1
;;;295          if (slop < MIN_SLOP)	/* give up when it gets real small */
0000b0  2f32              CMP      r7,#0x32
0000b2  d203              BCS      |L6.188|
;;;296    	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
0000b4  2102              MOVS     r1,#2
0000b6  4640              MOV      r0,r8
0000b8  f7fffffe          BL       out_of_memory
                  |L6.188|
0000bc  e7ef              B        |L6.158|
                  |L6.190|
0000be  bf00              NOP                            ;293
;;;297        }
;;;298        mem->total_space_allocated += min_request + slop;
0000c0  eb0a0107          ADD      r1,r10,r7
0000c4  f8db004c          LDR      r0,[r11,#0x4c]
0000c8  4408              ADD      r0,r0,r1
0000ca  f8cb004c          STR      r0,[r11,#0x4c]
;;;299        /* Success, initialize the new pool header and add to end of list */
;;;300        hdr_ptr->hdr.next = NULL;
0000ce  2000              MOVS     r0,#0
0000d0  6020              STR      r0,[r4,#0]
;;;301        hdr_ptr->hdr.bytes_used = 0;
0000d2  6060              STR      r0,[r4,#4]
;;;302        hdr_ptr->hdr.bytes_left = sizeofobject + slop;
0000d4  19e8              ADDS     r0,r5,r7
0000d6  60a0              STR      r0,[r4,#8]
;;;303        if (prev_hdr_ptr == NULL)	/* first pool in class? */
0000d8  f1b90f00          CMP      r9,#0
0000dc  d104              BNE      |L6.232|
;;;304          mem->small_list[pool_id] = hdr_ptr;
0000de  f10b0034          ADD      r0,r11,#0x34
0000e2  f8404026          STR      r4,[r0,r6,LSL #2]
                  |L6.230|
0000e6  e001              B        |L6.236|
                  |L6.232|
;;;305        else
;;;306          prev_hdr_ptr->hdr.next = hdr_ptr;
0000e8  f8c94000          STR      r4,[r9,#0]
                  |L6.236|
;;;307      }
;;;308    
;;;309      /* OK, allocate the object from the current pool */
;;;310      data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
0000ec  f1040010          ADD      r0,r4,#0x10
0000f0  9001              STR      r0,[sp,#4]
;;;311      data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
0000f2  9801              LDR      r0,[sp,#4]
0000f4  6861              LDR      r1,[r4,#4]
0000f6  4408              ADD      r0,r0,r1
0000f8  9001              STR      r0,[sp,#4]
;;;312      hdr_ptr->hdr.bytes_used += sizeofobject;
0000fa  6860              LDR      r0,[r4,#4]
0000fc  4428              ADD      r0,r0,r5
0000fe  6060              STR      r0,[r4,#4]
;;;313      hdr_ptr->hdr.bytes_left -= sizeofobject;
000100  68a0              LDR      r0,[r4,#8]
000102  1b40              SUBS     r0,r0,r5
000104  60a0              STR      r0,[r4,#8]
;;;314    
;;;315      return (void *) data_ptr;
000106  9801              LDR      r0,[sp,#4]
;;;316    }
000108  e8bd9ffc          POP      {r2-r12,pc}
;;;317    
                          ENDP

                  |L6.268|
                          DCD      0x3b9ac9f0
                  |L6.272|
                          DCD      first_pool_slop
                  |L6.276|
                          DCD      extra_pool_slop

                          AREA ||i.do_barray_io||, CODE, READONLY, ALIGN=1

                  do_barray_io PROC
;;;685    /* Do backing store read or write of a virtual coefficient-block array */
;;;686    LOCAL(void) do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b082              SUB      sp,sp,#8
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
;;;687      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;688    
;;;689      bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
00000a  68a0              LDR      r0,[r4,#8]
00000c  ea4f1ac0          LSL      r10,r0,#7
;;;690      file_offset = ptr->cur_start_row * bytesperrow;
000010  69a0              LDR      r0,[r4,#0x18]
000012  fb00fb0a          MUL      r11,r0,r10
;;;691      /* Loop to read or write each allocation chunk in mem_buffer */
;;;692      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000016  2500              MOVS     r5,#0
000018  e040              B        |L7.156|
                  |L7.26|
;;;693        /* One chunk, but check for short chunk at end of buffer */
;;;694        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
00001a  e9d41004          LDRD     r1,r0,[r4,#0x10]
00001e  1b49              SUBS     r1,r1,r5
000020  4288              CMP      r0,r1
000022  da01              BGE      |L7.40|
000024  6960              LDR      r0,[r4,#0x14]
000026  e001              B        |L7.44|
                  |L7.40|
000028  6920              LDR      r0,[r4,#0x10]
00002a  1b40              SUBS     r0,r0,r5
                  |L7.44|
00002c  4680              MOV      r8,r0
;;;695        /* Transfer no more than is currently defined */
;;;696        thisrow = (long) ptr->cur_start_row + i;
00002e  69a0              LDR      r0,[r4,#0x18]
000030  1946              ADDS     r6,r0,r5
;;;697        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
000032  69e0              LDR      r0,[r4,#0x1c]
000034  1b80              SUBS     r0,r0,r6
000036  4540              CMP      r0,r8
000038  dd01              BLE      |L7.62|
00003a  4640              MOV      r0,r8
00003c  e001              B        |L7.66|
                  |L7.62|
00003e  69e0              LDR      r0,[r4,#0x1c]
000040  1b80              SUBS     r0,r0,r6
                  |L7.66|
000042  4680              MOV      r8,r0
;;;698        /* Transfer no more than fits in file */
;;;699        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
000044  6860              LDR      r0,[r4,#4]
000046  1b80              SUBS     r0,r0,r6
000048  4540              CMP      r0,r8
00004a  dd01              BLE      |L7.80|
00004c  4640              MOV      r0,r8
00004e  e001              B        |L7.84|
                  |L7.80|
000050  6860              LDR      r0,[r4,#4]
000052  1b80              SUBS     r0,r0,r6
                  |L7.84|
000054  4680              MOV      r8,r0
;;;700        if (rows <= 0)		/* this chunk might be past end of file! */
000056  f1b80f00          CMP      r8,#0
00005a  dc00              BGT      |L7.94|
;;;701          break;
00005c  e021              B        |L7.162|
                  |L7.94|
;;;702        byte_count = rows * bytesperrow;
00005e  fb08f70a          MUL      r7,r8,r10
;;;703        if (writing)
000062  f1b90f00          CMP      r9,#0
000066  d00b              BEQ      |L7.128|
;;;704          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000068  9700              STR      r7,[sp,#0]
00006a  6820              LDR      r0,[r4,#0]
00006c  f8502025          LDR      r2,[r0,r5,LSL #2]
000070  465b              MOV      r3,r11
000072  f1040130          ADD      r1,r4,#0x30
000076  f8d4c034          LDR      r12,[r4,#0x34]
00007a  9802              LDR      r0,[sp,#8]
00007c  47e0              BLX      r12
00007e  e00a              B        |L7.150|
                  |L7.128|
;;;705    					    (void FAR *) ptr->mem_buffer[i],
;;;706    					    file_offset, byte_count);
;;;707        else
;;;708          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
000080  9700              STR      r7,[sp,#0]
000082  6820              LDR      r0,[r4,#0]
000084  f8502025          LDR      r2,[r0,r5,LSL #2]
000088  465b              MOV      r3,r11
00008a  f1040130          ADD      r1,r4,#0x30
00008e  f8d4c030          LDR      r12,[r4,#0x30]
000092  9802              LDR      r0,[sp,#8]
000094  47e0              BLX      r12
                  |L7.150|
;;;709    					   (void FAR *) ptr->mem_buffer[i],
;;;710    					   file_offset, byte_count);
;;;711        file_offset += byte_count;
000096  44bb              ADD      r11,r11,r7
000098  6960              LDR      r0,[r4,#0x14]         ;692
00009a  4405              ADD      r5,r5,r0              ;692
                  |L7.156|
00009c  6920              LDR      r0,[r4,#0x10]         ;692
00009e  42a8              CMP      r0,r5                 ;692
0000a0  dcbb              BGT      |L7.26|
                  |L7.162|
0000a2  bf00              NOP                            ;701
;;;712      }
;;;713    }
0000a4  b005              ADD      sp,sp,#0x14
0000a6  e8bd8ff0          POP      {r4-r11,pc}
;;;714    
                          ENDP


                          AREA ||i.do_sarray_io||, CODE, READONLY, ALIGN=1

                  do_sarray_io PROC
;;;653    
;;;654    LOCAL(void) do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b082              SUB      sp,sp,#8
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
;;;655    /* Do backing store read or write of a virtual sample array */
;;;656      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;657    
;;;658      bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
00000a  f8d4a008          LDR      r10,[r4,#8]
;;;659      file_offset = ptr->cur_start_row * bytesperrow;
00000e  69a0              LDR      r0,[r4,#0x18]
000010  fb00fb0a          MUL      r11,r0,r10
;;;660      /* Loop to read or write each allocation chunk in mem_buffer */
;;;661      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000014  2500              MOVS     r5,#0
000016  e040              B        |L8.154|
                  |L8.24|
;;;662        /* One chunk, but check for short chunk at end of buffer */
;;;663        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
000018  e9d41004          LDRD     r1,r0,[r4,#0x10]
00001c  1b49              SUBS     r1,r1,r5
00001e  4288              CMP      r0,r1
000020  da01              BGE      |L8.38|
000022  6960              LDR      r0,[r4,#0x14]
000024  e001              B        |L8.42|
                  |L8.38|
000026  6920              LDR      r0,[r4,#0x10]
000028  1b40              SUBS     r0,r0,r5
                  |L8.42|
00002a  4680              MOV      r8,r0
;;;664        /* Transfer no more than is currently defined */
;;;665        thisrow = (long) ptr->cur_start_row + i;
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  1946              ADDS     r6,r0,r5
;;;666        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
000030  69e0              LDR      r0,[r4,#0x1c]
000032  1b80              SUBS     r0,r0,r6
000034  4540              CMP      r0,r8
000036  dd01              BLE      |L8.60|
000038  4640              MOV      r0,r8
00003a  e001              B        |L8.64|
                  |L8.60|
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  1b80              SUBS     r0,r0,r6
                  |L8.64|
000040  4680              MOV      r8,r0
;;;667        /* Transfer no more than fits in file */
;;;668        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
000042  6860              LDR      r0,[r4,#4]
000044  1b80              SUBS     r0,r0,r6
000046  4540              CMP      r0,r8
000048  dd01              BLE      |L8.78|
00004a  4640              MOV      r0,r8
00004c  e001              B        |L8.82|
                  |L8.78|
00004e  6860              LDR      r0,[r4,#4]
000050  1b80              SUBS     r0,r0,r6
                  |L8.82|
000052  4680              MOV      r8,r0
;;;669        if (rows <= 0)		/* this chunk might be past end of file! */
000054  f1b80f00          CMP      r8,#0
000058  dc00              BGT      |L8.92|
;;;670          break;
00005a  e021              B        |L8.160|
                  |L8.92|
;;;671        byte_count = rows * bytesperrow;
00005c  fb08f70a          MUL      r7,r8,r10
;;;672        if (writing)
000060  f1b90f00          CMP      r9,#0
000064  d00b              BEQ      |L8.126|
;;;673          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000066  9700              STR      r7,[sp,#0]
000068  6820              LDR      r0,[r4,#0]
00006a  f8502025          LDR      r2,[r0,r5,LSL #2]
00006e  465b              MOV      r3,r11
000070  f1040130          ADD      r1,r4,#0x30
000074  f8d4c034          LDR      r12,[r4,#0x34]
000078  9802              LDR      r0,[sp,#8]
00007a  47e0              BLX      r12
00007c  e00a              B        |L8.148|
                  |L8.126|
;;;674    					    (void FAR *) ptr->mem_buffer[i],
;;;675    					    file_offset, byte_count);
;;;676        else
;;;677          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
00007e  9700              STR      r7,[sp,#0]
000080  6820              LDR      r0,[r4,#0]
000082  f8502025          LDR      r2,[r0,r5,LSL #2]
000086  465b              MOV      r3,r11
000088  f1040130          ADD      r1,r4,#0x30
00008c  f8d4c030          LDR      r12,[r4,#0x30]
000090  9802              LDR      r0,[sp,#8]
000092  47e0              BLX      r12
                  |L8.148|
;;;678    					   (void FAR *) ptr->mem_buffer[i],
;;;679    					   file_offset, byte_count);
;;;680        file_offset += byte_count;
000094  44bb              ADD      r11,r11,r7
000096  6960              LDR      r0,[r4,#0x14]         ;661
000098  4405              ADD      r5,r5,r0              ;661
                  |L8.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;661
00009c  42a8              CMP      r0,r5                 ;661
00009e  dcbb              BGT      |L8.24|
                  |L8.160|
0000a0  bf00              NOP                            ;670
;;;681      }
;;;682    }
0000a2  b005              ADD      sp,sp,#0x14
0000a4  e8bd8ff0          POP      {r4-r11,pc}
;;;683    
                          ENDP


                          AREA ||i.free_pool||, CODE, READONLY, ALIGN=1

                  free_pool PROC
;;;882    METHODDEF(void)
;;;883    free_pool (j_common_ptr cinfo, int pool_id)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;884    {
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
;;;885      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000008  f8da4004          LDR      r4,[r10,#4]
;;;886      small_pool_ptr shdr_ptr;
;;;887      large_pool_ptr lhdr_ptr;
;;;888      size_t space_freed;
;;;889    
;;;890      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
00000c  2d00              CMP      r5,#0
00000e  db01              BLT      |L9.20|
000010  2d02              CMP      r5,#2
000012  db0b              BLT      |L9.44|
                  |L9.20|
;;;891        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000014  200e              MOVS     r0,#0xe
000016  f8da1000          LDR      r1,[r10,#0]
00001a  6148              STR      r0,[r1,#0x14]
00001c  f8da0000          LDR      r0,[r10,#0]
000020  6185              STR      r5,[r0,#0x18]
000022  f8da0000          LDR      r0,[r10,#0]
000026  6801              LDR      r1,[r0,#0]
000028  4650              MOV      r0,r10
00002a  4788              BLX      r1
                  |L9.44|
;;;892    
;;;893    #ifdef MEM_STATS
;;;894      if (cinfo->err->trace_level > 1)
;;;895        print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
;;;896    #endif
;;;897    
;;;898      /* If freeing IMAGE pool, close any virtual arrays first */
;;;899      if (pool_id == JPOOL_IMAGE) {
00002c  2d01              CMP      r5,#1
00002e  d126              BNE      |L9.126|
;;;900        jvirt_sarray_ptr sptr;
;;;901        jvirt_barray_ptr bptr;
;;;902    
;;;903        for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
000030  f8d49044          LDR      r9,[r4,#0x44]
000034  e00d              B        |L9.82|
                  |L9.54|
;;;904          if (sptr->b_s_open) {	/* there may be no backing store */
000036  f8d90028          LDR      r0,[r9,#0x28]
00003a  b140              CBZ      r0,|L9.78|
;;;905    	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
00003c  2000              MOVS     r0,#0
00003e  f8c90028          STR      r0,[r9,#0x28]
;;;906    	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
000042  f1090130          ADD      r1,r9,#0x30
000046  4650              MOV      r0,r10
000048  f8d92038          LDR      r2,[r9,#0x38]
00004c  4790              BLX      r2
                  |L9.78|
00004e  f8d9902c          LDR      r9,[r9,#0x2c]         ;903
                  |L9.82|
000052  f1b90f00          CMP      r9,#0                 ;903
000056  d1ee              BNE      |L9.54|
;;;907          }
;;;908        }
;;;909        mem->virt_sarray_list = NULL;
000058  2000              MOVS     r0,#0
00005a  6460              STR      r0,[r4,#0x44]
;;;910        for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
00005c  6ca6              LDR      r6,[r4,#0x48]
00005e  e009              B        |L9.116|
                  |L9.96|
;;;911          if (bptr->b_s_open) {	/* there may be no backing store */
000060  6ab0              LDR      r0,[r6,#0x28]
000062  b130              CBZ      r0,|L9.114|
;;;912    	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
000064  2000              MOVS     r0,#0
000066  62b0              STR      r0,[r6,#0x28]
;;;913    	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
000068  f1060130          ADD      r1,r6,#0x30
00006c  4650              MOV      r0,r10
00006e  6bb2              LDR      r2,[r6,#0x38]
000070  4790              BLX      r2
                  |L9.114|
000072  6af6              LDR      r6,[r6,#0x2c]         ;910
                  |L9.116|
000074  2e00              CMP      r6,#0                 ;910
000076  d1f3              BNE      |L9.96|
;;;914          }
;;;915        }
;;;916        mem->virt_barray_list = NULL;
000078  2000              MOVS     r0,#0
00007a  64a0              STR      r0,[r4,#0x48]
;;;917      }
00007c  bf00              NOP      
                  |L9.126|
;;;918    
;;;919      /* Release large objects */
;;;920      lhdr_ptr = mem->large_list[pool_id];
00007e  f104003c          ADD      r0,r4,#0x3c
000082  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;921      mem->large_list[pool_id] = NULL;
000086  2100              MOVS     r1,#0
000088  f8401025          STR      r1,[r0,r5,LSL #2]
;;;922    
;;;923      while (lhdr_ptr != NULL) {
00008c  e011              B        |L9.178|
                  |L9.142|
;;;924        large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
00008e  f8d86000          LDR      r6,[r8,#0]
;;;925        space_freed = lhdr_ptr->hdr.bytes_used +
000092  e9d80101          LDRD     r0,r1,[r8,#4]
000096  4408              ADD      r0,r0,r1
000098  f1000b10          ADD      r11,r0,#0x10
;;;926    		  lhdr_ptr->hdr.bytes_left +
;;;927    		  SIZEOF(large_pool_hdr);
;;;928        jpeg_free_small/*RS: Changed from jpeg_free_large*/(cinfo, (void FAR *) lhdr_ptr, space_freed);
00009c  465a              MOV      r2,r11
00009e  4641              MOV      r1,r8
0000a0  4650              MOV      r0,r10
0000a2  f7fffffe          BL       jpeg_free_small
;;;929        mem->total_space_allocated -= space_freed;
0000a6  6ce0              LDR      r0,[r4,#0x4c]
0000a8  eba0000b          SUB      r0,r0,r11
0000ac  64e0              STR      r0,[r4,#0x4c]
;;;930        lhdr_ptr = next_lhdr_ptr;
0000ae  46b0              MOV      r8,r6
;;;931      }
0000b0  bf00              NOP      
                  |L9.178|
0000b2  f1b80f00          CMP      r8,#0                 ;923
0000b6  d1ea              BNE      |L9.142|
;;;932    
;;;933      /* Release small objects */
;;;934      shdr_ptr = mem->small_list[pool_id];
0000b8  f1040034          ADD      r0,r4,#0x34
0000bc  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;935      mem->small_list[pool_id] = NULL;
0000c0  2100              MOVS     r1,#0
0000c2  f8401025          STR      r1,[r0,r5,LSL #2]
;;;936    
;;;937      while (shdr_ptr != NULL) {
0000c6  e010              B        |L9.234|
                  |L9.200|
;;;938        small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
0000c8  683e              LDR      r6,[r7,#0]
;;;939        space_freed = shdr_ptr->hdr.bytes_used +
0000ca  e9d70101          LDRD     r0,r1,[r7,#4]
0000ce  4408              ADD      r0,r0,r1
0000d0  f1000b10          ADD      r11,r0,#0x10
;;;940    		  shdr_ptr->hdr.bytes_left +
;;;941    		  SIZEOF(small_pool_hdr);
;;;942        jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
0000d4  465a              MOV      r2,r11
0000d6  4639              MOV      r1,r7
0000d8  4650              MOV      r0,r10
0000da  f7fffffe          BL       jpeg_free_small
;;;943        mem->total_space_allocated -= space_freed;
0000de  6ce0              LDR      r0,[r4,#0x4c]
0000e0  eba0000b          SUB      r0,r0,r11
0000e4  64e0              STR      r0,[r4,#0x4c]
;;;944        shdr_ptr = next_shdr_ptr;
0000e6  4637              MOV      r7,r6
;;;945      }
0000e8  bf00              NOP      
                  |L9.234|
0000ea  2f00              CMP      r7,#0                 ;937
0000ec  d1ec              BNE      |L9.200|
;;;946    }
0000ee  e8bd9ff0          POP      {r4-r12,pc}
;;;947    
                          ENDP


                          AREA ||i.jinit_memory_mgr||, CODE, READONLY, ALIGN=2

                  jinit_memory_mgr PROC
;;;980    GLOBAL(void)
;;;981    jinit_memory_mgr (j_common_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;982    {
000004  4605              MOV      r5,r0
;;;983      my_mem_ptr mem;
;;;984      long max_to_use;
;;;985      int pool;
;;;986      size_t test_mac;
;;;987    
;;;988      cinfo->mem = NULL;		/* for safety if init fails */
000006  2000              MOVS     r0,#0
000008  6068              STR      r0,[r5,#4]
;;;989    
;;;990      /* Check for configuration errors.
;;;991       * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
;;;992       * doesn't reflect any real hardware alignment requirement.
;;;993       * The test is a little tricky: for X>0, X and X-1 have no one-bits
;;;994       * in common if and only if X is a power of 2, ie has only one one-bit.
;;;995       * Some compilers may give an "unreachable code" warning here; ignore it.
;;;996       */
;;;997      if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
;;;998        ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
;;;999      /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
;;;1000      * a multiple of SIZEOF(ALIGN_TYPE).
;;;1001      * Again, an "unreachable code" warning may be ignored here.
;;;1002      * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
;;;1003      */
;;;1004     test_mac = (size_t) MAX_ALLOC_CHUNK;
00000a  f8df80a4          LDR      r8,|L10.176|
;;;1005     if ((long) test_mac != MAX_ALLOC_CHUNK ||
00000e  4640              MOV      r0,r8
000010  4580              CMP      r8,r0
000012  d100              BNE      |L10.22|
;;;1006         (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
000014  e006              B        |L10.36|
                  |L10.22|
;;;1007       ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
000016  2003              MOVS     r0,#3
000018  6829              LDR      r1,[r5,#0]
00001a  6148              STR      r0,[r1,#0x14]
00001c  6828              LDR      r0,[r5,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  4628              MOV      r0,r5
000022  4788              BLX      r1
                  |L10.36|
;;;1008   
;;;1009     max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       jpeg_mem_init
00002a  4607              MOV      r7,r0
;;;1010   
;;;1011     /* Attempt to allocate memory manager's control block */
;;;1012     mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
00002c  2154              MOVS     r1,#0x54
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       jpeg_get_small
000034  4604              MOV      r4,r0
;;;1013   
;;;1014     if (mem == NULL) {
000036  b964              CBNZ     r4,|L10.82|
;;;1015       jpeg_mem_term(cinfo);	/* system-dependent cleanup */
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       jpeg_mem_term
;;;1016       ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
00003e  2036              MOVS     r0,#0x36
000040  6829              LDR      r1,[r5,#0]
000042  6148              STR      r0,[r1,#0x14]
000044  2000              MOVS     r0,#0
000046  6829              LDR      r1,[r5,#0]
000048  6188              STR      r0,[r1,#0x18]
00004a  6828              LDR      r0,[r5,#0]
00004c  6801              LDR      r1,[r0,#0]
00004e  4628              MOV      r0,r5
000050  4788              BLX      r1
                  |L10.82|
;;;1017     }
;;;1018   
;;;1019     /* OK, fill in the method pointers */
;;;1020     mem->pub.alloc_small = alloc_small;
000052  4818              LDR      r0,|L10.180|
000054  6020              STR      r0,[r4,#0]
;;;1021     mem->pub.alloc_large = alloc_large;
000056  4818              LDR      r0,|L10.184|
000058  6060              STR      r0,[r4,#4]
;;;1022     mem->pub.alloc_sarray = alloc_sarray;
00005a  4818              LDR      r0,|L10.188|
00005c  60a0              STR      r0,[r4,#8]
;;;1023     mem->pub.alloc_barray = alloc_barray;
00005e  4818              LDR      r0,|L10.192|
000060  60e0              STR      r0,[r4,#0xc]
;;;1024     mem->pub.request_virt_sarray = request_virt_sarray;
000062  4818              LDR      r0,|L10.196|
000064  6120              STR      r0,[r4,#0x10]
;;;1025     mem->pub.request_virt_barray = request_virt_barray;
000066  4818              LDR      r0,|L10.200|
000068  6160              STR      r0,[r4,#0x14]
;;;1026     mem->pub.realize_virt_arrays = realize_virt_arrays;
00006a  4818              LDR      r0,|L10.204|
00006c  61a0              STR      r0,[r4,#0x18]
;;;1027     mem->pub.access_virt_sarray = access_virt_sarray;
00006e  4818              LDR      r0,|L10.208|
000070  61e0              STR      r0,[r4,#0x1c]
;;;1028     mem->pub.access_virt_barray = access_virt_barray;
000072  4818              LDR      r0,|L10.212|
000074  6220              STR      r0,[r4,#0x20]
;;;1029     mem->pub.free_pool = free_pool;
000076  4818              LDR      r0,|L10.216|
000078  6260              STR      r0,[r4,#0x24]
;;;1030     mem->pub.self_destruct = self_destruct;
00007a  4818              LDR      r0,|L10.220|
00007c  62a0              STR      r0,[r4,#0x28]
;;;1031   
;;;1032     /* Make MAX_ALLOC_CHUNK accessible to other modules */
;;;1033     mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
00007e  480c              LDR      r0,|L10.176|
000080  6320              STR      r0,[r4,#0x30]
;;;1034   
;;;1035     /* Initialize working state */
;;;1036     mem->pub.max_memory_to_use = max_to_use;
000082  62e7              STR      r7,[r4,#0x2c]
;;;1037   
;;;1038     for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000084  2601              MOVS     r6,#1
000086  e008              B        |L10.154|
                  |L10.136|
;;;1039       mem->small_list[pool] = NULL;
000088  2100              MOVS     r1,#0
00008a  f1040034          ADD      r0,r4,#0x34
00008e  f8401026          STR      r1,[r0,r6,LSL #2]
;;;1040       mem->large_list[pool] = NULL;
000092  3008              ADDS     r0,r0,#8
000094  f8401026          STR      r1,[r0,r6,LSL #2]
000098  1e76              SUBS     r6,r6,#1              ;1038
                  |L10.154|
00009a  2e00              CMP      r6,#0                 ;1038
00009c  daf4              BGE      |L10.136|
;;;1041     }
;;;1042     mem->virt_sarray_list = NULL;
00009e  2000              MOVS     r0,#0
0000a0  6460              STR      r0,[r4,#0x44]
;;;1043     mem->virt_barray_list = NULL;
0000a2  64a0              STR      r0,[r4,#0x48]
;;;1044   
;;;1045     mem->total_space_allocated = SIZEOF(my_memory_mgr);
0000a4  2054              MOVS     r0,#0x54
0000a6  64e0              STR      r0,[r4,#0x4c]
;;;1046   
;;;1047     /* Declare ourselves open for business */
;;;1048     cinfo->mem = & mem->pub;
0000a8  606c              STR      r4,[r5,#4]
;;;1049   
;;;1050     /* Check for an environment variable JPEGMEM; if found, override the
;;;1051      * default max_memory setting from jpeg_mem_init.  Note that the
;;;1052      * surrounding application may again override this value.
;;;1053      * If your system doesn't support getenv(), define NO_GETENV to disable
;;;1054      * this feature.
;;;1055      */
;;;1056   #if 0 /* RS ndef NO_GETENV */
;;;1057     { char * memenv;
;;;1058   
;;;1059       if ((memenv = getenv("JPEGMEM")) != NULL) {
;;;1060         char ch = 'x';
;;;1061   
;;;1062         if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
;;;1063   	if (ch == 'm' || ch == 'M')
;;;1064   	  max_to_use *= 1000L;
;;;1065   	mem->pub.max_memory_to_use = max_to_use * 1000L;
;;;1066         }
;;;1067       }
;;;1068     }
;;;1069   #endif
;;;1070   
;;;1071   }
0000aa  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

0000ae  0000              DCW      0x0000
                  |L10.176|
                          DCD      0x3b9aca00
                  |L10.180|
                          DCD      alloc_small
                  |L10.184|
                          DCD      alloc_large
                  |L10.188|
                          DCD      alloc_sarray
                  |L10.192|
                          DCD      alloc_barray
                  |L10.196|
                          DCD      request_virt_sarray
                  |L10.200|
                          DCD      request_virt_barray
                  |L10.204|
                          DCD      realize_virt_arrays
                  |L10.208|
                          DCD      access_virt_sarray
                  |L10.212|
                          DCD      access_virt_barray
                  |L10.216|
                          DCD      free_pool
                  |L10.220|
                          DCD      self_destruct

                          AREA ||i.out_of_memory||, CODE, READONLY, ALIGN=1

                  out_of_memory PROC
;;;209    LOCAL(void)
;;;210    out_of_memory (j_common_ptr cinfo, int which)
000000  b570              PUSH     {r4-r6,lr}
;;;211    /* Report an out-of-memory error and stop execution */
;;;212    /* If we compiled MEM_STATS support, report alloc requests before dying */
;;;213    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;214    #ifdef MEM_STATS
;;;215      cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
;;;216    #endif
;;;217      ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
000006  2036              MOVS     r0,#0x36
000008  6821              LDR      r1,[r4,#0]
00000a  6148              STR      r0,[r1,#0x14]
00000c  6820              LDR      r0,[r4,#0]
00000e  6185              STR      r5,[r0,#0x18]
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;218    }
000018  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP


                          AREA ||i.realize_virt_arrays||, CODE, READONLY, ALIGN=1

                  realize_virt_arrays PROC
;;;549    
;;;550    METHODDEF(void) realize_virt_arrays (j_common_ptr cinfo) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;551    /* Allocate the in-memory buffers for any unrealized virtual arrays */
;;;552      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000006  f8d68004          LDR      r8,[r6,#4]
;;;553      long space_per_minheight, maximum_space/*, avail_mem*/;
;;;554    /*  long minheights, max_minheights;*/
;;;555      jvirt_sarray_ptr sptr;
;;;556      jvirt_barray_ptr bptr;
;;;557    
;;;558      /* Compute the minimum space needed (maxaccess rows in each buffer)
;;;559       * and the maximum space needed (full image height in each buffer).
;;;560       * These may be of use to the system-dependent jpeg_mem_available routine.
;;;561       */
;;;562      space_per_minheight = 0;
00000a  2700              MOVS     r7,#0
;;;563      maximum_space = 0;
00000c  46b9              MOV      r9,r7
;;;564      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
00000e  f8d85044          LDR      r5,[r8,#0x44]
000012  e00a              B        |L12.42|
                  |L12.20|
;;;565        if (sptr->mem_buffer == NULL) { /* if not realized yet */
000014  6828              LDR      r0,[r5,#0]
000016  b938              CBNZ     r0,|L12.40|
;;;566          space_per_minheight += (long) sptr->maxaccess *
000018  e9d51002          LDRD     r1,r0,[r5,#8]
00001c  fb007701          MLA      r7,r0,r1,r7
;;;567    			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;568          maximum_space += (long) sptr->rows_in_array *
000020  e9d50101          LDRD     r0,r1,[r5,#4]
000024  fb009901          MLA      r9,r0,r1,r9
                  |L12.40|
000028  6aed              LDR      r5,[r5,#0x2c]         ;564
                  |L12.42|
00002a  2d00              CMP      r5,#0                 ;564
00002c  d1f2              BNE      |L12.20|
;;;569    		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;570        }
;;;571      }
;;;572      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
00002e  f8d84048          LDR      r4,[r8,#0x48]
000032  e00c              B        |L12.78|
                  |L12.52|
;;;573        if (bptr->mem_buffer == NULL) { /* if not realized yet */
000034  6820              LDR      r0,[r4,#0]
000036  b948              CBNZ     r0,|L12.76|
;;;574          space_per_minheight += (long) bptr->maxaccess *
000038  e9d41002          LDRD     r1,r0,[r4,#8]
00003c  4348              MULS     r0,r1,r0
00003e  eb0717c0          ADD      r7,r7,r0,LSL #7
;;;575    			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;576          maximum_space += (long) bptr->rows_in_array *
000042  e9d40101          LDRD     r0,r1,[r4,#4]
000046  4348              MULS     r0,r1,r0
000048  eb0919c0          ADD      r9,r9,r0,LSL #7
                  |L12.76|
00004c  6ae4              LDR      r4,[r4,#0x2c]         ;572
                  |L12.78|
00004e  2c00              CMP      r4,#0                 ;572
000050  d1f0              BNE      |L12.52|
;;;577    		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;578        }
;;;579      }
;;;580    
;;;581      if (space_per_minheight <= 0)
000052  2f00              CMP      r7,#0
000054  dc01              BGT      |L12.90|
                  |L12.86|
;;;582        return;			/* no unrealized arrays, no work */
;;;583    
;;;584    #if 0  /*RS*/
;;;585      /* Determine amount of memory to actually use; this is system-dependent. */
;;;586      avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
;;;587    
;;;588      /* If the maximum space needed is available, make all the buffers full
;;;589       * height; otherwise parcel it out with the same number of minheights
;;;590       * in each buffer.
;;;591       */
;;;592      if (avail_mem >= maximum_space)
;;;593        max_minheights = 1000000000L;
;;;594      else {
;;;595        max_minheights = avail_mem / space_per_minheight;
;;;596        /* If there doesn't seem to be enough space, try to get the minimum
;;;597         * anyway.  This allows a "stub" implementation of jpeg_mem_available().
;;;598         */
;;;599        if (max_minheights <= 0)
;;;600          max_minheights = 1;
;;;601      }
;;;602    
;;;603      /* Allocate the in-memory buffers and initialize backing store as needed. */
;;;604      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
;;;605        if (sptr->mem_buffer == NULL) { /* if not realized yet */
;;;606          minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
;;;607          if (minheights <= max_minheights) {
;;;608    	/* This buffer fits in memory */
;;;609    	sptr->rows_in_mem = sptr->rows_in_array;
;;;610          } else {
;;;611    	/* It doesn't fit in memory, create backing store. */
;;;612    	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
;;;613    	jpeg_open_backing_store(cinfo, & sptr->b_s_info, (long) sptr->rows_in_array * (long) sptr->samplesperrow * (long) SIZEOF(JSAMPLE));
;;;614    	sptr->b_s_open = TRUE;
;;;615          }
;;;616          sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
;;;617    				      sptr->samplesperrow, sptr->rows_in_mem);
;;;618          sptr->rowsperchunk = mem->last_rowsperchunk;
;;;619          sptr->cur_start_row = 0;
;;;620          sptr->first_undef_row = 0;
;;;621          sptr->dirty = FALSE;
;;;622        }
;;;623      }
;;;624    
;;;625      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
;;;626        if (bptr->mem_buffer == NULL) { /* if not realized yet */
;;;627          minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
;;;628          if (minheights <= max_minheights) {
;;;629    	/* This buffer fits in memory */
;;;630    	bptr->rows_in_mem = bptr->rows_in_array;
;;;631          } else {
;;;632    	/* It doesn't fit in memory, create backing store. */
;;;633    	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
;;;634    	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
;;;635    				(long) bptr->rows_in_array *
;;;636    				(long) bptr->blocksperrow *
;;;637    				(long) SIZEOF(JBLOCK));
;;;638    	bptr->b_s_open = TRUE;
;;;639          }
;;;640          bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
;;;641    				      bptr->blocksperrow, bptr->rows_in_mem);
;;;642          bptr->rowsperchunk = mem->last_rowsperchunk;
;;;643          bptr->cur_start_row = 0;
;;;644          bptr->first_undef_row = 0;
;;;645          bptr->dirty = FALSE;
;;;646        }
;;;647      }
;;;648    # else
;;;649      ERREXIT(cinfo, JERR_NO_BACKING_STORE);
;;;650    #endif
;;;651    }
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L12.90|
00005a  2031              MOVS     r0,#0x31              ;649
00005c  6831              LDR      r1,[r6,#0]            ;649
00005e  6148              STR      r0,[r1,#0x14]         ;649
000060  6830              LDR      r0,[r6,#0]            ;649
000062  6801              LDR      r1,[r0,#0]            ;649
000064  4630              MOV      r0,r6                 ;649
000066  4788              BLX      r1                    ;649
000068  bf00              NOP      
00006a  e7f4              B        |L12.86|
;;;652    
                          ENDP


                          AREA ||i.request_virt_barray||, CODE, READONLY, ALIGN=1

                  request_virt_barray PROC
;;;526    
;;;527    METHODDEF(jvirt_barray_ptr) request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;528      /* Request a virtual 2-D coefficient-block array */
;;;529      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000010  f8d59004          LDR      r9,[r5,#4]
;;;530      jvirt_barray_ptr result;
;;;531      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;532      if (pool_id != JPOOL_IMAGE)
000014  2e01              CMP      r6,#1
000016  d008              BEQ      |L13.42|
;;;533        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000018  200e              MOVS     r0,#0xe
00001a  6829              LDR      r1,[r5,#0]
00001c  6148              STR      r0,[r1,#0x14]
00001e  6828              LDR      r0,[r5,#0]
000020  6186              STR      r6,[r0,#0x18]
000022  6828              LDR      r0,[r5,#0]
000024  6801              LDR      r1,[r0,#0]
000026  4628              MOV      r0,r5
000028  4788              BLX      r1
                  |L13.42|
;;;534    
;;;535      /* get control block */
;;;536      result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_barray_control));
00002a  227c              MOVS     r2,#0x7c
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       alloc_small
000034  4604              MOV      r4,r0
;;;537      result->mem_buffer = NULL;	/* marks array not yet realized */
000036  2100              MOVS     r1,#0
000038  6021              STR      r1,[r4,#0]
;;;538      result->rows_in_array = numrows;
00003a  f8c4a004          STR      r10,[r4,#4]
;;;539      result->blocksperrow = blocksperrow;
00003e  f8c48008          STR      r8,[r4,#8]
;;;540      result->maxaccess = maxaccess;
000042  f8c4b00c          STR      r11,[r4,#0xc]
;;;541      result->pre_zero = pre_zero;
000046  6227              STR      r7,[r4,#0x20]
;;;542      result->b_s_open = FALSE;	/* no associated backing-store object */
000048  62a1              STR      r1,[r4,#0x28]
;;;543      result->next = mem->virt_barray_list; /* add to list of virtual arrays */
00004a  f8d91048          LDR      r1,[r9,#0x48]
00004e  62e1              STR      r1,[r4,#0x2c]
;;;544      mem->virt_barray_list = result;
000050  f8c94048          STR      r4,[r9,#0x48]
;;;545    
;;;546      return result;
000054  4620              MOV      r0,r4
;;;547    }
000056  e8bd9ff0          POP      {r4-r12,pc}
;;;548    
                          ENDP


                          AREA ||i.request_virt_sarray||, CODE, READONLY, ALIGN=1

                  request_virt_sarray PROC
;;;502    
;;;503    METHODDEF(jvirt_sarray_ptr) request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;504      /* Request a virtual 2-D sample array */
;;;505      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000010  f8d59004          LDR      r9,[r5,#4]
;;;506      jvirt_sarray_ptr result;
;;;507    
;;;508      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;509      if (pool_id != JPOOL_IMAGE) {
000014  2e01              CMP      r6,#1
000016  d008              BEQ      |L14.42|
;;;510        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000018  200e              MOVS     r0,#0xe
00001a  6829              LDR      r1,[r5,#0]
00001c  6148              STR      r0,[r1,#0x14]
00001e  6828              LDR      r0,[r5,#0]
000020  6186              STR      r6,[r0,#0x18]
000022  6828              LDR      r0,[r5,#0]
000024  6801              LDR      r1,[r0,#0]
000026  4628              MOV      r0,r5
000028  4788              BLX      r1
                  |L14.42|
;;;511      }
;;;512      /* get control block */
;;;513      result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_sarray_control));
00002a  227c              MOVS     r2,#0x7c
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       alloc_small
000034  4604              MOV      r4,r0
;;;514      result->mem_buffer = NULL;	/* marks array not yet realized */
000036  2100              MOVS     r1,#0
000038  6021              STR      r1,[r4,#0]
;;;515      result->rows_in_array = numrows;
00003a  f8c4a004          STR      r10,[r4,#4]
;;;516      result->samplesperrow = samplesperrow;
00003e  f8c48008          STR      r8,[r4,#8]
;;;517      result->maxaccess = maxaccess;
000042  f8c4b00c          STR      r11,[r4,#0xc]
;;;518      result->pre_zero = pre_zero;
000046  6227              STR      r7,[r4,#0x20]
;;;519      result->b_s_open = FALSE;	/* no associated backing-store object */
000048  62a1              STR      r1,[r4,#0x28]
;;;520      result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
00004a  f8d91044          LDR      r1,[r9,#0x44]
00004e  62e1              STR      r1,[r4,#0x2c]
;;;521      mem->virt_sarray_list = result;
000050  f8c94044          STR      r4,[r9,#0x44]
;;;522    
;;;523      return result;
000054  4620              MOV      r0,r4
;;;524    }
000056  e8bd9ff0          POP      {r4-r12,pc}
;;;525    
                          ENDP


                          AREA ||i.self_destruct||, CODE, READONLY, ALIGN=1

                  self_destruct PROC
;;;954    METHODDEF(void)
;;;955    self_destruct (j_common_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;956    {
000002  4604              MOV      r4,r0
;;;957      int pool;
;;;958    
;;;959      /* Close all backing store, release all memory.
;;;960       * Releasing pools in reverse order might help avoid fragmentation
;;;961       * with some (brain-damaged) malloc libraries.
;;;962       */
;;;963      for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000004  2501              MOVS     r5,#1
000006  e004              B        |L15.18|
                  |L15.8|
;;;964        free_pool(cinfo, pool);
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       free_pool
000010  1e6d              SUBS     r5,r5,#1              ;963
                  |L15.18|
000012  2d00              CMP      r5,#0                 ;963
000014  daf8              BGE      |L15.8|
;;;965      }
;;;966    
;;;967      /* Release the memory manager control block too. */
;;;968      jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
000016  2254              MOVS     r2,#0x54
000018  4620              MOV      r0,r4
00001a  6861              LDR      r1,[r4,#4]
00001c  f7fffffe          BL       jpeg_free_small
;;;969      cinfo->mem = NULL;		/* ensures I will be called only once */
000020  2000              MOVS     r0,#0
000022  6060              STR      r0,[r4,#4]
;;;970    
;;;971      jpeg_mem_term(cinfo);		/* system-dependent cleanup */
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       jpeg_mem_term
;;;972    }
00002a  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  first_pool_slop
                          DCD      0x00000640
                          DCD      0x00003e80
                  extra_pool_slop
                          DCD      0x00000000
                          DCD      0x00001388
