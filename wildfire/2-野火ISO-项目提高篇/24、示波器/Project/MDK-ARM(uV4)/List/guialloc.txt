; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\guialloc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\guialloc.crf ..\..\uCGUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||i.GUI_ALLOC_AllocNoInit||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_AllocNoInit PROC
;;;356    */
;;;357    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;358      GUI_HMEM hMem;
;;;359      if (Size == 0) {
000004  b90c              CBNZ     r4,|L1.10|
;;;360        return (GUI_HMEM)0;
000006  2000              MOVS     r0,#0
                  |L1.8|
;;;361      }
;;;362      GUI_LOCK();
;;;363      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;364      hMem = _Alloc(Size);
;;;365      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;366      GUI_UNLOCK();
;;;367      return hMem;
;;;368    }
000008  bd70              POP      {r4-r6,pc}
                  |L1.10|
00000a  f7fffffe          BL       GUI_Lock
00000e  4620              MOV      r0,r4                 ;364
000010  f7fffffe          BL       _Alloc
000014  4605              MOV      r5,r0                 ;364
000016  f7fffffe          BL       GUI_Unlock
00001a  4628              MOV      r0,r5                 ;367
00001c  e7f4              B        |L1.8|
;;;369    
                          ENDP


                          AREA ||i.GUI_ALLOC_Free||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_Free PROC
;;;608    */
;;;609    void GUI_ALLOC_Free(GUI_HMEM hMem) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;610      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
000004  b904              CBNZ     r4,|L2.8|
                  |L2.6|
;;;611        return;
;;;612      }
;;;613      GUI_LOCK();
;;;614      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;615      _Free(hMem);
;;;616      GUI_UNLOCK();
;;;617    }
000006  bd10              POP      {r4,pc}
                  |L2.8|
000008  f7fffffe          BL       GUI_Lock
00000c  4620              MOV      r0,r4                 ;615
00000e  f7fffffe          BL       _Free
000012  f7fffffe          BL       GUI_Unlock
000016  bf00              NOP      
000018  e7f5              B        |L2.6|
;;;618    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtr||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_FreePtr PROC
;;;623    */
;;;624    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;625      GUI_LOCK();
000004  f7fffffe          BL       GUI_Lock
;;;626      GUI_ALLOC_Free(*ph);
000008  f9b40000          LDRSH    r0,[r4,#0]
00000c  f7fffffe          BL       GUI_ALLOC_Free
;;;627      *ph =0;
000010  2000              MOVS     r0,#0
000012  8020              STRH     r0,[r4,#0]
;;;628      GUI_UNLOCK();
000014  f7fffffe          BL       GUI_Unlock
;;;629    }
000018  bd10              POP      {r4,pc}
;;;630    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtrArray||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_FreePtrArray PROC
;;;634    */
;;;635    void GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;636      int i;
;;;637      for (i = 0; i < NumElems; i++) {
000006  2400              MOVS     r4,#0
000008  e004              B        |L4.20|
                  |L4.10|
;;;638        GUI_ALLOC_FreePtr(&pArray[i]);
00000a  eb050044          ADD      r0,r5,r4,LSL #1
00000e  f7fffffe          BL       GUI_ALLOC_FreePtr
000012  1c64              ADDS     r4,r4,#1              ;637
                  |L4.20|
000014  42b4              CMP      r4,r6                 ;637
000016  dbf8              BLT      |L4.10|
;;;639      }
;;;640    }
000018  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP


                          AREA ||i.GUI_ALLOC_GetMaxSize||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetMaxSize PROC
;;;431    */
;;;432    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;433      GUI_ALLOC_DATATYPE r = 0;
000004  2600              MOVS     r6,#0
;;;434      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;435      int i, iNext;
;;;436    
;;;437      GUI_LOCK();
000006  f7fffffe          BL       GUI_Lock
;;;438      _CheckInit();
00000a  f7fffffe          BL       _CheckInit
;;;439      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00000e  2500              MOVS     r5,#0
000010  e015              B        |L5.62|
                  |L5.18|
;;;440        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000012  eb050045          ADD      r0,r5,r5,LSL #1
000016  4919              LDR      r1,|L5.124|
000018  f8310010          LDRH     r0,[r1,r0,LSL #1]
00001c  eb050145          ADD      r1,r5,r5,LSL #1
000020  4a16              LDR      r2,|L5.124|
000022  eb020141          ADD      r1,r2,r1,LSL #1
000026  8849              LDRH     r1,[r1,#2]
000028  4408              ADD      r0,r0,r1
00002a  eb070147          ADD      r1,r7,r7,LSL #1
00002e  f8321011          LDRH     r1,[r2,r1,LSL #1]
000032  1a08              SUBS     r0,r1,r0
000034  b204              SXTH     r4,r0
;;;441        if (NumFreeBytes > r) {
000036  42b4              CMP      r4,r6
000038  dd00              BLE      |L5.60|
;;;442          r = NumFreeBytes;
00003a  4626              MOV      r6,r4
                  |L5.60|
00003c  463d              MOV      r5,r7                 ;439
                  |L5.62|
00003e  eb050045          ADD      r0,r5,r5,LSL #1       ;439
000042  490e              LDR      r1,|L5.124|
000044  eb010040          ADD      r0,r1,r0,LSL #1       ;439
000048  7907              LDRB     r7,[r0,#4]            ;439
00004a  2f00              CMP      r7,#0                 ;439
00004c  d1e1              BNE      |L5.18|
;;;443        }
;;;444      }
;;;445      /* Check last block */
;;;446      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
00004e  eb050045          ADD      r0,r5,r5,LSL #1
000052  f8310010          LDRH     r0,[r1,r0,LSL #1]
000056  eb050145          ADD      r1,r5,r5,LSL #1
00005a  4a08              LDR      r2,|L5.124|
00005c  eb020141          ADD      r1,r2,r1,LSL #1
000060  8849              LDRH     r1,[r1,#2]
000062  4408              ADD      r0,r0,r1
000064  f2413188          MOV      r1,#0x1388
000068  1a08              SUBS     r0,r1,r0
00006a  b204              SXTH     r4,r0
;;;447      if (NumFreeBytes > r) {
00006c  42b4              CMP      r4,r6
00006e  dd00              BLE      |L5.114|
;;;448        r = NumFreeBytes;
000070  4626              MOV      r6,r4
                  |L5.114|
;;;449      }
;;;450      GUI_UNLOCK();
000072  f7fffffe          BL       GUI_Unlock
;;;451      return r;
000076  4630              MOV      r0,r6
;;;452    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;453    
                          ENDP

                  |L5.124|
                          DCD      aBlock

                          AREA ||i.GUI_ALLOC_GetNumFreeBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBlocks PROC
;;;401    */
;;;402    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;403      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;404      return GUI_ALLOC.NumFreeBlocks;
000006  4802              LDR      r0,|L6.16|
000008  8880              LDRH     r0,[r0,#4]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;405    }
00000c  bd10              POP      {r4,pc}
;;;406    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumFreeBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;392    */
;;;393    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;394      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;395      return GUI_ALLOC.NumFreeBytes;
000006  4802              LDR      r0,|L7.16|
000008  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;396    }
00000c  bd10              POP      {r4,pc}
;;;397    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumUsedBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBlocks PROC
;;;419    */
;;;420    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;421      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;422      return GUI_ALLOC.NumUsedBlocks;
000006  4802              LDR      r0,|L8.16|
000008  8800              LDRH     r0,[r0,#0]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;423    }
00000c  bd10              POP      {r4,pc}
;;;424    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumUsedBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBytes PROC
;;;410    */
;;;411    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;412      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;413      return GUI_ALLOC.NumUsedBytes;
000006  4802              LDR      r0,|L9.16|
000008  f9b0000c          LDRSH    r0,[r0,#0xc]  ; GUI_ALLOC
;;;414    }
00000c  bd10              POP      {r4,pc}
;;;415    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetSize||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_GetSize PROC
;;;594    */
;;;595    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;596      GUI_ALLOC_DATATYPE r;
;;;597    
;;;598      r = 0;
000004  2500              MOVS     r5,#0
;;;599      if (hMem) {
000006  b11c              CBZ      r4,|L10.16|
;;;600        r = _GetSize(hMem);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _GetSize
00000e  4605              MOV      r5,r0
                  |L10.16|
;;;601      }
;;;602      return r;
000010  4628              MOV      r0,r5
;;;603    }
000012  bd70              POP      {r4-r6,pc}
;;;604    
                          ENDP


                          AREA ||i.GUI_ALLOC_Init||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Init PROC
;;;340    */
;;;341    void GUI_ALLOC_Init(void) {
000000  209d              MOVS     r0,#0x9d
;;;342      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;343      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
000002  490a              LDR      r1,|L11.44|
000004  6048              STR      r0,[r1,#4]  ; GUI_ALLOC
000006  6088              STR      r0,[r1,#8]  ; GUI_ALLOC
;;;344      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
000008  f2413088          MOV      r0,#0x1388
00000c  81c8              STRH     r0,[r1,#0xe]
00000e  8208              STRH     r0,[r1,#0x10]
;;;345      GUI_ALLOC.NumUsedBlocks = 0;
000010  2000              MOVS     r0,#0
000012  6008              STR      r0,[r1,#0]  ; GUI_ALLOC
;;;346      GUI_ALLOC.NumUsedBytes = 0;
000014  8188              STRH     r0,[r1,#0xc]
;;;347      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
000016  2004              MOVS     r0,#4
000018  4905              LDR      r1,|L11.48|
00001a  8048              STRH     r0,[r1,#2]
;;;348      aBlock[0].Off  = 0;
00001c  2000              MOVS     r0,#0
00001e  8008              STRH     r0,[r1,#0]
;;;349      aBlock[0].Next = 0;
000020  7108              STRB     r0,[r1,#4]
;;;350      IsInitialized =1;
000022  2001              MOVS     r0,#1
000024  4903              LDR      r1,|L11.52|
000026  7008              STRB     r0,[r1,#0]
;;;351    }
000028  4770              BX       lr
;;;352    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      GUI_ALLOC
                  |L11.48|
                          DCD      aBlock
                  |L11.52|
                          DCD      IsInitialized

                          AREA ||i.GUI_ALLOC_Lock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Lock PROC
;;;461    */
;;;462    void GUI_ALLOC_Lock(void) {
000000  4802              LDR      r0,|L12.12|
;;;463      _LockCnt++;
000002  6800              LDR      r0,[r0,#0]  ; _LockCnt
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L12.12|
000008  6008              STR      r0,[r1,#0]  ; _LockCnt
;;;464    }
00000a  4770              BX       lr
;;;465    
                          ENDP

                  |L12.12|
                          DCD      _LockCnt

                          AREA ||i.GUI_ALLOC_Unlock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Unlock PROC
;;;473    */
;;;474    void GUI_ALLOC_Unlock(void) {
000000  4802              LDR      r0,|L13.12|
;;;475      _LockCnt--;
000002  6800              LDR      r0,[r0,#0]  ; _LockCnt
000004  1e40              SUBS     r0,r0,#1
000006  4901              LDR      r1,|L13.12|
000008  6008              STR      r0,[r1,#0]  ; _LockCnt
;;;476    }
00000a  4770              BX       lr
;;;477    
                          ENDP

                  |L13.12|
                          DCD      _LockCnt

                          AREA ||i.GUI_ALLOC_h2p||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_h2p PROC
;;;373    */
;;;374    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
000000  4601              MOV      r1,r0
;;;375      GUI_ASSERT_LOCK();
;;;376      #if GUI_DEBUG_LEVEL > 0
;;;377        if (!hMem) {
000002  b909              CBNZ     r1,|L14.8|
;;;378          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;379          return 0;
000004  2000              MOVS     r0,#0
                  |L14.6|
;;;380        }
;;;381        if (aBlock[hMem].Size == 0) {
;;;382          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;383        }
;;;384    
;;;385      #endif
;;;386      return HMEM2PTR(hMem);
;;;387    }
000006  4770              BX       lr
                  |L14.8|
000008  eb010041          ADD      r0,r1,r1,LSL #1       ;386
00000c  4a02              LDR      r2,|L14.24|
00000e  f9320010          LDRSH    r0,[r2,r0,LSL #1]     ;386
000012  4a02              LDR      r2,|L14.28|
000014  4410              ADD      r0,r0,r2              ;386
000016  e7f6              B        |L14.6|
;;;388    
                          ENDP

                  |L14.24|
                          DCD      aBlock
                  |L14.28|
                          DCD      GUI_Heap

                          AREA ||i._Alloc||, CODE, READONLY, ALIGN=2

                  _Alloc PROC
;;;278    */
;;;279    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;280      GUI_HMEM hMemNew, hMemIns;
;;;281      _CheckInit();
000006  f7fffffe          BL       _CheckInit
;;;282      size = _Size2LegalSize(size);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       _Size2LegalSize
000010  4606              MOV      r6,r0
;;;283      /* Check if memory is available at all ...*/
;;;284      if (size > _GetNumFreeBytes()) {
000012  f7fffffe          BL       _GetNumFreeBytes
000016  42b0              CMP      r0,r6
000018  da02              BGE      |L15.32|
;;;285        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;286        return 0;
00001a  2000              MOVS     r0,#0
                  |L15.28|
;;;287      }
;;;288      /* Locate free handle */
;;;289      if ((hMemNew = _FindFreeHandle()) == 0) {
;;;290        return 0;
;;;291      }
;;;292      /* Locate or Create hole of sufficient size */
;;;293      hMemIns = _FindHole(size);
;;;294      #if GUI_ALLOC_AUTDEFRAG
;;;295        if (hMemIns == -1) {
;;;296          if (_LockCnt == 0) {
;;;297            hMemIns = _CreateHole(size);
;;;298          }
;;;299        }
;;;300      #endif
;;;301      /* Occupy hole */
;;;302      if (hMemIns==-1) {
;;;303        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;304        return 0;
;;;305    	}
;;;306      {
;;;307        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
;;;308        int Next = aBlock[hMemIns].Next;
;;;309        aBlock[hMemNew].Size  = size;
;;;310        aBlock[hMemNew].Off   = Off;
;;;311        if ((aBlock[hMemNew].Next  = Next) >0) {
;;;312          aBlock[Next].Prev = hMemNew;  
;;;313        }
;;;314        aBlock[hMemNew].Prev  = hMemIns;
;;;315        aBlock[hMemIns].Next  = hMemNew;
;;;316      }
;;;317      /* Keep track of number of blocks and av. memory */
;;;318      GUI_ALLOC.NumUsedBlocks++;
;;;319      GUI_ALLOC.NumFreeBlocks--;
;;;320      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
;;;321        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
;;;322      }
;;;323      GUI_ALLOC.NumUsedBytes += size;
;;;324      GUI_ALLOC.NumFreeBytes -= size;
;;;325      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
;;;326        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
;;;327      }
;;;328      return hMemNew;
;;;329    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L15.32|
000020  f7fffffe          BL       _FindFreeHandle
000024  0005              MOVS     r5,r0                 ;289
000026  d100              BNE      |L15.42|
000028  e7f8              B        |L15.28|
                  |L15.42|
00002a  4630              MOV      r0,r6                 ;293
00002c  f7fffffe          BL       _FindHole
000030  4604              MOV      r4,r0                 ;293
000032  1c60              ADDS     r0,r4,#1              ;295
000034  d106              BNE      |L15.68|
000036  4833              LDR      r0,|L15.260|
000038  6800              LDR      r0,[r0,#0]            ;296  ; _LockCnt
00003a  b918              CBNZ     r0,|L15.68|
00003c  4630              MOV      r0,r6                 ;297
00003e  f7fffffe          BL       _CreateHole
000042  4604              MOV      r4,r0                 ;297
                  |L15.68|
000044  1c60              ADDS     r0,r4,#1              ;302
000046  d100              BNE      |L15.74|
000048  e7e8              B        |L15.28|
                  |L15.74|
00004a  eb040244          ADD      r2,r4,r4,LSL #1       ;307
00004e  4b2e              LDR      r3,|L15.264|
000050  f8332012          LDRH     r2,[r3,r2,LSL #1]     ;307
000054  eb040344          ADD      r3,r4,r4,LSL #1       ;307
000058  4f2b              LDR      r7,|L15.264|
00005a  eb070343          ADD      r3,r7,r3,LSL #1       ;307
00005e  885b              LDRH     r3,[r3,#2]            ;307
000060  441a              ADD      r2,r2,r3              ;307
000062  b211              SXTH     r1,r2                 ;307
000064  eb040244          ADD      r2,r4,r4,LSL #1       ;308
000068  463b              MOV      r3,r7                 ;308
00006a  eb030242          ADD      r2,r3,r2,LSL #1       ;308
00006e  7910              LDRB     r0,[r2,#4]            ;308
000070  eb050245          ADD      r2,r5,r5,LSL #1       ;309
000074  eb030242          ADD      r2,r3,r2,LSL #1       ;309
000078  8056              STRH     r6,[r2,#2]            ;309
00007a  eb050245          ADD      r2,r5,r5,LSL #1       ;310
00007e  f8231012          STRH     r1,[r3,r2,LSL #1]     ;310
000082  eb050245          ADD      r2,r5,r5,LSL #1       ;311
000086  eb030242          ADD      r2,r3,r2,LSL #1       ;311
00008a  7110              STRB     r0,[r2,#4]            ;311
00008c  2800              CMP      r0,#0                 ;311
00008e  dd04              BLE      |L15.154|
000090  eb000340          ADD      r3,r0,r0,LSL #1       ;312
000094  eb070343          ADD      r3,r7,r3,LSL #1       ;312
000098  715d              STRB     r5,[r3,#5]            ;312
                  |L15.154|
00009a  eb050345          ADD      r3,r5,r5,LSL #1       ;314
00009e  4f1a              LDR      r7,|L15.264|
0000a0  eb070343          ADD      r3,r7,r3,LSL #1       ;314
0000a4  715c              STRB     r4,[r3,#5]            ;314
0000a6  eb040344          ADD      r3,r4,r4,LSL #1       ;315
0000aa  eb070343          ADD      r3,r7,r3,LSL #1       ;315
0000ae  711d              STRB     r5,[r3,#4]            ;315
0000b0  4816              LDR      r0,|L15.268|
0000b2  6800              LDR      r0,[r0,#0]            ;318  ; GUI_ALLOC
0000b4  1c40              ADDS     r0,r0,#1              ;318
0000b6  4915              LDR      r1,|L15.268|
0000b8  6008              STR      r0,[r1,#0]            ;318  ; GUI_ALLOC
0000ba  4608              MOV      r0,r1                 ;319
0000bc  6840              LDR      r0,[r0,#4]            ;319  ; GUI_ALLOC
0000be  1e40              SUBS     r0,r0,#1              ;319
0000c0  6048              STR      r0,[r1,#4]            ;319  ; GUI_ALLOC
0000c2  4608              MOV      r0,r1                 ;320
0000c4  6880              LDR      r0,[r0,#8]            ;320  ; GUI_ALLOC
0000c6  6849              LDR      r1,[r1,#4]            ;320  ; GUI_ALLOC
0000c8  4288              CMP      r0,r1                 ;320
0000ca  dd03              BLE      |L15.212|
0000cc  480f              LDR      r0,|L15.268|
0000ce  6840              LDR      r0,[r0,#4]            ;321  ; GUI_ALLOC
0000d0  490e              LDR      r1,|L15.268|
0000d2  6088              STR      r0,[r1,#8]            ;321  ; GUI_ALLOC
                  |L15.212|
0000d4  480d              LDR      r0,|L15.268|
0000d6  8980              LDRH     r0,[r0,#0xc]          ;323  ; GUI_ALLOC
0000d8  4430              ADD      r0,r0,r6              ;323
0000da  b200              SXTH     r0,r0                 ;323
0000dc  490b              LDR      r1,|L15.268|
0000de  8188              STRH     r0,[r1,#0xc]          ;323
0000e0  4608              MOV      r0,r1                 ;324
0000e2  89c0              LDRH     r0,[r0,#0xe]          ;324  ; GUI_ALLOC
0000e4  1b80              SUBS     r0,r0,r6              ;324
0000e6  b200              SXTH     r0,r0                 ;324
0000e8  81c8              STRH     r0,[r1,#0xe]          ;324
0000ea  4608              MOV      r0,r1                 ;325
0000ec  f9b00010          LDRSH    r0,[r0,#0x10]         ;325  ; GUI_ALLOC
0000f0  f9b1100e          LDRSH    r1,[r1,#0xe]          ;325  ; GUI_ALLOC
0000f4  4288              CMP      r0,r1                 ;325
0000f6  dd03              BLE      |L15.256|
0000f8  4804              LDR      r0,|L15.268|
0000fa  89c0              LDRH     r0,[r0,#0xe]          ;326  ; GUI_ALLOC
0000fc  4903              LDR      r1,|L15.268|
0000fe  8208              STRH     r0,[r1,#0x10]         ;326
                  |L15.256|
000100  4628              MOV      r0,r5                 ;328
000102  e78b              B        |L15.28|
;;;330    
                          ENDP

                  |L15.260|
                          DCD      _LockCnt
                  |L15.264|
                          DCD      aBlock
                  |L15.268|
                          DCD      GUI_ALLOC

                          AREA ||i._CheckInit||, CODE, READONLY, ALIGN=2

                  _CheckInit PROC
;;;256    */
;;;257    static void _CheckInit(void) {
000000  b500              PUSH     {lr}
;;;258      if (!IsInitialized) {
000002  4803              LDR      r0,|L16.16|
000004  7800              LDRB     r0,[r0,#0]  ; IsInitialized
000006  b908              CBNZ     r0,|L16.12|
;;;259        GUI_ALLOC_Init();
000008  f7fffffe          BL       GUI_ALLOC_Init
                  |L16.12|
;;;260      }
;;;261    }
00000c  bd00              POP      {pc}
;;;262    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      IsInitialized

                          AREA ||i._CreateHole||, CODE, READONLY, ALIGN=2

                  _CreateHole PROC
;;;231    */
;;;232    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;233      int i, iNext;
;;;234      int r = -1;
000006  f04f39ff          MOV      r9,#0xffffffff
;;;235      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00000a  2400              MOVS     r4,#0
00000c  e049              B        |L17.162|
                  |L17.14|
;;;236        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00000e  eb040044          ADD      r0,r4,r4,LSL #1
000012  4933              LDR      r1,|L17.224|
000014  f8310010          LDRH     r0,[r1,r0,LSL #1]
000018  eb040144          ADD      r1,r4,r4,LSL #1
00001c  4a30              LDR      r2,|L17.224|
00001e  eb020141          ADD      r1,r2,r1,LSL #1
000022  8849              LDRH     r1,[r1,#2]
000024  4408              ADD      r0,r0,r1
000026  eb050145          ADD      r1,r5,r5,LSL #1
00002a  f8321011          LDRH     r1,[r2,r1,LSL #1]
00002e  1a08              SUBS     r0,r1,r0
000030  fa0ffa80          SXTH     r10,r0
;;;237        if (NumFreeBytes < Size) {
000034  45b2              CMP      r10,r6
000036  da33              BGE      |L17.160|
;;;238          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
000038  eb040044          ADD      r0,r4,r4,LSL #1
00003c  4611              MOV      r1,r2
00003e  f8310010          LDRH     r0,[r1,r0,LSL #1]
000042  eb040144          ADD      r1,r4,r4,LSL #1
000046  eb020141          ADD      r1,r2,r1,LSL #1
00004a  8849              LDRH     r1,[r1,#2]
00004c  4408              ADD      r0,r0,r1
00004e  eb050145          ADD      r1,r5,r5,LSL #1
000052  f8321011          LDRH     r1,[r2,r1,LSL #1]
000056  1a08              SUBS     r0,r1,r0
000058  b207              SXTH     r7,r0
;;;239          if (NumBytesBeforeBlock) {
00005a  b307              CBZ      r7,|L17.158|
;;;240            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
00005c  eb050045          ADD      r0,r5,r5,LSL #1
000060  4611              MOV      r1,r2
000062  f9310010          LDRSH    r0,[r1,r0,LSL #1]
000066  491f              LDR      r1,|L17.228|
000068  eb000801          ADD      r8,r0,r1
;;;241            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
00006c  eb050145          ADD      r1,r5,r5,LSL #1
000070  4613              MOV      r3,r2
000072  eb030141          ADD      r1,r3,r1,LSL #1
000076  f9b12002          LDRSH    r2,[r1,#2]
00007a  eba80007          SUB      r0,r8,r7
00007e  4641              MOV      r1,r8
000080  f7fffffe          BL       __aeabi_memmove
;;;242            aBlock[iNext].Off -=NumBytesBeforeBlock;
000084  eb050045          ADD      r0,r5,r5,LSL #1
000088  4915              LDR      r1,|L17.224|
00008a  f8310010          LDRH     r0,[r1,r0,LSL #1]
00008e  1bc0              SUBS     r0,r0,r7
000090  b200              SXTH     r0,r0
000092  eb050145          ADD      r1,r5,r5,LSL #1
000096  4a12              LDR      r2,|L17.224|
000098  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;243          }
00009c  bf00              NOP      
                  |L17.158|
;;;244        }
00009e  bf00              NOP      
                  |L17.160|
0000a0  462c              MOV      r4,r5                 ;235
                  |L17.162|
0000a2  eb040044          ADD      r0,r4,r4,LSL #1       ;235
0000a6  490e              LDR      r1,|L17.224|
0000a8  eb010040          ADD      r0,r1,r0,LSL #1       ;235
0000ac  7905              LDRB     r5,[r0,#4]            ;235
0000ae  2d00              CMP      r5,#0                 ;235
0000b0  d1ad              BNE      |L17.14|
;;;245      }
;;;246      /* Check last block */
;;;247      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
0000b2  eb040044          ADD      r0,r4,r4,LSL #1
0000b6  f9310010          LDRSH    r0,[r1,r0,LSL #1]
0000ba  eb040144          ADD      r1,r4,r4,LSL #1
0000be  4a08              LDR      r2,|L17.224|
0000c0  eb020141          ADD      r1,r2,r1,LSL #1
0000c4  f9b11002          LDRSH    r1,[r1,#2]
0000c8  4408              ADD      r0,r0,r1
0000ca  f2413188          MOV      r1,#0x1388
0000ce  1a08              SUBS     r0,r1,r0
0000d0  42b0              CMP      r0,r6
0000d2  db00              BLT      |L17.214|
;;;248        r = i;
0000d4  46a1              MOV      r9,r4
                  |L17.214|
;;;249      }
;;;250      return r;
0000d6  fa0ff089          SXTH     r0,r9
;;;251    }
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;252    
                          ENDP

0000de  0000              DCW      0x0000
                  |L17.224|
                          DCD      aBlock
                  |L17.228|
                          DCD      GUI_Heap

                          AREA ||i._FindFreeHandle||, CODE, READONLY, ALIGN=2

                  _FindFreeHandle PROC
;;;188    */
;;;189    static GUI_HMEM _FindFreeHandle(void) {
000000  4809              LDR      r0,|L18.40|
;;;190      int i;
;;;191      for (i = _FirstFreeHandle; i < GUI_MAXBLOCKS; i++) {
000002  6801              LDR      r1,[r0,#0]  ; _FirstFreeHandle
000004  e00b              B        |L18.30|
                  |L18.6|
;;;192        if (aBlock[i].Size == 0) {
000006  eb010041          ADD      r0,r1,r1,LSL #1
00000a  4a08              LDR      r2,|L18.44|
00000c  eb020040          ADD      r0,r2,r0,LSL #1
000010  8840              LDRH     r0,[r0,#2]
000012  b918              CBNZ     r0,|L18.28|
;;;193          _FirstFreeHandle = i;
000014  4804              LDR      r0,|L18.40|
000016  6001              STR      r1,[r0,#0]  ; _FirstFreeHandle
;;;194          return i;
000018  b208              SXTH     r0,r1
                  |L18.26|
;;;195        }
;;;196      }
;;;197      GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
;;;198      return GUI_HMEM_NULL;
;;;199    }
00001a  4770              BX       lr
                  |L18.28|
00001c  1c49              ADDS     r1,r1,#1              ;191
                  |L18.30|
00001e  299e              CMP      r1,#0x9e              ;191
000020  dbf1              BLT      |L18.6|
000022  2000              MOVS     r0,#0                 ;198
000024  e7f9              B        |L18.26|
;;;200    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      _FirstFreeHandle
                  |L18.44|
                          DCD      aBlock

                          AREA ||i._FindHole||, CODE, READONLY, ALIGN=2

                  _FindHole PROC
;;;208    */
;;;209    static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
;;;210      int i, iNext;
;;;211      for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
000004  2100              MOVS     r1,#0
000006  e016              B        |L19.54|
                  |L19.8|
;;;212        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000008  eb010041          ADD      r0,r1,r1,LSL #1
00000c  4d19              LDR      r5,|L19.116|
00000e  f8350010          LDRH     r0,[r5,r0,LSL #1]
000012  eb010541          ADD      r5,r1,r1,LSL #1
000016  4e17              LDR      r6,|L19.116|
000018  eb060545          ADD      r5,r6,r5,LSL #1
00001c  886d              LDRH     r5,[r5,#2]
00001e  4428              ADD      r0,r0,r5
000020  eb030543          ADD      r5,r3,r3,LSL #1
000024  f8365015          LDRH     r5,[r6,r5,LSL #1]
000028  1a28              SUBS     r0,r5,r0
00002a  b204              SXTH     r4,r0
;;;213        if (NumFreeBytes>=Size) {
00002c  4294              CMP      r4,r2
00002e  db01              BLT      |L19.52|
;;;214          return i;
000030  b208              SXTH     r0,r1
                  |L19.50|
;;;215        }
;;;216      }
;;;217      /* Check last block */
;;;218      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
;;;219        return i;
;;;220      }
;;;221      return -1;
;;;222    }
000032  bd70              POP      {r4-r6,pc}
                  |L19.52|
000034  4619              MOV      r1,r3                 ;211
                  |L19.54|
000036  eb010041          ADD      r0,r1,r1,LSL #1       ;211
00003a  4c0e              LDR      r4,|L19.116|
00003c  eb040040          ADD      r0,r4,r0,LSL #1       ;211
000040  7903              LDRB     r3,[r0,#4]            ;211
000042  2b00              CMP      r3,#0                 ;211
000044  d1e0              BNE      |L19.8|
000046  eb010041          ADD      r0,r1,r1,LSL #1       ;218
00004a  f9340010          LDRSH    r0,[r4,r0,LSL #1]     ;218
00004e  eb010441          ADD      r4,r1,r1,LSL #1       ;218
000052  4d08              LDR      r5,|L19.116|
000054  eb050444          ADD      r4,r5,r4,LSL #1       ;218
000058  f9b44002          LDRSH    r4,[r4,#2]            ;218
00005c  4420              ADD      r0,r0,r4              ;218
00005e  f2413488          MOV      r4,#0x1388            ;218
000062  1a20              SUBS     r0,r4,r0              ;218
000064  4290              CMP      r0,r2                 ;218
000066  db01              BLT      |L19.108|
000068  b208              SXTH     r0,r1                 ;219
00006a  e7e2              B        |L19.50|
                  |L19.108|
00006c  f04f30ff          MOV      r0,#0xffffffff        ;221
000070  e7df              B        |L19.50|
;;;223    
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      aBlock

                          AREA ||i._Free||, CODE, READONLY, ALIGN=2

                  _Free PROC
;;;148    */
;;;149    static void _Free(GUI_HMEM hMem) {
000000  b570              PUSH     {r4-r6,lr}
;;;150      GUI_ALLOC_DATATYPE Size;
;;;151      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;152      /* Do some error checking ... */
;;;153      #if GUI_DEBUG_LEVEL>0
;;;154        /* Block not allocated ? */
;;;155        if (aBlock[hMem].Size == 0) {
000002  eb000140          ADD      r1,r0,r0,LSL #1
000006  4b23              LDR      r3,|L20.148|
000008  eb030141          ADD      r1,r3,r1,LSL #1
00000c  8849              LDRH     r1,[r1,#2]
00000e  b901              CBNZ     r1,|L20.18|
                  |L20.16|
;;;156          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;157          return;
;;;158        }
;;;159      #endif
;;;160      Size = aBlock[hMem].Size;
;;;161      #ifdef WIN32
;;;162        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;163      #endif
;;;164      GUI_ALLOC.NumFreeBytes += Size;
;;;165      GUI_ALLOC.NumUsedBytes -= Size;
;;;166      aBlock[hMem].Size = 0;
;;;167      if (_FirstFreeHandle > hMem) {
;;;168        _FirstFreeHandle = hMem;
;;;169      }
;;;170      {
;;;171        int Next = aBlock[hMem].Next;
;;;172        int Prev = aBlock[hMem].Prev;
;;;173        aBlock[Prev].Next = Next;
;;;174        if (Next) {
;;;175          aBlock[Next].Prev = Prev;
;;;176        }
;;;177      }  
;;;178      GUI_ALLOC.NumFreeBlocks++;
;;;179      GUI_ALLOC.NumUsedBlocks--;
;;;180    }
000010  bd70              POP      {r4-r6,pc}
                  |L20.18|
000012  eb000140          ADD      r1,r0,r0,LSL #1       ;160
000016  4b1f              LDR      r3,|L20.148|
000018  eb030141          ADD      r1,r3,r1,LSL #1       ;160
00001c  f9b12002          LDRSH    r2,[r1,#2]            ;160
000020  491d              LDR      r1,|L20.152|
000022  89c9              LDRH     r1,[r1,#0xe]          ;164  ; GUI_ALLOC
000024  4411              ADD      r1,r1,r2              ;164
000026  b209              SXTH     r1,r1                 ;164
000028  4b1b              LDR      r3,|L20.152|
00002a  81d9              STRH     r1,[r3,#0xe]          ;164
00002c  4619              MOV      r1,r3                 ;165
00002e  8989              LDRH     r1,[r1,#0xc]          ;165  ; GUI_ALLOC
000030  1a89              SUBS     r1,r1,r2              ;165
000032  b209              SXTH     r1,r1                 ;165
000034  8199              STRH     r1,[r3,#0xc]          ;165
000036  2100              MOVS     r1,#0                 ;166
000038  eb000340          ADD      r3,r0,r0,LSL #1       ;166
00003c  4c15              LDR      r4,|L20.148|
00003e  eb040343          ADD      r3,r4,r3,LSL #1       ;166
000042  8059              STRH     r1,[r3,#2]            ;166
000044  4915              LDR      r1,|L20.156|
000046  6809              LDR      r1,[r1,#0]            ;167  ; _FirstFreeHandle
000048  4281              CMP      r1,r0                 ;167
00004a  dd01              BLE      |L20.80|
00004c  4913              LDR      r1,|L20.156|
00004e  6008              STR      r0,[r1,#0]            ;168  ; _FirstFreeHandle
                  |L20.80|
000050  eb000440          ADD      r4,r0,r0,LSL #1       ;171
000054  4d0f              LDR      r5,|L20.148|
000056  eb050444          ADD      r4,r5,r4,LSL #1       ;171
00005a  7921              LDRB     r1,[r4,#4]            ;171
00005c  eb000440          ADD      r4,r0,r0,LSL #1       ;172
000060  eb050444          ADD      r4,r5,r4,LSL #1       ;172
000064  7963              LDRB     r3,[r4,#5]            ;172
000066  eb030443          ADD      r4,r3,r3,LSL #1       ;173
00006a  eb050444          ADD      r4,r5,r4,LSL #1       ;173
00006e  7121              STRB     r1,[r4,#4]            ;173
000070  b129              CBZ      r1,|L20.126|
000072  eb010541          ADD      r5,r1,r1,LSL #1       ;175
000076  4e07              LDR      r6,|L20.148|
000078  eb060545          ADD      r5,r6,r5,LSL #1       ;175
00007c  716b              STRB     r3,[r5,#5]            ;175
                  |L20.126|
00007e  4906              LDR      r1,|L20.152|
000080  6849              LDR      r1,[r1,#4]            ;178  ; GUI_ALLOC
000082  1c49              ADDS     r1,r1,#1              ;178
000084  4b04              LDR      r3,|L20.152|
000086  6059              STR      r1,[r3,#4]            ;178  ; GUI_ALLOC
000088  4619              MOV      r1,r3                 ;179
00008a  6809              LDR      r1,[r1,#0]            ;179  ; GUI_ALLOC
00008c  1e49              SUBS     r1,r1,#1              ;179
00008e  6019              STR      r1,[r3,#0]            ;179  ; GUI_ALLOC
000090  bf00              NOP      
000092  e7bd              B        |L20.16|
;;;181    
                          ENDP

                  |L20.148|
                          DCD      aBlock
                  |L20.152|
                          DCD      GUI_ALLOC
                  |L20.156|
                          DCD      _FirstFreeHandle

                          AREA ||i._GetNumFreeBytes||, CODE, READONLY, ALIGN=2

                  _GetNumFreeBytes PROC
;;;266    */
;;;267    static GUI_ALLOC_DATATYPE _GetNumFreeBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;268      if (_LockCnt) {
000002  4805              LDR      r0,|L21.24|
000004  6800              LDR      r0,[r0,#0]  ; _LockCnt
000006  b110              CBZ      r0,|L21.14|
;;;269        return GUI_ALLOC_GetMaxSize();
000008  f7fffffe          BL       GUI_ALLOC_GetMaxSize
                  |L21.12|
;;;270      } else {
;;;271        return GUI_ALLOC.NumFreeBytes;  
;;;272      }
;;;273    }
00000c  bd10              POP      {r4,pc}
                  |L21.14|
00000e  4803              LDR      r0,|L21.28|
000010  f9b0000e          LDRSH    r0,[r0,#0xe]          ;271  ; GUI_ALLOC
000014  e7fa              B        |L21.12|
;;;274    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      _LockCnt
                  |L21.28|
                          DCD      GUI_ALLOC

                          AREA ||i._GetSize||, CODE, READONLY, ALIGN=2

                  _GetSize PROC
;;;140    */
;;;141    static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
000000  4601              MOV      r1,r0
;;;142      return aBlock[hMem].Size;
000002  eb010041          ADD      r0,r1,r1,LSL #1
000006  4a03              LDR      r2,|L22.20|
000008  eb020040          ADD      r0,r2,r0,LSL #1
00000c  f9b00002          LDRSH    r0,[r0,#2]
;;;143    }
000010  4770              BX       lr
;;;144    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      aBlock

                          AREA ||i._Size2LegalSize||, CODE, READONLY, ALIGN=1

                  _Size2LegalSize PROC
;;;132    */
;;;133    static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
000000  4601              MOV      r1,r0
;;;134      return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
000002  1cc8              ADDS     r0,r1,#3
000004  f0200003          BIC      r0,r0,#3
000008  b200              SXTH     r0,r0
;;;135    }
00000a  4770              BX       lr
;;;136      
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GUI_Heap
                          %        5000
                  aBlock
                          %        948
                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  IsInitialized
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _FirstFreeHandle
                          DCD      0x00000001
                  _LockCnt
                          DCD      0x00000000
