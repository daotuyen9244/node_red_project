; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\maintask.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\maintask.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\maintask.crf ..\..\uCGUI\uCGUIDemo\MainTask.c]
                          THUMB

                          AREA ||i.AdjustAtt||, CODE, READONLY, ALIGN=2

                  AdjustAtt PROC
;;;445    */
;;;446     void AdjustAtt(uint8_t ch, uint8_t mode)
000000  2801              CMP      r0,#1
;;;447    {
;;;448    
;;;449    	if (ch == 1)
000002  d125              BNE      |L1.80|
;;;450    	{
;;;451    		if (mode == 0) 	/* 降低 */
000004  b951              CBNZ     r1,|L1.28|
;;;452    		{
;;;453    			if (g_DSO.Ch1AttId > 0)
000006  4a26              LDR      r2,|L1.160|
000008  7c12              LDRB     r2,[r2,#0x10]
00000a  2a00              CMP      r2,#0
00000c  dd10              BLE      |L1.48|
;;;454    			{
;;;455    				g_DSO.Ch1AttId--;
00000e  4a24              LDR      r2,|L1.160|
000010  7c12              LDRB     r2,[r2,#0x10]
000012  1e52              SUBS     r2,r2,#1
000014  b2d3              UXTB     r3,r2
000016  4a22              LDR      r2,|L1.160|
000018  7413              STRB     r3,[r2,#0x10]
00001a  e009              B        |L1.48|
                  |L1.28|
;;;456    			}
;;;457    		}
;;;458    		else		/* 增加 */
;;;459    		{
;;;460    			if (g_DSO.Ch1AttId < ATT_COUNT - 1)
00001c  4a20              LDR      r2,|L1.160|
00001e  7c12              LDRB     r2,[r2,#0x10]
000020  2a08              CMP      r2,#8
000022  da05              BGE      |L1.48|
;;;461    			{
;;;462    				g_DSO.Ch1AttId++;
000024  4a1e              LDR      r2,|L1.160|
000026  7c12              LDRB     r2,[r2,#0x10]
000028  1c52              ADDS     r2,r2,#1
00002a  b2d3              UXTB     r3,r2
00002c  4a1c              LDR      r2,|L1.160|
00002e  7413              STRB     r3,[r2,#0x10]
                  |L1.48|
;;;463    			}
;;;464    		}
;;;465    
;;;466    		g_DSO.Ch1Attenuation = g_AttTable[g_DSO.Ch1AttId][0];
000030  4a1b              LDR      r2,|L1.160|
000032  7c12              LDRB     r2,[r2,#0x10]
000034  4b1b              LDR      r3,|L1.164|
000036  f8533032          LDR      r3,[r3,r2,LSL #3]
00003a  4a19              LDR      r2,|L1.160|
00003c  6153              STR      r3,[r2,#0x14]
;;;467    		g_DSO.Ch1VScale =  g_AttTable[g_DSO.Ch1AttId][1];
00003e  7c12              LDRB     r2,[r2,#0x10]
000040  4b18              LDR      r3,|L1.164|
000042  eb0302c2          ADD      r2,r3,r2,LSL #3
000046  8892              LDRH     r2,[r2,#4]
000048  b293              UXTH     r3,r2
00004a  4a15              LDR      r2,|L1.160|
00004c  8393              STRH     r3,[r2,#0x1c]
00004e  e026              B        |L1.158|
                  |L1.80|
;;;468    	}
;;;469    	else if (ch == 2)
000050  2802              CMP      r0,#2
000052  d124              BNE      |L1.158|
;;;470    	{
;;;471    		if (mode == 0) 	/* 降低 */
000054  b951              CBNZ     r1,|L1.108|
;;;472    		{
;;;473    			if (g_DSO.Ch2AttId > 0)
000056  4a12              LDR      r2,|L1.160|
000058  7c52              LDRB     r2,[r2,#0x11]
00005a  2a00              CMP      r2,#0
00005c  dd10              BLE      |L1.128|
;;;474    			{
;;;475    				g_DSO.Ch2AttId--;
00005e  4a10              LDR      r2,|L1.160|
000060  7c52              LDRB     r2,[r2,#0x11]
000062  1e52              SUBS     r2,r2,#1
000064  b2d3              UXTB     r3,r2
000066  4a0e              LDR      r2,|L1.160|
000068  7453              STRB     r3,[r2,#0x11]
00006a  e009              B        |L1.128|
                  |L1.108|
;;;476    			}
;;;477    		}
;;;478    		else		/* 增加 */
;;;479    		{
;;;480    			if (g_DSO.Ch2AttId < ATT_COUNT - 1)
00006c  4a0c              LDR      r2,|L1.160|
00006e  7c52              LDRB     r2,[r2,#0x11]
000070  2a08              CMP      r2,#8
000072  da05              BGE      |L1.128|
;;;481    			{
;;;482    				g_DSO.Ch2AttId++;
000074  4a0a              LDR      r2,|L1.160|
000076  7c52              LDRB     r2,[r2,#0x11]
000078  1c52              ADDS     r2,r2,#1
00007a  b2d3              UXTB     r3,r2
00007c  4a08              LDR      r2,|L1.160|
00007e  7453              STRB     r3,[r2,#0x11]
                  |L1.128|
;;;483    			}
;;;484    		}
;;;485    		g_DSO.Ch2Attenuation = g_AttTable[g_DSO.Ch2AttId][0];
000080  4a07              LDR      r2,|L1.160|
000082  7c52              LDRB     r2,[r2,#0x11]
000084  4b07              LDR      r3,|L1.164|
000086  f8533032          LDR      r3,[r3,r2,LSL #3]
00008a  4a05              LDR      r2,|L1.160|
00008c  6193              STR      r3,[r2,#0x18]
;;;486    		g_DSO.Ch2VScale =  g_AttTable[g_DSO.Ch2AttId][1];
00008e  7c52              LDRB     r2,[r2,#0x11]
000090  4b04              LDR      r3,|L1.164|
000092  eb0302c2          ADD      r2,r3,r2,LSL #3
000096  8892              LDRH     r2,[r2,#4]
000098  b293              UXTH     r3,r2
00009a  4a01              LDR      r2,|L1.160|
00009c  83d3              STRH     r3,[r2,#0x1e]
                  |L1.158|
;;;487    	}
;;;488    }
00009e  4770              BX       lr
;;;489    
                          ENDP

                  |L1.160|
                          DCD      g_DSO+0x5000
                  |L1.164|
                          DCD      g_AttTable

                          AREA ||i.DecSampleFreq||, CODE, READONLY, ALIGN=2

                  DecSampleFreq PROC
;;;423    */
;;;424     void DecSampleFreq(void)
000000  b500              PUSH     {lr}
;;;425    {
;;;426    	if (g_DSO.TimeBaseId > 0)
000002  480d              LDR      r0,|L2.56|
000004  6840              LDR      r0,[r0,#4]
000006  b120              CBZ      r0,|L2.18|
;;;427    	{
;;;428    		g_DSO.TimeBaseId--;
000008  480b              LDR      r0,|L2.56|
00000a  6840              LDR      r0,[r0,#4]
00000c  1e40              SUBS     r0,r0,#1
00000e  490a              LDR      r1,|L2.56|
000010  6048              STR      r0,[r1,#4]
                  |L2.18|
;;;429    	}
;;;430    													 
;;;431    	g_DSO.TimeBase = g_TimeTable[g_DSO.TimeBaseId];
000012  4809              LDR      r0,|L2.56|
000014  6840              LDR      r0,[r0,#4]
000016  4909              LDR      r1,|L2.60|
000018  f8511020          LDR      r1,[r1,r0,LSL #2]
00001c  4806              LDR      r0,|L2.56|
00001e  60c1              STR      r1,[r0,#0xc]
;;;432    	g_DSO.SampleFreq = 25000000 / g_DSO.TimeBase;
000020  68c0              LDR      r0,[r0,#0xc]
000022  4907              LDR      r1,|L2.64|
000024  fbb1f1f0          UDIV     r1,r1,r0
000028  4803              LDR      r0,|L2.56|
00002a  6081              STR      r1,[r0,#8]
;;;433    
;;;434    	SetSampRate(g_DSO.SampleFreq);	/* 改变采样频率 */
00002c  4601              MOV      r1,r0
00002e  6888              LDR      r0,[r1,#8]
000030  f7fffffe          BL       SetSampRate
;;;435    }
000034  bd00              POP      {pc}
;;;436    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      g_DSO+0x5000
                  |L2.60|
                          DCD      g_TimeTable
                  |L2.64|
                          DCD      0x017d7840

                          AREA ||i.DispButton||, CODE, READONLY, ALIGN=2

                  DispButton PROC
;;;509    *******************************************************************************/
;;;510     void DispButton(void)
000000  b510              PUSH     {r4,lr}
;;;511    {
;;;512    	GUI_SetColor(GUI_GREEN);
000002  f44f407f          MOV      r0,#0xff00
000006  f7fffffe          BL       GUI_SetColor
;;;513    				
;;;514    	GUI_DispStringAt(  "VCC",          323-55, 24);
00000a  2218              MOVS     r2,#0x18
00000c  f44f7186          MOV      r1,#0x10c
000010  a016              ADR      r0,|L3.108|
000012  f7fffffe          BL       GUI_DispStringAt
;;;515    	GUI_DispStringAt(  "          V",   323-55, 40);
000016  2228              MOVS     r2,#0x28
000018  f44f7186          MOV      r1,#0x10c
00001c  a014              ADR      r0,|L3.112|
00001e  f7fffffe          BL       GUI_DispStringAt
;;;516    	GUI_DispStringAt(   "ADC",         323-55, 56);
000022  2238              MOVS     r2,#0x38
000024  f44f7186          MOV      r1,#0x10c
000028  a014              ADR      r0,|L3.124|
00002a  f7fffffe          BL       GUI_DispStringAt
;;;517    	GUI_DispStringAt(  "          N",     323-55, 72);
00002e  2248              MOVS     r2,#0x48
000030  f44f7186          MOV      r1,#0x10c
000034  a012              ADR      r0,|L3.128|
000036  f7fffffe          BL       GUI_DispStringAt
;;;518        GUI_DispStringAt(   "VPP",         323-55, 88);
00003a  2258              MOVS     r2,#0x58
00003c  f44f7186          MOV      r1,#0x10c
000040  a012              ADR      r0,|L3.140|
000042  f7fffffe          BL       GUI_DispStringAt
;;;519    	GUI_DispStringAt(  "          V",   323-55, 104);
000046  2268              MOVS     r2,#0x68
000048  f44f7186          MOV      r1,#0x10c
00004c  a008              ADR      r0,|L3.112|
00004e  f7fffffe          BL       GUI_DispStringAt
;;;520    	GUI_DispStringAt(  "PERIOD",       323-55, 120);
000052  2278              MOVS     r2,#0x78
000054  f44f7186          MOV      r1,#0x10c
000058  a00d              ADR      r0,|L3.144|
00005a  f7fffffe          BL       GUI_DispStringAt
;;;521    	GUI_DispStringAt(  "           H", 323-55, 136);
00005e  2288              MOVS     r2,#0x88
000060  f44f7186          MOV      r1,#0x10c
000064  a00c              ADR      r0,|L3.152|
000066  f7fffffe          BL       GUI_DispStringAt
;;;522    }
00006a  bd10              POP      {r4,pc}
;;;523    /*******************************************************************************
                          ENDP

                  |L3.108|
00006c  56434300          DCB      "VCC",0
                  |L3.112|
000070  20202020          DCB      "          V",0
000074  20202020
000078  20205600
                  |L3.124|
00007c  41444300          DCB      "ADC",0
                  |L3.128|
000080  20202020          DCB      "          N",0
000084  20202020
000088  20204e00
                  |L3.140|
00008c  56505000          DCB      "VPP",0
                  |L3.144|
000090  50455249          DCB      "PERIOD",0
000094  4f4400  
000097  00                DCB      0
                  |L3.152|
000098  20202020          DCB      "           H",0
00009c  20202020
0000a0  20202048
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.DispCh1Wave||, CODE, READONLY, ALIGN=2

                  DispCh1Wave PROC
;;;254    */
;;;255     void DispCh1Wave(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;256    {
000004  b087              SUB      sp,sp,#0x1c
;;;257    	int16_t i,j = 0;		/* 有符号数 */
000006  f04f0b00          MOV      r11,#0
;;;258    	uint16_t *px;
;;;259    	uint16_t *py;
;;;260    	int16_t iTemp;
;;;261        uint16_t VccMax,VccMin;
;;;262    	uint16_t Average;
;;;263    
;;;264          for(i=0;i<1024;i++)
00000a  2400              MOVS     r4,#0
00000c  e017              B        |L4.62|
                  |L4.14|
;;;265    	{ 
;;;266    		
;;;267    		g_DSO.Ch1Buf[j++]=g_DSO.buffer[i]>>16;		//ADC2
00000e  487d              LDR      r0,|L4.516|
000010  f8500024          LDR      r0,[r0,r4,LSL #2]
000014  0c02              LSRS     r2,r0,#16
000016  4658              MOV      r0,r11
000018  1c41              ADDS     r1,r0,#1
00001a  fa0ffb81          SXTH     r11,r1
00001e  497a              LDR      r1,|L4.520|
000020  f8212010          STRH     r2,[r1,r0,LSL #1]
;;;268    		g_DSO.Ch1Buf[j++]=g_DSO.buffer[i] & 0xFFFF;	//ADC1
000024  4877              LDR      r0,|L4.516|
000026  f8300024          LDRH     r0,[r0,r4,LSL #2]
00002a  b282              UXTH     r2,r0
00002c  4658              MOV      r0,r11
00002e  1c41              ADDS     r1,r0,#1
000030  fa0ffb81          SXTH     r11,r1
000034  4974              LDR      r1,|L4.520|
000036  f8212010          STRH     r2,[r1,r0,LSL #1]
00003a  1c60              ADDS     r0,r4,#1              ;264
00003c  b204              SXTH     r4,r0                 ;264
                  |L4.62|
00003e  f5b46f80          CMP      r4,#0x400             ;264
000042  dbe4              BLT      |L4.14|
;;;269    	}
;;;270    
;;;271    	if (g_DSO.BufUsed == 0)
000044  4871              LDR      r0,|L4.524|
000046  f89001e0          LDRB     r0,[r0,#0x1e0]
00004a  b920              CBNZ     r0,|L4.86|
;;;272    	{
;;;273    		g_DSO.BufUsed = 1;
00004c  2101              MOVS     r1,#1
00004e  486f              LDR      r0,|L4.524|
000050  f88011e0          STRB     r1,[r0,#0x1e0]
000054  e003              B        |L4.94|
                  |L4.86|
;;;274    	}
;;;275    	else
;;;276    	{
;;;277    		g_DSO.BufUsed = 0;
000056  2100              MOVS     r1,#0
000058  486c              LDR      r0,|L4.524|
00005a  f88011e0          STRB     r1,[r0,#0x1e0]
                  |L4.94|
;;;278    	}
;;;279    
;;;280    	if (g_DSO.BufUsed == 0)
00005e  486b              LDR      r0,|L4.524|
000060  f89001e0          LDRB     r0,[r0,#0x1e0]
000064  b920              CBNZ     r0,|L4.112|
;;;281    	{
;;;282    		px = g_DSO.xCh1Buf1;
000066  f8df81a8          LDR      r8,|L4.528|
;;;283    		py = g_DSO.yCh1Buf1;
00006a  f508751b          ADD      r5,r8,#0x26c
00006e  e003              B        |L4.120|
                  |L4.112|
;;;284    	}
;;;285    	else
;;;286    	{
;;;287    		px = g_DSO.xCh1Buf2;
000070  f8df81a0          LDR      r8,|L4.532|
;;;288    		py = g_DSO.yCh1Buf2;
000074  f508751b          ADD      r5,r8,#0x26c
                  |L4.120|
;;;289    	}
;;;290    
;;;291    	  GUI_SetColor(GUI_MAGENTA);
000078  f04f10ff          MOV      r0,#0xff00ff
00007c  f7fffffe          BL       GUI_SetColor
;;;292    	
;;;293    	 /* 下面的代码用于实现 最大值和最小值得差值  */
;;;294    	 VccMax=g_DSO.Ch1Buf[0];
000080  4861              LDR      r0,|L4.520|
000082  8807              LDRH     r7,[r0,#0]  ; g_DSO
;;;295    	 VccMin=g_DSO.Ch1Buf[0];
000084  f8b09000          LDRH     r9,[r0,#0]  ; g_DSO
;;;296    	 for(i=1;i<1024;i++)
000088  2401              MOVS     r4,#1
00008a  e011              B        |L4.176|
                  |L4.140|
;;;297    	 {
;;;298    	    if(VccMax<g_DSO.Ch1Buf[i])VccMax=g_DSO.Ch1Buf[i];
00008c  485e              LDR      r0,|L4.520|
00008e  f8300014          LDRH     r0,[r0,r4,LSL #1]
000092  42b8              CMP      r0,r7
000094  dd02              BLE      |L4.156|
000096  485c              LDR      r0,|L4.520|
000098  f8307014          LDRH     r7,[r0,r4,LSL #1]
                  |L4.156|
;;;299    		if(VccMin>g_DSO.Ch1Buf[i])VccMin=g_DSO.Ch1Buf[i];
00009c  485a              LDR      r0,|L4.520|
00009e  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000a2  4548              CMP      r0,r9
0000a4  da02              BGE      |L4.172|
0000a6  4858              LDR      r0,|L4.520|
0000a8  f8309014          LDRH     r9,[r0,r4,LSL #1]
                  |L4.172|
0000ac  1c60              ADDS     r0,r4,#1              ;296
0000ae  b204              SXTH     r4,r0                 ;296
                  |L4.176|
0000b0  f5b46f80          CMP      r4,#0x400             ;296
0000b4  dbea              BLT      |L4.140|
;;;300    	 }
;;;301    	  VccMax=VccMax-VccMin;
0000b6  eba70009          SUB      r0,r7,r9
0000ba  b287              UXTH     r7,r0
;;;302          GUI_GotoXY(323-55,104);
0000bc  2168              MOVS     r1,#0x68
0000be  f44f7086          MOV      r0,#0x10c
0000c2  f7fffffe          BL       GUI_GotoXY
;;;303    	  GUI_DispFloatFix((VccMax* 1.406)/1050,5,2);
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       __aeabi_ui2d
0000cc  4a52              LDR      r2,|L4.536|
0000ce  4b53              LDR      r3,|L4.540|
0000d0  e9cd0100          STRD     r0,r1,[sp,#0]
0000d4  f7fffffe          BL       __aeabi_dmul
0000d8  2200              MOVS     r2,#0
0000da  4b51              LDR      r3,|L4.544|
0000dc  e9cd0102          STRD     r0,r1,[sp,#8]
0000e0  f7fffffe          BL       __aeabi_ddiv
0000e4  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000e8  f7fffffe          BL       __aeabi_d2f
0000ec  2202              MOVS     r2,#2
0000ee  2105              MOVS     r1,#5
0000f0  9006              STR      r0,[sp,#0x18]
0000f2  f7fffffe          BL       GUI_DispFloatFix
;;;304    	 
;;;305    	 /* CH1通道, 输入0V时，ADC采样值 = 1900 ,1024个点求到的平均值 */
;;;306    	 /* 增益1:1的时候 1.406对应的AD值是2951 -1901 = 1050  */
;;;307    	  for(i=1;i<21;i++)
0000f6  2401              MOVS     r4,#1
0000f8  e007              B        |L4.266|
                  |L4.250|
;;;308    	 {
;;;309    	    Average +=g_DSO.Ch1Buf[i];
0000fa  4843              LDR      r0,|L4.520|
0000fc  f8300014          LDRH     r0,[r0,r4,LSL #1]
000100  4450              ADD      r0,r0,r10
000102  fa1ffa80          UXTH     r10,r0
000106  1c60              ADDS     r0,r4,#1              ;307
000108  b204              SXTH     r4,r0                 ;307
                  |L4.266|
00010a  2c15              CMP      r4,#0x15              ;307
00010c  dbf5              BLT      |L4.250|
;;;310    	 } 
;;;311    	 Average = Average / 20;
00010e  2014              MOVS     r0,#0x14
000110  fb9af0f0          SDIV     r0,r10,r0
000114  fa1ffa80          UXTH     r10,r0
;;;312    	 GUI_GotoXY(323-55,40);
000118  2128              MOVS     r1,#0x28
00011a  f44f7086          MOV      r0,#0x10c
00011e  f7fffffe          BL       GUI_GotoXY
;;;313    	 GUI_DispFloatFix(((Average-1900) * 1.406)/1050,5,2);
000122  f2aa706c          SUB      r0,r10,#0x76c
000126  f7fffffe          BL       __aeabi_i2d
00012a  4a3b              LDR      r2,|L4.536|
00012c  4b3b              LDR      r3,|L4.540|
00012e  e9cd0100          STRD     r0,r1,[sp,#0]
000132  f7fffffe          BL       __aeabi_dmul
000136  2200              MOVS     r2,#0
000138  4b39              LDR      r3,|L4.544|
00013a  e9cd0102          STRD     r0,r1,[sp,#8]
00013e  f7fffffe          BL       __aeabi_ddiv
000142  e9cd0104          STRD     r0,r1,[sp,#0x10]
000146  f7fffffe          BL       __aeabi_d2f
00014a  2202              MOVS     r2,#2
00014c  2105              MOVS     r1,#5
00014e  9006              STR      r0,[sp,#0x18]
000150  f7fffffe          BL       GUI_DispFloatFix
;;;314    	 
;;;315    
;;;316    	 GUI_DispDecAt(g_DSO.Ch1Buf[0], 323-55, 72, 4);
000154  492c              LDR      r1,|L4.520|
000156  8808              LDRH     r0,[r1,#0]  ; g_DSO
000158  2304              MOVS     r3,#4
00015a  2248              MOVS     r2,#0x48
00015c  f44f7186          MOV      r1,#0x10c
000160  f7fffffe          BL       GUI_DispDecAt
;;;317    	/* 下面的代码用于实现波形的刷新  */
;;;318    	for (i = 0; i < 300; i++)
000164  2400              MOVS     r4,#0
000166  e023              B        |L4.432|
                  |L4.360|
;;;319    	{
;;;320    		px[i] = 15 + i;
000168  f104000f          ADD      r0,r4,#0xf
00016c  f8280014          STRH     r0,[r8,r4,LSL #1]
;;;321    		iTemp = g_DSO.Ch1VOffset + (int16_t)((1900 - g_DSO.Ch1Buf[i + 1]) * 10)/g_DSO.Ch1Attenuation ;
000170  4925              LDR      r1,|L4.520|
000172  1c60              ADDS     r0,r4,#1
000174  f8310010          LDRH     r0,[r1,r0,LSL #1]
000178  f240716c          MOV      r1,#0x76c
00017c  1a08              SUBS     r0,r1,r0
00017e  eb000080          ADD      r0,r0,r0,LSL #2
000182  0040              LSLS     r0,r0,#1
000184  b201              SXTH     r1,r0
000186  4822              LDR      r0,|L4.528|
000188  3830              SUBS     r0,r0,#0x30
00018a  6940              LDR      r0,[r0,#0x14]
00018c  fb91f1f0          SDIV     r1,r1,r0
000190  481f              LDR      r0,|L4.528|
000192  3830              SUBS     r0,r0,#0x30
000194  8d40              LDRH     r0,[r0,#0x2a]
000196  4408              ADD      r0,r0,r1
000198  b206              SXTH     r6,r0
;;;322    		if (iTemp > 200)
00019a  2ec8              CMP      r6,#0xc8
00019c  dd01              BLE      |L4.418|
;;;323    		{
;;;324    			iTemp = 200;
00019e  26c8              MOVS     r6,#0xc8
0001a0  e002              B        |L4.424|
                  |L4.418|
;;;325    		}
;;;326    		else if (iTemp < 0)
0001a2  2e00              CMP      r6,#0
0001a4  da00              BGE      |L4.424|
;;;327    		{
;;;328    			iTemp = 0;
0001a6  2600              MOVS     r6,#0
                  |L4.424|
;;;329    		}
;;;330    		py[i] = iTemp;
0001a8  f8256014          STRH     r6,[r5,r4,LSL #1]
0001ac  1c60              ADDS     r0,r4,#1              ;318
0001ae  b204              SXTH     r4,r0                 ;318
                  |L4.432|
0001b0  f5b47f96          CMP      r4,#0x12c             ;318
0001b4  dbd8              BLT      |L4.360|
;;;331    	}
;;;332    
;;;333    	/* 下面的代码采取清除上帧波形，然后再重新描绘新波形，避免整屏刷新的闪烁感 */
;;;334    	/* 清除上帧波形 */
;;;335    	if (g_DSO.BufUsed == 0)
0001b6  4815              LDR      r0,|L4.524|
0001b8  f89001e0          LDRB     r0,[r0,#0x1e0]
0001bc  b950              CBNZ     r0,|L4.468|
;;;336    	{
;;;337    		GUI_SetColor(GUI_BLUE);
0001be  f44f007f          MOV      r0,#0xff0000
0001c2  f7fffffe          BL       GUI_SetColor
;;;338    	    GUI_DrawGraph((signed short *)g_DSO.yCh1Buf2, 250, 14,20);
0001c6  2314              MOVS     r3,#0x14
0001c8  220e              MOVS     r2,#0xe
0001ca  21fa              MOVS     r1,#0xfa
0001cc  4815              LDR      r0,|L4.548|
0001ce  f7fffffe          BL       GUI_DrawGraph
0001d2  e009              B        |L4.488|
                  |L4.468|
;;;339    
;;;340    	}
;;;341    	else
;;;342    	{
;;;343    		GUI_SetColor(GUI_BLUE);
0001d4  f44f007f          MOV      r0,#0xff0000
0001d8  f7fffffe          BL       GUI_SetColor
;;;344    	    GUI_DrawGraph((signed short *)g_DSO.yCh1Buf1, 250, 14,20);
0001dc  2314              MOVS     r3,#0x14
0001de  220e              MOVS     r2,#0xe
0001e0  21fa              MOVS     r1,#0xfa
0001e2  4811              LDR      r0,|L4.552|
0001e4  f7fffffe          BL       GUI_DrawGraph
                  |L4.488|
;;;345    	}
;;;346    
;;;347    	/* 显示更新的波形 */
;;;348    	GUI_SetColor(GUI_YELLOW);
0001e8  f64f70ff          MOV      r0,#0xffff
0001ec  f7fffffe          BL       GUI_SetColor
;;;349    	GUI_DrawGraph((I16 *)py, 250, 14,20);
0001f0  2314              MOVS     r3,#0x14
0001f2  220e              MOVS     r2,#0xe
0001f4  21fa              MOVS     r1,#0xfa
0001f6  4628              MOV      r0,r5
0001f8  f7fffffe          BL       GUI_DrawGraph
;;;350    }
0001fc  b007              ADD      sp,sp,#0x1c
0001fe  e8bd8ff0          POP      {r4-r11,pc}
;;;351    /*
                          ENDP

000202  0000              DCW      0x0000
                  |L4.516|
                          DCD      g_DSO+0x1000
                  |L4.520|
                          DCD      g_DSO
                  |L4.524|
                          DCD      g_DSO+0x6000
                  |L4.528|
                          DCD      g_DSO+0x5030
                  |L4.532|
                          DCD      g_DSO+0x5508
                  |L4.536|
                          DCD      0xdb22d0e5
                  |L4.540|
                          DCD      0x3ff67ef9
                  |L4.544|
                          DCD      0x40906800
                  |L4.548|
                          DCD      g_DSO+0x5774
                  |L4.552|
                          DCD      g_DSO+0x529c

                          AREA ||i.DispChInfo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                  DispChInfo PROC
;;;528    *******************************************************************************/
;;;529    static void DispChInfo(void)
000000  b510              PUSH     {r4,lr}
;;;530    {
000002  b088              SUB      sp,sp,#0x20
;;;531    	char buf[32];   							/* 字符显示缓冲区 */
;;;532    											
;;;533    
;;;534    	GUI_SetColor(GUI_GREEN);   					/* 白字 */
000004  f44f407f          MOV      r0,#0xff00
000008  f7fffffe          BL       GUI_SetColor
;;;535    	GUI_DispStringAt( DSO_VER,15, 2);
00000c  2202              MOVS     r2,#2
00000e  210f              MOVS     r1,#0xf
000010  a03b              ADR      r0,|L5.256|
000012  f7fffffe          BL       GUI_DispStringAt
;;;536    		
;;;537    	if (g_DSO.Ch1DC == 1)						/* 显示通道1信息 */
000016  483c              LDR      r0,|L5.264|
000018  f8900028          LDRB     r0,[r0,#0x28]
00001c  2801              CMP      r0,#1
00001e  d104              BNE      |L5.42|
;;;538    	{
;;;539    		strcpy(buf, "CH1 ");
000020  a13a              ADR      r1,|L5.268|
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strcpy
000028  e003              B        |L5.50|
                  |L5.42|
;;;540    	}
;;;541    	else
;;;542    	{
;;;543    		strcpy(buf, "CH1 ");
00002a  a138              ADR      r1,|L5.268|
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       strcpy
                  |L5.50|
;;;544    	}
;;;545    
;;;546    	if (g_DSO.Ch1VScale >= 1000)
000032  4835              LDR      r0,|L5.264|
000034  8b80              LDRH     r0,[r0,#0x1c]
000036  f5b07f7a          CMP      r0,#0x3e8
00003a  db0b              BLT      |L5.84|
;;;547    	{
;;;548    		sprintf(&buf[4], "%d.00V/div", g_DSO.Ch1VScale / 1000);
00003c  4832              LDR      r0,|L5.264|
00003e  8b80              LDRH     r0,[r0,#0x1c]
000040  f44f717a          MOV      r1,#0x3e8
000044  fb90f4f1          SDIV     r4,r0,r1
000048  4622              MOV      r2,r4
00004a  a132              ADR      r1,|L5.276|
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       __2sprintf
000052  e005              B        |L5.96|
                  |L5.84|
;;;549    	}
;;;550    	else
;;;551    	{
;;;552    		sprintf(&buf[4], "%dmV/div", g_DSO.Ch1VScale);
000054  482c              LDR      r0,|L5.264|
000056  8b82              LDRH     r2,[r0,#0x1c]
000058  a131              ADR      r1,|L5.288|
00005a  a801              ADD      r0,sp,#4
00005c  f7fffffe          BL       __2sprintf
                  |L5.96|
;;;553    	}
;;;554    	GUI_DispStringAt( buf,15, 224);
000060  22e0              MOVS     r2,#0xe0
000062  210f              MOVS     r1,#0xf
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       GUI_DispStringAt
;;;555    	
;;;556    	
;;;557    	/* 显示时基 */
;;;558    	if (g_DSO.TimeBase <= 1000)
00006a  4827              LDR      r0,|L5.264|
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  f5b07f7a          CMP      r0,#0x3e8
000072  d807              BHI      |L5.132|
;;;559    	{
;;;560    		sprintf(buf, "Time %3dus/div", g_DSO.TimeBase/2);
000074  4824              LDR      r0,|L5.264|
000076  68c0              LDR      r0,[r0,#0xc]
000078  0842              LSRS     r2,r0,#1
00007a  a12c              ADR      r1,|L5.300|
00007c  4668              MOV      r0,sp
00007e  f7fffffe          BL       __2sprintf
000082  e01a              B        |L5.186|
                  |L5.132|
;;;561    	}
;;;562    	else if (g_DSO.TimeBase < 1000000)
000084  4820              LDR      r0,|L5.264|
000086  68c0              LDR      r0,[r0,#0xc]
000088  492c              LDR      r1,|L5.316|
00008a  4288              CMP      r0,r1
00008c  d20b              BCS      |L5.166|
;;;563    	{
;;;564    		sprintf(buf, "Time %3dms/div  ", g_DSO.TimeBase / 2000);
00008e  481e              LDR      r0,|L5.264|
000090  68c0              LDR      r0,[r0,#0xc]
000092  f44f61fa          MOV      r1,#0x7d0
000096  fbb0f4f1          UDIV     r4,r0,r1
00009a  4622              MOV      r2,r4
00009c  a128              ADR      r1,|L5.320|
00009e  4668              MOV      r0,sp
0000a0  f7fffffe          BL       __2sprintf
0000a4  e009              B        |L5.186|
                  |L5.166|
;;;565    	}
;;;566    	else
;;;567    	{
;;;568    		sprintf(buf, "Time %3ds/div   ", g_DSO.TimeBase / 2000000);	
0000a6  4818              LDR      r0,|L5.264|
0000a8  68c0              LDR      r0,[r0,#0xc]
0000aa  492a              LDR      r1,|L5.340|
0000ac  fbb0f4f1          UDIV     r4,r0,r1
0000b0  4622              MOV      r2,r4
0000b2  a129              ADR      r1,|L5.344|
0000b4  4668              MOV      r0,sp
0000b6  f7fffffe          BL       __2sprintf
                  |L5.186|
;;;569    	}
;;;570    	GUI_DispStringAt(buf, 170, 224);
0000ba  22e0              MOVS     r2,#0xe0
0000bc  21aa              MOVS     r1,#0xaa
0000be  4668              MOV      r0,sp
0000c0  f7fffffe          BL       GUI_DispStringAt
;;;571    	                                                                                                                                                                                                                                             
;;;572    	
;;;573    	if (g_DSO.AdjustMode == 1)
0000c4  4810              LDR      r0,|L5.264|
0000c6  f890002f          LDRB     r0,[r0,#0x2f]
0000ca  2801              CMP      r0,#1
0000cc  d105              BNE      |L5.218|
;;;574    	{
;;;575            GUI_DispStringAt("ChangeFreq   ",170, 2);
0000ce  2202              MOVS     r2,#2
0000d0  21aa              MOVS     r1,#0xaa
0000d2  a026              ADR      r0,|L5.364|
0000d4  f7fffffe          BL       GUI_DispStringAt
0000d8  e004              B        |L5.228|
                  |L5.218|
;;;576    	}
;;;577    	else
;;;578    	{
;;;579    		GUI_DispStringAt("ChangeScope ",170, 2);
0000da  2202              MOVS     r2,#2
0000dc  21aa              MOVS     r1,#0xaa
0000de  a027              ADR      r0,|L5.380|
0000e0  f7fffffe          BL       GUI_DispStringAt
                  |L5.228|
;;;580    	}
;;;581    	
;;;582    	
;;;583    	sprintf(buf, "Freq:%7dHz  ",	g_DSO.SampleFreq*2);
0000e4  4808              LDR      r0,|L5.264|
0000e6  6880              LDR      r0,[r0,#8]
0000e8  0042              LSLS     r2,r0,#1
0000ea  a128              ADR      r1,|L5.396|
0000ec  4668              MOV      r0,sp
0000ee  f7fffffe          BL       __2sprintf
;;;584        GUI_DispStringAt(buf,52, 2);
0000f2  2202              MOVS     r2,#2
0000f4  2134              MOVS     r1,#0x34
0000f6  4668              MOV      r0,sp
0000f8  f7fffffe          BL       GUI_DispStringAt
;;;585    }
0000fc  b008              ADD      sp,sp,#0x20
0000fe  bd10              POP      {r4,pc}
;;;586    /*
                          ENDP

                  |L5.256|
000100  56312e30          DCB      "V1.0",0
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L5.264|
                          DCD      g_DSO+0x5000
                  |L5.268|
00010c  43483120          DCB      "CH1 ",0
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L5.276|
000114  25642e30          DCB      "%d.00V/div",0
000118  30562f64
00011c  697600  
00011f  00                DCB      0
                  |L5.288|
000120  25646d56          DCB      "%dmV/div",0
000124  2f646976
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L5.300|
00012c  54696d65          DCB      "Time %3dus/div",0
000130  20253364
000134  75732f64
000138  697600  
00013b  00                DCB      0
                  |L5.316|
                          DCD      0x000f4240
                  |L5.320|
000140  54696d65          DCB      "Time %3dms/div  ",0
000144  20253364
000148  6d732f64
00014c  69762020
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L5.340|
                          DCD      0x001e8480
                  |L5.344|
000158  54696d65          DCB      "Time %3ds/div   ",0
00015c  20253364
000160  732f6469
000164  76202020
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L5.364|
00016c  4368616e          DCB      "ChangeFreq   ",0
000170  67654672
000174  65712020
000178  2000    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L5.380|
00017c  4368616e          DCB      "ChangeScope ",0
000180  67655363
000184  6f706520
000188  00      
000189  00                DCB      0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L5.396|
00018c  46726571          DCB      "Freq:%7dHz  ",0
000190  3a253764
000194  487a2020
000198  00      
000199  00                DCB      0
00019a  00                DCB      0
00019b  00                DCB      0

                          AREA ||i.DispFrame||, CODE, READONLY, ALIGN=1

                  DispFrame PROC
;;;613    }
;;;614     void DispFrame(void)
000000  b570              PUSH     {r4-r6,lr}
;;;615    {
;;;616    	uint16_t x,y;
;;;617    	GUI_SetColor(GUI_WHITE);					
000002  f06f407f          MVN      r0,#0xff000000
000006  f7fffffe          BL       GUI_SetColor
;;;618    	GUI_DrawRect(13, 19, 265, 221);						//这个函数对坐标值有影响 
00000a  23dd              MOVS     r3,#0xdd
00000c  f2401209          MOV      r2,#0x109
000010  2113              MOVS     r1,#0x13
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       GUI_DrawRect
;;;619    	for (x = 0; x < 11; x++)							/* 绘制垂直刻度点 */
000018  2400              MOVS     r4,#0
00001a  e013              B        |L6.68|
                  |L6.28|
;;;620    	{
;;;621    		for (y = 0; y < 41; y++)
00001c  2500              MOVS     r5,#0
00001e  e00d              B        |L6.60|
                  |L6.32|
;;;622    		{
;;;623    			GUI_DrawPixel(14 + (x * 25), 20 + (y * 5));
000020  eb050285          ADD      r2,r5,r5,LSL #2
000024  f1020114          ADD      r1,r2,#0x14
000028  eb0402c4          ADD      r2,r4,r4,LSL #3
00002c  eb021204          ADD      r2,r2,r4,LSL #4
000030  f102000e          ADD      r0,r2,#0xe
000034  f7fffffe          BL       GUI_DrawPixel
000038  1c68              ADDS     r0,r5,#1              ;621
00003a  b285              UXTH     r5,r0                 ;621
                  |L6.60|
00003c  2d29              CMP      r5,#0x29              ;621
00003e  dbef              BLT      |L6.32|
000040  1c60              ADDS     r0,r4,#1              ;619
000042  b284              UXTH     r4,r0                 ;619
                  |L6.68|
000044  2c0b              CMP      r4,#0xb               ;619
000046  dbe9              BLT      |L6.28|
;;;624    		}
;;;625    	}
;;;626    	for (y = 0; y < 9; y++)								/* 绘制水平刻度点 */
000048  2500              MOVS     r5,#0
00004a  e013              B        |L6.116|
                  |L6.76|
;;;627    	{
;;;628    		for (x = 0; x < 51; x++)
00004c  2400              MOVS     r4,#0
00004e  e00d              B        |L6.108|
                  |L6.80|
;;;629    		{
;;;630    			GUI_DrawPixel(14 + (x * 5), 20 + (y * 25));
000050  eb0502c5          ADD      r2,r5,r5,LSL #3
000054  eb021205          ADD      r2,r2,r5,LSL #4
000058  f1020114          ADD      r1,r2,#0x14
00005c  eb040284          ADD      r2,r4,r4,LSL #2
000060  f102000e          ADD      r0,r2,#0xe
000064  f7fffffe          BL       GUI_DrawPixel
000068  1c60              ADDS     r0,r4,#1              ;628
00006a  b284              UXTH     r4,r0                 ;628
                  |L6.108|
00006c  2c33              CMP      r4,#0x33              ;628
00006e  dbef              BLT      |L6.80|
000070  1c68              ADDS     r0,r5,#1              ;626
000072  b285              UXTH     r5,r0                 ;626
                  |L6.116|
000074  2d09              CMP      r5,#9                 ;626
000076  dbe9              BLT      |L6.76|
;;;631    		}
;;;632    	}
;;;633    	for (y = 0; y < 41; y++)							/* 绘制垂直中心刻度点 */
000078  2500              MOVS     r5,#0
00007a  e00f              B        |L6.156|
                  |L6.124|
;;;634    	{	 
;;;635    		GUI_DrawPixel(13 + (5 * 25), 20 + (y * 5));
00007c  eb050085          ADD      r0,r5,r5,LSL #2
000080  f1000114          ADD      r1,r0,#0x14
000084  208a              MOVS     r0,#0x8a
000086  f7fffffe          BL       GUI_DrawPixel
;;;636    		GUI_DrawPixel(15 + (5 * 25), 20 + (y * 5));
00008a  eb050085          ADD      r0,r5,r5,LSL #2
00008e  f1000114          ADD      r1,r0,#0x14
000092  208c              MOVS     r0,#0x8c
000094  f7fffffe          BL       GUI_DrawPixel
000098  1c68              ADDS     r0,r5,#1              ;633
00009a  b285              UXTH     r5,r0                 ;633
                  |L6.156|
00009c  2d29              CMP      r5,#0x29              ;633
00009e  dbed              BLT      |L6.124|
;;;637    	}	
;;;638    	for (x = 0; x < 51; x++)							/* 绘制水平中心刻度点 */
0000a0  2400              MOVS     r4,#0
0000a2  e00f              B        |L6.196|
                  |L6.164|
;;;639    	{	 
;;;640    		GUI_DrawPixel(14 + (x * 5), 19 + (4 * 25));
0000a4  eb040184          ADD      r1,r4,r4,LSL #2
0000a8  f101000e          ADD      r0,r1,#0xe
0000ac  2177              MOVS     r1,#0x77
0000ae  f7fffffe          BL       GUI_DrawPixel
;;;641    		GUI_DrawPixel(14 + (x * 5), 21 + (4 * 25));
0000b2  eb040184          ADD      r1,r4,r4,LSL #2
0000b6  f101000e          ADD      r0,r1,#0xe
0000ba  2179              MOVS     r1,#0x79
0000bc  f7fffffe          BL       GUI_DrawPixel
0000c0  1c60              ADDS     r0,r4,#1              ;638
0000c2  b284              UXTH     r4,r0                 ;638
                  |L6.196|
0000c4  2c33              CMP      r4,#0x33              ;638
0000c6  dbed              BLT      |L6.164|
;;;642    	}
;;;643    }
0000c8  bd70              POP      {r4-r6,pc}
;;;644    
                          ENDP


                          AREA ||i.IncSampleFreq||, CODE, READONLY, ALIGN=2

                  IncSampleFreq PROC
;;;386    */
;;;387     void IncSampleFreq(void)
000000  b500              PUSH     {lr}
;;;388    {
;;;389    	/*	时间轴分度（每1个大格的时长)
;;;390    	    10us          2500000		
;;;391    		20us 	      1250000   
;;;392    		50us 		   500000
;;;393    		100us		   250000
;;;394    		200us		   125000
;;;395    		500us		    50000
;;;396    		1ms				 2500
;;;397    		2ms				 1250
;;;398    		5ms				  500 
;;;399    		10ms			  250
;;;400    		20ms			  125
;;;401    		50ms			   50
;;;402    		100ms			   25
;;;403    
;;;404    	*/
;;;405    	if (g_DSO.TimeBaseId < (sizeof(g_TimeTable) / 4) - 1)
000002  480d              LDR      r0,|L7.56|
000004  6840              LDR      r0,[r0,#4]
000006  280f              CMP      r0,#0xf
000008  d204              BCS      |L7.20|
;;;406    	{
;;;407    		g_DSO.TimeBaseId++;
00000a  480b              LDR      r0,|L7.56|
00000c  6840              LDR      r0,[r0,#4]
00000e  1c40              ADDS     r0,r0,#1
000010  4909              LDR      r1,|L7.56|
000012  6048              STR      r0,[r1,#4]
                  |L7.20|
;;;408    	}
;;;409    													 
;;;410    	g_DSO.TimeBase = 	g_TimeTable[g_DSO.TimeBaseId];
000014  4808              LDR      r0,|L7.56|
000016  6840              LDR      r0,[r0,#4]
000018  4908              LDR      r1,|L7.60|
00001a  f8511020          LDR      r1,[r1,r0,LSL #2]
00001e  4806              LDR      r0,|L7.56|
000020  60c1              STR      r1,[r0,#0xc]
;;;411    	g_DSO.SampleFreq = 25000000 / g_DSO.TimeBase;
000022  68c0              LDR      r0,[r0,#0xc]
000024  4906              LDR      r1,|L7.64|
000026  fbb1f1f0          UDIV     r1,r1,r0
00002a  4803              LDR      r0,|L7.56|
00002c  6081              STR      r1,[r0,#8]
;;;412    
;;;413    	SetSampRate(g_DSO.SampleFreq);	/* 改变采样频率 */
00002e  4601              MOV      r1,r0
000030  6888              LDR      r0,[r1,#8]
000032  f7fffffe          BL       SetSampRate
;;;414    }
000036  bd00              POP      {pc}
;;;415    
                          ENDP

                  |L7.56|
                          DCD      g_DSO+0x5000
                  |L7.60|
                          DCD      g_TimeTable
                  |L7.64|
                          DCD      0x017d7840

                          AREA ||i.InitDSO||, CODE, READONLY, ALIGN=2

                  InitDSO PROC
;;;103    */
;;;104     void InitDSO(void)
000000  b500              PUSH     {lr}
;;;105    {
000002  b08b              SUB      sp,sp,#0x2c
;;;106      	{
;;;107    		GPIO_InitTypeDef GPIO_InitStructure;
;;;108    
;;;109    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC	| RCC_APB2Periph_AFIO, ENABLE); //配置IO口
000004  2101              MOVS     r1,#1
000006  2011              MOVS     r0,#0x11
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;110    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);			   			//使能定时器1时钟
00000c  2101              MOVS     r1,#1
00000e  02c8              LSLS     r0,r1,#11
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;111    		RCC_ADCCLKConfig(RCC_PCLK2_Div2);     										//ADCCLK = PCLK2/4 = 18MHz
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       RCC_ADCCLKConfig
;;;112    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
00001a  2003              MOVS     r0,#3
00001c  f8ad0028          STRH     r0,[sp,#0x28]
;;;113    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000020  2000              MOVS     r0,#0
000022  f88d002b          STRB     r0,[sp,#0x2b]
;;;114    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d002a          STRB     r0,[sp,#0x2a]
;;;115    		GPIO_Init(GPIOC, &GPIO_InitStructure);
00002c  a90a              ADD      r1,sp,#0x28
00002e  4871              LDR      r0,|L8.500|
000030  f7fffffe          BL       GPIO_Init
;;;116    	}
;;;117    	#if 1
;;;118    	{
;;;119    		DMA_InitTypeDef DMA_InitStructure;
;;;120    		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000034  2101              MOVS     r1,#1
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;121    
;;;122    		DMA_DeInit(DMA1_Channel1);													/* 复位DMA1寄存器到缺省状态 */
00003c  486e              LDR      r0,|L8.504|
00003e  f7fffffe          BL       DMA_DeInit
;;;123    		DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;					/* 选择ADC1的数据寄存器作为源 */
000042  486e              LDR      r0,|L8.508|
000044  9000              STR      r0,[sp,#0]
;;;124    		DMA_InitStructure.DMA_MemoryBaseAddr =(uint32_t)&g_DSO.buffer;						/* 目标地址 */
000046  486e              LDR      r0,|L8.512|
000048  9001              STR      r0,[sp,#4]
;;;125    		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;							/* 设置DMA传输方向，外设(ADC)作为源 */
00004a  2000              MOVS     r0,#0
00004c  9002              STR      r0,[sp,#8]
;;;126    		DMA_InitStructure.DMA_BufferSize = SAMPLE_COUNT;							/* 设置缓冲区大小 */
00004e  f44f6080          MOV      r0,#0x400
000052  9003              STR      r0,[sp,#0xc]
;;;127    		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;			/* 外设地址不自增 */
000054  2000              MOVS     r0,#0
000056  9004              STR      r0,[sp,#0x10]
;;;128    		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;						/* 存储器地址需要自增 */
000058  2080              MOVS     r0,#0x80
00005a  9005              STR      r0,[sp,#0x14]
;;;129    //		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	/* 选择外设传输单位：16bit */
;;;130    //		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;			/* 选择内存传输单位：16bit */
;;;131    		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;	    /* 选择外设传输单位：16bit */
00005c  0080              LSLS     r0,r0,#2
00005e  9006              STR      r0,[sp,#0x18]
;;;132    		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;			    /* 选择内存传输单位：16bit */
000060  0080              LSLS     r0,r0,#2
000062  9007              STR      r0,[sp,#0x1c]
;;;133    		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;								/* 无需循环模式   */
000064  2000              MOVS     r0,#0
000066  9008              STR      r0,[sp,#0x20]
;;;134    		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;						/* 选择DMA优先级 */
000068  f44f5040          MOV      r0,#0x3000
00006c  9009              STR      r0,[sp,#0x24]
;;;135    		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;								/* DMA传输类型，不是内存到内存 */
00006e  2000              MOVS     r0,#0
000070  900a              STR      r0,[sp,#0x28]
;;;136    		DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000072  4669              MOV      r1,sp
000074  4860              LDR      r0,|L8.504|
000076  f7fffffe          BL       DMA_Init
;;;137    		DMA_Cmd(DMA1_Channel1, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  485e              LDR      r0,|L8.504|
00007e  f7fffffe          BL       DMA_Cmd
;;;138    	}
;;;139    	#endif
;;;140    	#if 1
;;;141    	{
;;;142    		ADC_InitTypeDef	ADC_InitStructure;
;;;143    
;;;144    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1|RCC_APB2Periph_ADC2, ENABLE);
000082  2101              MOVS     r1,#1
000084  f44f60c0          MOV      r0,#0x600
000088  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;145    
;;;146    		  ADC_DeInit(ADC1);
00008c  485b              LDR      r0,|L8.508|
00008e  384c              SUBS     r0,r0,#0x4c
000090  f7fffffe          BL       ADC_DeInit
;;;147    		  ADC_DeInit(ADC2);
000094  485b              LDR      r0,|L8.516|
000096  f7fffffe          BL       ADC_DeInit
;;;148    		  /* ADC1 configuration ------------------------------------------------------*/
;;;149    		  ADC_InitStructure.ADC_Mode = ADC_Mode_FastInterl;
00009a  f44f20e0          MOV      r0,#0x70000
00009e  9006              STR      r0,[sp,#0x18]
;;;150    		  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000a0  2000              MOVS     r0,#0
0000a2  f88d001c          STRB     r0,[sp,#0x1c]
;;;151    		  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000a6  f88d001d          STRB     r0,[sp,#0x1d]
;;;152    		  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC3;
0000aa  f44f2080          MOV      r0,#0x40000
0000ae  9008              STR      r0,[sp,#0x20]
;;;153    		  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000b0  2000              MOVS     r0,#0
0000b2  9009              STR      r0,[sp,#0x24]
;;;154    		  ADC_InitStructure.ADC_NbrOfChannel = 1;
0000b4  2001              MOVS     r0,#1
0000b6  f88d0028          STRB     r0,[sp,#0x28]
;;;155    		  ADC_Init(ADC1, &ADC_InitStructure);
0000ba  a906              ADD      r1,sp,#0x18
0000bc  484f              LDR      r0,|L8.508|
0000be  384c              SUBS     r0,r0,#0x4c
0000c0  f7fffffe          BL       ADC_Init
;;;156    		  ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_1Cycles5);//18M/(1.5+12.5)=1.2857M最大采样频率  
0000c4  2300              MOVS     r3,#0
0000c6  2201              MOVS     r2,#1
0000c8  210a              MOVS     r1,#0xa
0000ca  484c              LDR      r0,|L8.508|
0000cc  384c              SUBS     r0,r0,#0x4c
0000ce  f7fffffe          BL       ADC_RegularChannelConfig
;;;157    		  ADC_ExternalTrigConvCmd(ADC1, ENABLE);
0000d2  2101              MOVS     r1,#1
0000d4  4849              LDR      r0,|L8.508|
0000d6  384c              SUBS     r0,r0,#0x4c
0000d8  f7fffffe          BL       ADC_ExternalTrigConvCmd
;;;158    		  
;;;159    		  /* ADC1 configuration ------------------------------------------------------*/
;;;160    		  ADC_InitStructure.ADC_Mode = ADC_Mode_FastInterl;
0000dc  f44f20e0          MOV      r0,#0x70000
0000e0  9006              STR      r0,[sp,#0x18]
;;;161    		  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000e2  2000              MOVS     r0,#0
0000e4  f88d001c          STRB     r0,[sp,#0x1c]
;;;162    		  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000e8  f88d001d          STRB     r0,[sp,#0x1d]
;;;163    		  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0000ec  f44f2060          MOV      r0,#0xe0000
0000f0  9008              STR      r0,[sp,#0x20]
;;;164    		  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000f2  2000              MOVS     r0,#0
0000f4  9009              STR      r0,[sp,#0x24]
;;;165    		  ADC_InitStructure.ADC_NbrOfChannel = 1;
0000f6  2001              MOVS     r0,#1
0000f8  f88d0028          STRB     r0,[sp,#0x28]
;;;166    		  ADC_Init(ADC2, &ADC_InitStructure);
0000fc  a906              ADD      r1,sp,#0x18
0000fe  4841              LDR      r0,|L8.516|
000100  f7fffffe          BL       ADC_Init
;;;167    		  ADC_RegularChannelConfig(ADC2, ADC_Channel_10, 1, ADC_SampleTime_1Cycles5); //18M/(1.5+12.5)=1.2857M最大采样频率
000104  2300              MOVS     r3,#0
000106  2201              MOVS     r2,#1
000108  210a              MOVS     r1,#0xa
00010a  483e              LDR      r0,|L8.516|
00010c  f7fffffe          BL       ADC_RegularChannelConfig
;;;168    		  ADC_ExternalTrigConvCmd(ADC2, ENABLE);
000110  2101              MOVS     r1,#1
000112  483c              LDR      r0,|L8.516|
000114  f7fffffe          BL       ADC_ExternalTrigConvCmd
;;;169    		  
;;;170    		  /* Enable ADC1 */
;;;171    		  ADC_DMACmd(ADC1, ENABLE);
000118  2101              MOVS     r1,#1
00011a  4838              LDR      r0,|L8.508|
00011c  384c              SUBS     r0,r0,#0x4c
00011e  f7fffffe          BL       ADC_DMACmd
;;;172    		  ADC_Cmd(ADC1, ENABLE);  
000122  2101              MOVS     r1,#1
000124  4835              LDR      r0,|L8.508|
000126  384c              SUBS     r0,r0,#0x4c
000128  f7fffffe          BL       ADC_Cmd
;;;173    		  ADC_ResetCalibration(ADC1);
00012c  4833              LDR      r0,|L8.508|
00012e  384c              SUBS     r0,r0,#0x4c
000130  f7fffffe          BL       ADC_ResetCalibration
;;;174    		  while(ADC_GetResetCalibrationStatus(ADC1));
000134  bf00              NOP      
                  |L8.310|
000136  4831              LDR      r0,|L8.508|
000138  384c              SUBS     r0,r0,#0x4c
00013a  f7fffffe          BL       ADC_GetResetCalibrationStatus
00013e  2800              CMP      r0,#0
000140  d1f9              BNE      |L8.310|
;;;175    		  ADC_StartCalibration(ADC1);
000142  482e              LDR      r0,|L8.508|
000144  384c              SUBS     r0,r0,#0x4c
000146  f7fffffe          BL       ADC_StartCalibration
;;;176    		  while(ADC_GetCalibrationStatus(ADC1));
00014a  bf00              NOP      
                  |L8.332|
00014c  482b              LDR      r0,|L8.508|
00014e  384c              SUBS     r0,r0,#0x4c
000150  f7fffffe          BL       ADC_GetCalibrationStatus
000154  2800              CMP      r0,#0
000156  d1f9              BNE      |L8.332|
;;;177    		     
;;;178    		  /* Enable ADC2 */
;;;179    		  ADC_Cmd(ADC2, ENABLE);
000158  2101              MOVS     r1,#1
00015a  482a              LDR      r0,|L8.516|
00015c  f7fffffe          BL       ADC_Cmd
;;;180    		  ADC_ResetCalibration(ADC2);
000160  4828              LDR      r0,|L8.516|
000162  f7fffffe          BL       ADC_ResetCalibration
;;;181    		  while(ADC_GetResetCalibrationStatus(ADC2));
000166  bf00              NOP      
                  |L8.360|
000168  4826              LDR      r0,|L8.516|
00016a  f7fffffe          BL       ADC_GetResetCalibrationStatus
00016e  2800              CMP      r0,#0
000170  d1fa              BNE      |L8.360|
;;;182    		  ADC_StartCalibration(ADC2);
000172  4824              LDR      r0,|L8.516|
000174  f7fffffe          BL       ADC_StartCalibration
;;;183    		  while(ADC_GetCalibrationStatus(ADC2));
000178  bf00              NOP      
                  |L8.378|
00017a  4822              LDR      r0,|L8.516|
00017c  f7fffffe          BL       ADC_GetCalibrationStatus
000180  2800              CMP      r0,#0
000182  d1fa              BNE      |L8.378|
;;;184    	}
;;;185    	#endif
;;;186    	#if 0
;;;187    	{
;;;188    		ADC_InitTypeDef	ADC_InitStructure;
;;;189    
;;;190    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
;;;191    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
;;;192    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
;;;193    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;							/* 连续转换静止 */
;;;194    		//ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;		/* 选择TIM1的CC1做触发 */
;;;195    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC3;		/* 选择TIM2的CC3做触发 */
;;;196    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;						/* 数据右对齐,高位为0 */
;;;197    		ADC_InitStructure.ADC_NbrOfChannel = 1;										/* 1个通道 */
;;;198    		ADC_Init(ADC3, &ADC_InitStructure);		
;;;199    		ADC_RegularChannelConfig(ADC3, ADC_Channel_11, 1, ADC_SampleTime_1Cycles5);	/* ADC1 regular channels configuration */
;;;200    		ADC_ExternalTrigConvCmd(ADC3, ENABLE);
;;;201    		ADC_Cmd(ADC3, ENABLE);
;;;202    		ADC_DMACmd(ADC3, ENABLE);
;;;203    		ADC_ResetCalibration(ADC3);
;;;204    		while(ADC_GetResetCalibrationStatus(ADC3));
;;;205    		ADC_StartCalibration(ADC3);
;;;206    		while(ADC_GetCalibrationStatus(ADC3));
;;;207    	}
;;;208    	#endif
;;;209    	//SetSampRate(g_DSO.SampleFreq);													/* 配置采样触发定时器，使用TIM1 CC3修改采样频率(启动时100K) */
;;;210    	#if 1
;;;211    	{   
;;;212    	    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;213    		TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;214    		TIM_Cmd(TIM1, DISABLE);	
000184  2100              MOVS     r1,#0
000186  4820              LDR      r0,|L8.520|
000188  f7fffffe          BL       TIM_Cmd
;;;215    		TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 				   //初始化定时器1的寄存器为复位值
00018c  a808              ADD      r0,sp,#0x20
00018e  f7fffffe          BL       TIM_TimeBaseStructInit
;;;216    		TIM_TimeBaseStructure.TIM_Period = 72000000 / g_DSO.SampleFreq;    //ARR自动重装载寄存器周期的值(定时时间）到设置频率后产生个更新或者中断(也是说定时时间到)
000192  481e              LDR      r0,|L8.524|
000194  6880              LDR      r0,[r0,#8]
000196  491e              LDR      r1,|L8.528|
000198  fbb1f0f0          UDIV     r0,r1,r0
00019c  b280              UXTH     r0,r0
00019e  f8ad0024          STRH     r0,[sp,#0x24]
;;;217    		TIM_TimeBaseStructure.TIM_Prescaler = 0;   						   //PSC时钟预分频数 例如：时钟频率=TIM1CLK/(时钟预分频+1)
0001a2  2000              MOVS     r0,#0
0001a4  f8ad0020          STRH     r0,[sp,#0x20]
;;;218    		TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    				   //CR1->CKD时间分割值
0001a8  f8ad0026          STRH     r0,[sp,#0x26]
;;;219    		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  	   //CR1->CMS[1:0]和DIR定时器模式 向上计数
0001ac  f8ad0022          STRH     r0,[sp,#0x22]
;;;220    		TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
0001b0  a908              ADD      r1,sp,#0x20
0001b2  4815              LDR      r0,|L8.520|
0001b4  f7fffffe          BL       TIM_TimeBaseInit
;;;221    
;;;222    		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 				   //CCMR2在向上计数时，一旦TIMx_CNT<TIMx_CCR1时通道1为有效电平，否则为无效电平
0001b8  2060              MOVS     r0,#0x60
0001ba  f8ad0010          STRH     r0,[sp,#0x10]
;;;223    		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;      //CCER 输出使能          
0001be  2001              MOVS     r0,#1
0001c0  f8ad0012          STRH     r0,[sp,#0x12]
;;;224    		TIM_OCInitStructure.TIM_Pulse = TIM_TimeBaseStructure.TIM_Period / 2;//CCR3同计数器TIMx_CNT的比较，并在OC4端口上产生输出信号 
0001c4  f8bd0024          LDRH     r0,[sp,#0x24]
0001c8  eb0071d0          ADD      r1,r0,r0,LSR #31
0001cc  1049              ASRS     r1,r1,#1
0001ce  f8ad1016          STRH     r1,[sp,#0x16]
;;;225    		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;    	   //CCER输出极性设置	高电平有效     
0001d2  2002              MOVS     r0,#2
0001d4  f8ad0018          STRH     r0,[sp,#0x18]
;;;226    		TIM_OC3Init(TIM1, &TIM_OCInitStructure);
0001d8  a904              ADD      r1,sp,#0x10
0001da  480b              LDR      r0,|L8.520|
0001dc  f7fffffe          BL       TIM_OC3Init
;;;227    	    //TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);					//CMR2 设置预装载使能  更新事件产生时写入有效
;;;228    		//TIM_ARRPreloadConfig(TIM1, ENABLE);		   		 				//CR1  设置ARR自动重装 更新事件产生时写入有效
;;;229    		TIM_Cmd(TIM1, ENABLE);											   
0001e0  2101              MOVS     r1,#1
0001e2  4809              LDR      r0,|L8.520|
0001e4  f7fffffe          BL       TIM_Cmd
;;;230    		TIM_CtrlPWMOutputs(TIM1, ENABLE);  								   //使能PWM 输出
0001e8  2101              MOVS     r1,#1
0001ea  4807              LDR      r0,|L8.520|
0001ec  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;231    	}
;;;232    	#endif
;;;233    }
0001f0  b00b              ADD      sp,sp,#0x2c
0001f2  bd00              POP      {pc}
;;;234    
                          ENDP

                  |L8.500|
                          DCD      0x40011000
                  |L8.504|
                          DCD      0x40020008
                  |L8.508|
                          DCD      0x4001244c
                  |L8.512|
                          DCD      g_DSO+0x1000
                  |L8.516|
                          DCD      0x40012800
                  |L8.520|
                          DCD      0x40012c00
                  |L8.524|
                          DCD      g_DSO+0x5000
                  |L8.528|
                          DCD      0x044aa200

                          AREA ||i.InitDsoParam||, CODE, READONLY, ALIGN=2

                  InitDsoParam PROC
;;;358    */
;;;359     void InitDsoParam(void)
000000  2164              MOVS     r1,#0x64
;;;360    {				
;;;361    
;;;362    	g_DSO.Ch1VOffset = 100; 				/* 通道1 GND线位置 */
000002  4815              LDR      r0,|L9.88|
000004  8541              STRH     r1,[r0,#0x2a]
;;;363    	g_DSO.Ch2VOffset = 220;
000006  21dc              MOVS     r1,#0xdc
000008  8581              STRH     r1,[r0,#0x2c]
;;;364    
;;;365    	g_DSO.AdjustMode = 0;					/* 缺省是调节放大和衰减 */
00000a  2100              MOVS     r1,#0
00000c  f880102f          STRB     r1,[r0,#0x2f]
;;;366    
;;;367    	g_DSO.HoldEn = 0;
000010  f5005080          ADD      r0,r0,#0x1000
000014  f88011e4          STRB     r1,[r0,#0x1e4]
;;;368    	g_DSO.TimeBaseId = 0;									 
000018  480f              LDR      r0,|L9.88|
00001a  6041              STR      r1,[r0,#4]
;;;369    	g_DSO.TimeBase   = g_TimeTable[g_DSO.TimeBaseId];
00001c  6840              LDR      r0,[r0,#4]
00001e  490f              LDR      r1,|L9.92|
000020  f8511020          LDR      r1,[r1,r0,LSL #2]
000024  480c              LDR      r0,|L9.88|
000026  60c1              STR      r1,[r0,#0xc]
;;;370    	g_DSO.SampleFreq = 25000000 / g_DSO.TimeBase;
000028  68c0              LDR      r0,[r0,#0xc]
00002a  490d              LDR      r1,|L9.96|
00002c  fbb1f1f0          UDIV     r1,r1,r0
000030  4809              LDR      r0,|L9.88|
000032  6081              STR      r1,[r0,#8]
;;;371    
;;;372    
;;;373    	g_DSO.Ch1AttId = 2;
000034  2102              MOVS     r1,#2
000036  7401              STRB     r1,[r0,#0x10]
;;;374    	g_DSO.Ch1Attenuation = g_AttTable[g_DSO.Ch1AttId][0];		/* 缺省是1V */
000038  7c00              LDRB     r0,[r0,#0x10]
00003a  490a              LDR      r1,|L9.100|
00003c  f8511030          LDR      r1,[r1,r0,LSL #3]
000040  4805              LDR      r0,|L9.88|
000042  6141              STR      r1,[r0,#0x14]
;;;375    	g_DSO.Ch1VScale =  g_AttTable[g_DSO.Ch1AttId][1];			/* 设置缺省衰减系数 */
000044  7c00              LDRB     r0,[r0,#0x10]
000046  4907              LDR      r1,|L9.100|
000048  eb0100c0          ADD      r0,r1,r0,LSL #3
00004c  8880              LDRH     r0,[r0,#4]
00004e  b281              UXTH     r1,r0
000050  4801              LDR      r0,|L9.88|
000052  8381              STRH     r1,[r0,#0x1c]
;;;376    
;;;377    }
000054  4770              BX       lr
;;;378    
                          ENDP

000056  0000              DCW      0x0000
                  |L9.88|
                          DCD      g_DSO+0x5000
                  |L9.92|
                          DCD      g_TimeTable
                  |L9.96|
                          DCD      0x017d7840
                  |L9.100|
                          DCD      g_AttTable

                          AREA ||i.MainTask||, CODE, READONLY, ALIGN=2

                  MainTask PROC
;;;757    */
;;;758    void MainTask(void) 
000000  b51f              PUSH     {r0-r4,lr}
;;;759    { 
;;;760        GUI_Init();
000002  f7fffffe          BL       GUI_Init
;;;761        WM_SetCreateFlags(WM_CF_MEMDEV);  /* Use memory devices on all windows to avoid flicker */
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       WM_SetCreateFlags
;;;762    	WM_EnableMemdev(WM_HBKWIN);
00000c  f7fffffe          BL       WM_GetDesktopWindow
000010  4604              MOV      r4,r0
000012  f7fffffe          BL       WM_EnableMemdev
;;;763    	WM_SetCallback(WM_HBKWIN, &_cbBkWin);
000016  f7fffffe          BL       WM_GetDesktopWindow
00001a  4604              MOV      r4,r0
00001c  4986              LDR      r1,|L10.568|
00001e  f7fffffe          BL       WM_SetCallback
;;;764    
;;;765    
;;;766    	GUI_SetBkColor(GUI_BLUE);
000022  f44f007f          MOV      r0,#0xff0000
000026  f7fffffe          BL       GUI_SetBkColor
;;;767    	GUI_SetFont(&GUI_Font16B_1);
00002a  4884              LDR      r0,|L10.572|
00002c  f7fffffe          BL       GUI_SetFont
;;;768    	GUI_Clear();
000030  f7fffffe          BL       GUI_Clear
;;;769    
;;;770    
;;;771        ahButton[0] = BUTTON_Create(318-52,152,75-21, 20, GUI_ID_ADC,  BUTTON_CF_SHOW );
000034  2002              MOVS     r0,#2
000036  0281              LSLS     r1,r0,#10
000038  2314              MOVS     r3,#0x14
00003a  2236              MOVS     r2,#0x36
00003c  e9cd1000          STRD     r1,r0,[sp,#0]
000040  2198              MOVS     r1,#0x98
000042  f44f7085          MOV      r0,#0x10a
000046  f7fffffe          BL       BUTTON_Create
00004a  497d              LDR      r1,|L10.576|
00004c  8008              STRH     r0,[r1,#0]
;;;772    	BUTTON_SetTextColor(ahButton[0],BUTTON_CI_UNPRESSED,GUI_GREEN);
00004e  f9b10000          LDRSH    r0,[r1,#0]  ; ahButton
000052  f44f427f          MOV      r2,#0xff00
000056  2100              MOVS     r1,#0
000058  f7fffffe          BL       BUTTON_SetTextColor
;;;773        BUTTON_SetFont(ahButton[0],&GUI_Font16B_1);
00005c  4978              LDR      r1,|L10.576|
00005e  f9b10000          LDRSH    r0,[r1,#0]  ; ahButton
000062  4976              LDR      r1,|L10.572|
000064  f7fffffe          BL       BUTTON_SetFont
;;;774    	BUTTON_SetText(ahButton[0],"Inc");
000068  4975              LDR      r1,|L10.576|
00006a  f9b10000          LDRSH    r0,[r1,#0]  ; ahButton
00006e  a175              ADR      r1,|L10.580|
000070  f7fffffe          BL       BUTTON_SetText
;;;775    		
;;;776    	ahButton[1] = BUTTON_Create(318-52,174,75-21, 20,  GUI_ID_DAC,  BUTTON_CF_SHOW );
000074  2002              MOVS     r0,#2
000076  f6400101          MOV      r1,#0x801
00007a  2314              MOVS     r3,#0x14
00007c  2236              MOVS     r2,#0x36
00007e  e9cd1000          STRD     r1,r0,[sp,#0]
000082  21ae              MOVS     r1,#0xae
000084  f44f7085          MOV      r0,#0x10a
000088  f7fffffe          BL       BUTTON_Create
00008c  496c              LDR      r1,|L10.576|
00008e  8048              STRH     r0,[r1,#2]
;;;777    	BUTTON_SetTextColor(ahButton[1],BUTTON_CI_UNPRESSED,GUI_GREEN);
000090  f9b10002          LDRSH    r0,[r1,#2]  ; ahButton
000094  f44f427f          MOV      r2,#0xff00
000098  2100              MOVS     r1,#0
00009a  f7fffffe          BL       BUTTON_SetTextColor
;;;778        BUTTON_SetFont(ahButton[1],&GUI_Font16B_1);
00009e  4968              LDR      r1,|L10.576|
0000a0  f9b10002          LDRSH    r0,[r1,#2]  ; ahButton
0000a4  4965              LDR      r1,|L10.572|
0000a6  f7fffffe          BL       BUTTON_SetFont
;;;779    	BUTTON_SetText(ahButton[1],"Dec");
0000aa  4965              LDR      r1,|L10.576|
0000ac  f9b10002          LDRSH    r0,[r1,#2]  ; ahButton
0000b0  a165              ADR      r1,|L10.584|
0000b2  f7fffffe          BL       BUTTON_SetText
;;;780    
;;;781    	ahButton[2] = BUTTON_Create(318-52,196,75-21, 20,  GUI_ID_FFT,  BUTTON_CF_SHOW );
0000b6  2002              MOVS     r0,#2
0000b8  f6400102          MOV      r1,#0x802
0000bc  2314              MOVS     r3,#0x14
0000be  2236              MOVS     r2,#0x36
0000c0  e9cd1000          STRD     r1,r0,[sp,#0]
0000c4  21c4              MOVS     r1,#0xc4
0000c6  f44f7085          MOV      r0,#0x10a
0000ca  f7fffffe          BL       BUTTON_Create
0000ce  495c              LDR      r1,|L10.576|
0000d0  8088              STRH     r0,[r1,#4]
;;;782    	BUTTON_SetTextColor(ahButton[2],BUTTON_CI_UNPRESSED,GUI_GREEN);
0000d2  f9b10004          LDRSH    r0,[r1,#4]  ; ahButton
0000d6  f44f427f          MOV      r2,#0xff00
0000da  2100              MOVS     r1,#0
0000dc  f7fffffe          BL       BUTTON_SetTextColor
;;;783        BUTTON_SetFont(ahButton[2],&GUI_Font16B_1);
0000e0  4957              LDR      r1,|L10.576|
0000e2  f9b10004          LDRSH    r0,[r1,#4]  ; ahButton
0000e6  4955              LDR      r1,|L10.572|
0000e8  f7fffffe          BL       BUTTON_SetFont
;;;784    	BUTTON_SetText(ahButton[2],"Switch");
0000ec  4954              LDR      r1,|L10.576|
0000ee  f9b10004          LDRSH    r0,[r1,#4]  ; ahButton
0000f2  a156              ADR      r1,|L10.588|
0000f4  f7fffffe          BL       BUTTON_SetText
;;;785    
;;;786    	ahButton[3] = BUTTON_Create(318-52,218,75-21, 20,  GUI_ID_Spectrum, BUTTON_CF_SHOW );
0000f8  2002              MOVS     r0,#2
0000fa  f6400103          MOV      r1,#0x803
0000fe  2314              MOVS     r3,#0x14
000100  2236              MOVS     r2,#0x36
000102  e9cd1000          STRD     r1,r0,[sp,#0]
000106  21da              MOVS     r1,#0xda
000108  f44f7085          MOV      r0,#0x10a
00010c  f7fffffe          BL       BUTTON_Create
000110  494b              LDR      r1,|L10.576|
000112  80c8              STRH     r0,[r1,#6]
;;;787    	BUTTON_SetTextColor(ahButton[3],BUTTON_CI_UNPRESSED,GUI_GREEN);
000114  f9b10006          LDRSH    r0,[r1,#6]  ; ahButton
000118  f44f427f          MOV      r2,#0xff00
00011c  2100              MOVS     r1,#0
00011e  f7fffffe          BL       BUTTON_SetTextColor
;;;788        BUTTON_SetFont(ahButton[3],&GUI_Font16B_1);
000122  4947              LDR      r1,|L10.576|
000124  f9b10006          LDRSH    r0,[r1,#6]  ; ahButton
000128  4944              LDR      r1,|L10.572|
00012a  f7fffffe          BL       BUTTON_SetFont
;;;789    	BUTTON_SetText(ahButton[3],"Spectr");
00012e  4944              LDR      r1,|L10.576|
000130  f9b10006          LDRSH    r0,[r1,#6]  ; ahButton
000134  a147              ADR      r1,|L10.596|
000136  f7fffffe          BL       BUTTON_SetText
;;;790    
;;;791    	
;;;792    	ahProgbar[0]=PROGBAR_Create(318-52,2,75-21,20,WM_CF_SHOW);
00013a  2002              MOVS     r0,#2
00013c  2314              MOVS     r3,#0x14
00013e  2236              MOVS     r2,#0x36
000140  4601              MOV      r1,r0
000142  9000              STR      r0,[sp,#0]
000144  f44f7085          MOV      r0,#0x10a
000148  f7fffffe          BL       PROGBAR_Create
00014c  4943              LDR      r1,|L10.604|
00014e  8008              STRH     r0,[r1,#0]
;;;793        PROGBAR_SetBarColor(ahProgbar[0],0,GUI_MAGENTA);
000150  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
000154  f04f12ff          MOV      r2,#0xff00ff
000158  2100              MOVS     r1,#0
00015a  f7fffffe          BL       PROGBAR_SetBarColor
;;;794        PROGBAR_SetBarColor(ahProgbar[0],1,GUI_RED);
00015e  493f              LDR      r1,|L10.604|
000160  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
000164  22ff              MOVS     r2,#0xff
000166  2101              MOVS     r1,#1
000168  f7fffffe          BL       PROGBAR_SetBarColor
;;;795        PROGBAR_SetFont(ahProgbar[0],&GUI_Font16B_1);
00016c  493b              LDR      r1,|L10.604|
00016e  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
000172  4932              LDR      r1,|L10.572|
000174  f7fffffe          BL       PROGBAR_SetFont
;;;796    	PROGBAR_SetMinMax(ahProgbar[0],0,100);
000178  4938              LDR      r1,|L10.604|
00017a  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
00017e  2264              MOVS     r2,#0x64
000180  2100              MOVS     r1,#0
000182  f7fffffe          BL       PROGBAR_SetMinMax
;;;797    	WIDGET_SetEffect(ahProgbar[0], &WIDGET_Effect_3D);
000186  4935              LDR      r1,|L10.604|
000188  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
00018c  4934              LDR      r1,|L10.608|
00018e  f7fffffe          BL       WIDGET_SetEffect
;;;798    
;;;799    	ahScrollbar[0]=SCROLLBAR_Create(0,11,12,217,0,GUI_ID_OSCLevel,WM_CF_SHOW,SCROLLBAR_CF_VERTICAL);
000192  2008              MOVS     r0,#8
000194  2102              MOVS     r1,#2
000196  f6400204          MOV      r2,#0x804
00019a  2300              MOVS     r3,#0
00019c  e9cd3200          STRD     r3,r2,[sp,#0]
0001a0  e9cd1002          STRD     r1,r0,[sp,#8]
0001a4  23d9              MOVS     r3,#0xd9
0001a6  220c              MOVS     r2,#0xc
0001a8  210b              MOVS     r1,#0xb
0001aa  2000              MOVS     r0,#0
0001ac  f7fffffe          BL       SCROLLBAR_Create
0001b0  492c              LDR      r1,|L10.612|
0001b2  8008              STRH     r0,[r1,#0]
;;;800        SCROLLBAR_SetNumItems(ahScrollbar[0],200);
0001b4  f9b10000          LDRSH    r0,[r1,#0]  ; ahScrollbar
0001b8  21c8              MOVS     r1,#0xc8
0001ba  f7fffffe          BL       SCROLLBAR_SetNumItems
;;;801    	SCROLLBAR_SetValue(ahScrollbar[0],100);
0001be  4929              LDR      r1,|L10.612|
0001c0  f9b10000          LDRSH    r0,[r1,#0]  ; ahScrollbar
0001c4  2164              MOVS     r1,#0x64
0001c6  f7fffffe          BL       SCROLLBAR_SetValue
;;;802    	
;;;803    	DispButton();
0001ca  f7fffffe          BL       DispButton
;;;804    	DispChInfo();
0001ce  f7fffffe          BL       DispChInfo
;;;805    	ConfigRefresh=0;
0001d2  2000              MOVS     r0,#0
0001d4  4924              LDR      r1,|L10.616|
0001d6  7008              STRB     r0,[r1,#0]
;;;806    	fRefresh =1;
0001d8  2001              MOVS     r0,#1
0001da  4924              LDR      r1,|L10.620|
0001dc  7008              STRB     r0,[r1,#0]
;;;807    	while(1)
0001de  e029              B        |L10.564|
                  |L10.480|
;;;808    	{ 
;;;809    	   if(ConfigRefresh == 0) 
0001e0  4821              LDR      r0,|L10.616|
0001e2  7800              LDRB     r0,[r0,#0]  ; ConfigRefresh
0001e4  bb18              CBNZ     r0,|L10.558|
;;;810    	   { 
;;;811    		  if (fRefresh)
0001e6  4821              LDR      r0,|L10.620|
0001e8  7800              LDRB     r0,[r0,#0]  ; fRefresh
0001ea  b148              CBZ      r0,|L10.512|
;;;812    		  {
;;;813    			  fRefresh = 0;
0001ec  2000              MOVS     r0,#0
0001ee  491f              LDR      r1,|L10.620|
0001f0  7008              STRB     r0,[r1,#0]
;;;814    			  if(g_DSO.HoldEn == 1)
0001f2  481f              LDR      r0,|L10.624|
0001f4  f89001e4          LDRB     r0,[r0,#0x1e4]
0001f8  2801              CMP      r0,#1
0001fa  d101              BNE      |L10.512|
;;;815    			{		 
;;;816    			   DispChInfo();	
0001fc  f7fffffe          BL       DispChInfo
                  |L10.512|
;;;817    			}	 
;;;818    			  
;;;819    		  }
;;;820    		  if (g_DSO.HoldEn == 0)
000200  481b              LDR      r0,|L10.624|
000202  f89001e4          LDRB     r0,[r0,#0x1e4]
000206  b958              CBNZ     r0,|L10.544|
;;;821    		  {
;;;822    		    StopADC();	  			 /* 暂停采样 */			 
000208  f7fffffe          BL       StopADC
;;;823    	 		DispFrame();
00020c  f7fffffe          BL       DispFrame
;;;824    			DispChInfo();
000210  f7fffffe          BL       DispChInfo
;;;825    			DispCh1Wave();
000214  f7fffffe          BL       DispCh1Wave
;;;826    			FFT_Convert();
000218  f7fffffe          BL       FFT_Convert
;;;827    		    StartADC();	  			 /* 开始采样 */
00021c  f7fffffe          BL       StartADC
                  |L10.544|
;;;828    		  }
;;;829    		  PROGBAR_SetValue(ahProgbar[0],OSCPUUsage);
000220  490e              LDR      r1,|L10.604|
000222  f9b10000          LDRSH    r0,[r1,#0]  ; ahProgbar
000226  4913              LDR      r1,|L10.628|
000228  7809              LDRB     r1,[r1,#0]  ; OSCPUUsage
00022a  f7fffffe          BL       PROGBAR_SetValue
                  |L10.558|
;;;830    	   }
;;;831    		GUI_Delay(50); 			 
00022e  2032              MOVS     r0,#0x32
000230  f7fffffe          BL       GUI_Delay
                  |L10.564|
000234  e7d4              B        |L10.480|
;;;832    	}
;;;833    }
;;;834    
                          ENDP

000236  0000              DCW      0x0000
                  |L10.568|
                          DCD      _cbBkWin
                  |L10.572|
                          DCD      GUI_Font16B_1
                  |L10.576|
                          DCD      ahButton
                  |L10.580|
000244  496e6300          DCB      "Inc",0
                  |L10.584|
000248  44656300          DCB      "Dec",0
                  |L10.588|
00024c  53776974          DCB      "Switch",0
000250  636800  
000253  00                DCB      0
                  |L10.596|
000254  53706563          DCB      "Spectr",0
000258  747200  
00025b  00                DCB      0
                  |L10.604|
                          DCD      ahProgbar
                  |L10.608|
                          DCD      WIDGET_Effect_3D
                  |L10.612|
                          DCD      ahScrollbar
                  |L10.616|
                          DCD      ConfigRefresh
                  |L10.620|
                          DCD      fRefresh
                  |L10.624|
                          DCD      g_DSO+0x6000
                  |L10.628|
                          DCD      OSCPUUsage

                          AREA ||i.SetSampRate||, CODE, READONLY, ALIGN=2

                  SetSampRate PROC
;;;242    */
;;;243     void SetSampRate(uint32_t freq)
000000  4902              LDR      r1,|L11.12|
;;;244    {
;;;245      TIM1->ARR=72000000 / freq;  									   //设定计数器自动重装值 
000002  fbb1f1f0          UDIV     r1,r1,r0
000006  4a02              LDR      r2,|L11.16|
000008  8011              STRH     r1,[r2,#0]
;;;246    }
00000a  4770              BX       lr
;;;247    /*
                          ENDP

                  |L11.12|
                          DCD      0x044aa200
                  |L11.16|
                          DCD      0x40012c2c

                          AREA ||i.StartADC||, CODE, READONLY, ALIGN=2

                  StartADC PROC
;;;593    */
;;;594    void StartADC(void)
000000  4817              LDR      r0,|L12.96|
;;;595    {
;;;596    	#if 1
;;;597    	  DMA1_Channel1->CPAR=ADC1_DR_Address; 	 				    //DMA1 外设地址 
000002  4918              LDR      r1,|L12.100|
000004  6108              STR      r0,[r1,#0x10]
;;;598    	  DMA1_Channel1->CMAR=(uint32_t)&g_DSO.buffer; 			    //DMA1,存储器地址
000006  4818              LDR      r0,|L12.104|
000008  6148              STR      r0,[r1,#0x14]
;;;599    	  DMA1_Channel1->CNDTR=SAMPLE_COUNT;    					//DMA1,传输数据量
00000a  1508              ASRS     r0,r1,#20
00000c  60c8              STR      r0,[r1,#0xc]
;;;600    	  DMA1_Channel1->CCR=0X00000000;							//复位
00000e  2000              MOVS     r0,#0
000010  6088              STR      r0,[r1,#8]
;;;601    	  DMA1_Channel1->CCR|=0<<4;  								//从外设来读
000012  4608              MOV      r0,r1
000014  6880              LDR      r0,[r0,#8]
000016  6088              STR      r0,[r1,#8]
;;;602    	  DMA1_Channel1->CCR|=0<<5;  								//普通模式
000018  4608              MOV      r0,r1
00001a  6880              LDR      r0,[r0,#8]
00001c  6088              STR      r0,[r1,#8]
;;;603    	  DMA1_Channel1->CCR|=0<<6;  								//外设地址非增量模式
00001e  4608              MOV      r0,r1
000020  6880              LDR      r0,[r0,#8]
000022  6088              STR      r0,[r1,#8]
;;;604    	  DMA1_Channel1->CCR|=1<<7;  								//存储器增量模式
000024  4608              MOV      r0,r1
000026  6880              LDR      r0,[r0,#8]
000028  f0400080          ORR      r0,r0,#0x80
00002c  6088              STR      r0,[r1,#8]
;;;605    	  DMA1_Channel1->CCR|=2<<8;  								//外设数据宽度为32位
00002e  4608              MOV      r0,r1
000030  6880              LDR      r0,[r0,#8]
000032  f4407000          ORR      r0,r0,#0x200
000036  6088              STR      r0,[r1,#8]
;;;606    	  DMA1_Channel1->CCR|=2<<10; 								//存储器数据宽度32位
000038  4608              MOV      r0,r1
00003a  6880              LDR      r0,[r0,#8]
00003c  f4406000          ORR      r0,r0,#0x800
000040  6088              STR      r0,[r1,#8]
;;;607    	  DMA1_Channel1->CCR|=2<<12; 								//高优先级
000042  4608              MOV      r0,r1
000044  6880              LDR      r0,[r0,#8]
000046  f4405000          ORR      r0,r0,#0x2000
00004a  6088              STR      r0,[r1,#8]
;;;608    	  DMA1_Channel1->CCR|=0<<14; 								//非存储器到存储器模式	
00004c  4608              MOV      r0,r1
00004e  6880              LDR      r0,[r0,#8]
000050  6088              STR      r0,[r1,#8]
;;;609       #endif
;;;610    
;;;611    	  DMA1_Channel1->CCR|=1;          							//开启DMA传输
000052  4608              MOV      r0,r1
000054  6880              LDR      r0,[r0,#8]
000056  f0400001          ORR      r0,r0,#1
00005a  6088              STR      r0,[r1,#8]
;;;612    	  //TIM1->CR1|=1;									    		//开启定时器1
;;;613    }
00005c  4770              BX       lr
;;;614     void DispFrame(void)
                          ENDP

00005e  0000              DCW      0x0000
                  |L12.96|
                          DCD      0x4001244c
                  |L12.100|
                          DCD      0x40020000
                  |L12.104|
                          DCD      g_DSO+0x1000

                          AREA ||i.StopADC||, CODE, READONLY, ALIGN=2

                  StopADC PROC
;;;497    */
;;;498     void StopADC(void)
000000  4803              LDR      r0,|L13.16|
;;;499    {
;;;500    		DMA1_Channel1->CCR&=0xffffffe;          					//关闭DMA传输
000002  6880              LDR      r0,[r0,#8]
000004  4903              LDR      r1,|L13.20|
000006  4008              ANDS     r0,r0,r1
000008  4901              LDR      r1,|L13.16|
00000a  6088              STR      r0,[r1,#8]
;;;501    }
00000c  4770              BX       lr
;;;502    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40020000
                  |L13.20|
                          DCD      0x0ffffffe

                          AREA ||i._cbBkWin||, CODE, READONLY, ALIGN=2

                  _cbBkWin PROC
;;;652    */
;;;653    static void _cbBkWin(WM_MESSAGE* pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;654    
;;;655      int NCode, Id;
;;;656      switch (pMsg->MsgId) {
000004  6828              LDR      r0,[r5,#0]
000006  280b              CMP      r0,#0xb
000008  d075              BEQ      |L14.246|
00000a  280c              CMP      r0,#0xc
00000c  d074              BEQ      |L14.248|
00000e  280f              CMP      r0,#0xf
000010  d002              BEQ      |L14.24|
000012  2826              CMP      r0,#0x26
000014  d171              BNE      |L14.250|
000016  e000              B        |L14.26|
                  |L14.24|
;;;657     case WM_PAINT:
;;;658        break;
000018  e085              B        |L14.294|
                  |L14.26|
;;;659     case WM_NOTIFY_PARENT: 
;;;660         Id = WM_GetId(pMsg->hWinSrc); 
00001a  f9b50006          LDRSH    r0,[r5,#6]
00001e  f7fffffe          BL       WM_GetId
000022  4606              MOV      r6,r0
;;;661         NCode = pMsg->Data.v;
000024  68ac              LDR      r4,[r5,#8]
;;;662          switch (Id) {        
000026  f5a66000          SUB      r0,r6,#0x800
00002a  2805              CMP      r0,#5
00002c  d273              BCS      |L14.278|
00002e  e8dff000          TBB      [pc,r0]
000032  0316              DCB      0x03,0x16
000034  293e6500          DCB      0x29,0x3e,0x65,0x00
;;;663          case GUI_ID_ADC:
;;;664    	      switch(NCode)
000038  2c02              CMP      r4,#2
00003a  d10e              BNE      |L14.90|
;;;665              {
;;;666                case WM_NOTIFICATION_RELEASED:
;;;667    				if (g_DSO.AdjustMode == 0)		   /* 调节幅度放大倍数 */
00003c  483b              LDR      r0,|L14.300|
00003e  f890002f          LDRB     r0,[r0,#0x2f]
000042  b920              CBNZ     r0,|L14.78|
;;;668    				{
;;;669    					AdjustAtt(1, 1);
000044  2101              MOVS     r1,#1
000046  4608              MOV      r0,r1
000048  f7fffffe          BL       AdjustAtt
00004c  e001              B        |L14.82|
                  |L14.78|
;;;670    				}
;;;671    				else 							    /* 调节上下偏移 */
;;;672    				{
;;;673    					DecSampleFreq();  				/* 递增采样频率 */	
00004e  f7fffffe          BL       DecSampleFreq
                  |L14.82|
;;;674    				}
;;;675    				fRefresh = 1;				        /* 请求刷新LCD */
000052  2001              MOVS     r0,#1
000054  4936              LDR      r1,|L14.304|
000056  7008              STRB     r0,[r1,#0]
;;;676                     break;
000058  bf00              NOP      
                  |L14.90|
00005a  bf00              NOP      
;;;677              }
;;;678            break;				  
00005c  e05b              B        |L14.278|
;;;679    	  case GUI_ID_DAC:
;;;680    	      switch(NCode)
00005e  2c02              CMP      r4,#2
000060  d10e              BNE      |L14.128|
;;;681              {
;;;682                case WM_NOTIFICATION_RELEASED:
;;;683    				if (g_DSO.AdjustMode == 0)		   /* 调节幅度放大倍数 */
000062  4832              LDR      r0,|L14.300|
000064  f890002f          LDRB     r0,[r0,#0x2f]
000068  b920              CBNZ     r0,|L14.116|
;;;684    				{
;;;685    					AdjustAtt(1, 0);
00006a  2100              MOVS     r1,#0
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       AdjustAtt
000072  e001              B        |L14.120|
                  |L14.116|
;;;686    				}
;;;687    				else 							    /* 调节上下偏移 */
;;;688    				{
;;;689    					IncSampleFreq();				   /* 递减采样频率 */
000074  f7fffffe          BL       IncSampleFreq
                  |L14.120|
;;;690    				}
;;;691    				fRefresh = 1;				        /* 请求刷新LCD */
000078  2001              MOVS     r0,#1
00007a  492d              LDR      r1,|L14.304|
00007c  7008              STRB     r0,[r1,#0]
;;;692                    break;
00007e  bf00              NOP      
                  |L14.128|
000080  bf00              NOP      
;;;693              }
;;;694            break;
000082  e048              B        |L14.278|
;;;695    	  case GUI_ID_FFT:   
;;;696    	   	  switch(NCode)
000084  2c02              CMP      r4,#2
000086  d110              BNE      |L14.170|
;;;697              {
;;;698                case WM_NOTIFICATION_RELEASED:
;;;699    				if (g_DSO.AdjustMode == 0)		   
000088  4828              LDR      r0,|L14.300|
00008a  f890002f          LDRB     r0,[r0,#0x2f]
00008e  b920              CBNZ     r0,|L14.154|
;;;700    				{
;;;701    					g_DSO.AdjustMode = 1;
000090  2101              MOVS     r1,#1
000092  4826              LDR      r0,|L14.300|
000094  f880102f          STRB     r1,[r0,#0x2f]
000098  e003              B        |L14.162|
                  |L14.154|
;;;702    				}
;;;703    				else
;;;704    				{
;;;705    					g_DSO.AdjustMode = 0;
00009a  2100              MOVS     r1,#0
00009c  4823              LDR      r0,|L14.300|
00009e  f880102f          STRB     r1,[r0,#0x2f]
                  |L14.162|
;;;706    				}
;;;707    				fRefresh = 1;						/* 请求刷新LCD */
0000a2  2001              MOVS     r0,#1
0000a4  4922              LDR      r1,|L14.304|
0000a6  7008              STRB     r0,[r1,#0]
;;;708                     break;
0000a8  bf00              NOP      
                  |L14.170|
0000aa  bf00              NOP      
;;;709              }
;;;710            break;
0000ac  e033              B        |L14.278|
;;;711    	  case GUI_ID_Spectrum:
;;;712    	       switch(NCode)
0000ae  2c02              CMP      r4,#2
0000b0  d11f              BNE      |L14.242|
;;;713    	       {
;;;714    	         case WM_NOTIFICATION_RELEASED:
;;;715                    if(SpectrumFlag == 1)
0000b2  4820              LDR      r0,|L14.308|
0000b4  7800              LDRB     r0,[r0,#0]  ; SpectrumFlag
0000b6  2801              CMP      r0,#1
0000b8  d10d              BNE      |L14.214|
;;;716    				{
;;;717    				   GUI_Clear();
0000ba  f7fffffe          BL       GUI_Clear
;;;718    				   DispButton();
0000be  f7fffffe          BL       DispButton
;;;719    				   SpectrumFlag = 0;
0000c2  2000              MOVS     r0,#0
0000c4  491b              LDR      r1,|L14.308|
0000c6  7008              STRB     r0,[r1,#0]
;;;720    				   BUTTON_SetText(ahButton[3],"Spectr");
0000c8  491b              LDR      r1,|L14.312|
0000ca  f9b10006          LDRSH    r0,[r1,#6]  ; ahButton
0000ce  a11b              ADR      r1,|L14.316|
0000d0  f7fffffe          BL       BUTTON_SetText
0000d4  e00c              B        |L14.240|
                  |L14.214|
;;;721    				}
;;;722    				else
;;;723    				{
;;;724    				   GUI_Clear();
0000d6  f7fffffe          BL       GUI_Clear
;;;725    				   DispButton();
0000da  f7fffffe          BL       DispButton
;;;726    				   SpectrumFlag = 1;
0000de  2001              MOVS     r0,#1
0000e0  4914              LDR      r1,|L14.308|
0000e2  7008              STRB     r0,[r1,#0]
;;;727    				   BUTTON_SetText(ahButton[3],"Spetrum2");
0000e4  4914              LDR      r1,|L14.312|
0000e6  f9b10006          LDRSH    r0,[r1,#6]  ; ahButton
0000ea  a116              ADR      r1,|L14.324|
0000ec  f7fffffe          BL       BUTTON_SetText
                  |L14.240|
;;;728    				}   
;;;729    	            break;
0000f0  bf00              NOP      
                  |L14.242|
0000f2  bf00              NOP      
;;;730    	       }
;;;731            break;
0000f4  e00f              B        |L14.278|
                  |L14.246|
0000f6  e011              B        |L14.284|
                  |L14.248|
0000f8  e00f              B        |L14.282|
                  |L14.250|
0000fa  e010              B        |L14.286|
;;;732    	   case GUI_ID_OSCLevel:
;;;733    	         switch(NCode)
0000fc  2c05              CMP      r4,#5
0000fe  d108              BNE      |L14.274|
;;;734                {
;;;735                    case WM_NOTIFICATION_VALUE_CHANGED:
;;;736                        g_DSO.Ch1VOffset = SCROLLBAR_GetValue(ahScrollbar[0]);
000100  4913              LDR      r1,|L14.336|
000102  f9b10000          LDRSH    r0,[r1,#0]  ; ahScrollbar
000106  f7fffffe          BL       SCROLLBAR_GetValue
00010a  b201              SXTH     r1,r0
00010c  4807              LDR      r0,|L14.300|
00010e  8541              STRH     r1,[r0,#0x2a]
;;;737                        break;
000110  bf00              NOP      
                  |L14.274|
000112  bf00              NOP      
;;;738                }
;;;739                break;   
000114  bf00              NOP      
                  |L14.278|
000116  bf00              NOP                            ;678
;;;740          }
;;;741    	 break;
000118  e005              B        |L14.294|
                  |L14.282|
;;;742     case WM_TOUCH:
;;;743    
;;;744         break;
00011a  e004              B        |L14.294|
                  |L14.284|
;;;745     case WM_DELETE:
;;;746    
;;;747         break;
00011c  e003              B        |L14.294|
                  |L14.286|
;;;748      default:
;;;749        WM_DefaultProc(pMsg);
00011e  4628              MOV      r0,r5
000120  f7fffffe          BL       WM_DefaultProc
000124  bf00              NOP                            ;656
                  |L14.294|
000126  bf00              NOP                            ;658
;;;750      }
;;;751    }
000128  bd70              POP      {r4-r6,pc}
;;;752    /*********************************************************************
                          ENDP

00012a  0000              DCW      0x0000
                  |L14.300|
                          DCD      g_DSO+0x5000
                  |L14.304|
                          DCD      fRefresh
                  |L14.308|
                          DCD      SpectrumFlag
                  |L14.312|
                          DCD      ahButton
                  |L14.316|
00013c  53706563          DCB      "Spectr",0
000140  747200  
000143  00                DCB      0
                  |L14.324|
000144  53706574          DCB      "Spetrum2",0
000148  72756d32
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L14.336|
                          DCD      ahScrollbar

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_DSO
                          %        25064

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_TimeTable
                          DCD      0x00000010
                          DCD      0x00000014
                          DCD      0x00000028
                          DCD      0x00000064
                          DCD      0x000000c8
                          DCD      0x00000190
                          DCD      0x000003e8
                          DCD      0x000007d0
                          DCD      0x00000fa0
                          DCD      0x00002710
                          DCD      0x00004e20
                          DCD      0x00009c40
                          DCD      0x000186a0
                          DCD      0x00030d40
                          DCD      0x00061a80
                          DCD      0x000f4240
                  g_AttTable
                          DCD      0x000005aa
                          DCD      0x00001388
                          DCD      0x00000244
                          DCD      0x000007d0
                          DCD      0x00000122
                          DCD      0x000003e8
                          DCD      0x00000091
                          DCD      0x000001f4
                          DCD      0x0000003a
                          DCD      0x000000c8
                          DCD      0x0000001d
                          DCD      0x00000064
                          DCD      0x0000000f
                          DCD      0x00000032
                          DCD      0x00000006
                          DCD      0x00000014
                          DCD      0x00000003
                          DCD      0x0000000a

                          AREA ||.data||, DATA, ALIGN=2

                  SpectrumFlag
000000  00                DCB      0x00
                  fRefresh
000001  00                DCB      0x00
                  ConfigRefresh
000002  0000              DCB      0x00,0x00
                  Clock_count
                          DCD      0x00000000
                  Clock
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  ahButton
                          %        8
                  ahProgbar
000014  0000              DCB      0x00,0x00
                  ahScrollbar
000016  0000              DCB      0x00,0x00
